<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>置顶</title>
    <url>/9999/05/13/%E7%BD%AE%E9%A1%B6/</url>
    <content><![CDATA[<p><strong>简单描述一下我的博客</strong>：</p>
<p>首先这是一个萌新成长过程的记录，不是一个大佬的经验分享。其次懂得越多，越觉得自己写的烂，所以更新越来越慢，是因为有太多东西没有消化，不想写一些烂的东西。</p>
<p><strong>补充</strong>，除部分自己分享的，还有很多整理搬运的，有一些忘记贴参考链接，后面更的能找到都会贴上。</p>
<p><strong>时间线：</strong></p>
<p>2022年11月13日21:57:44</p>
<p>然后每回过头看一遍我的博客，就会删除一些旧的文章，会的越多不会的越多，现在还不知道写些什么，目前在学习c++，后续可能会写一些c++相关的东西?</p>
<p>2021年12月11日22:33:23</p>
<p>不小心把一个备案域名解析到香港服务器了，备案失效了，导致七牛云的资源全部下不下来了。。</p>
<p>然后找了下用 <code>qshell</code> 这个工具，自己写了个<a href="https://github.com/ruomuc/practice/blob/master/shells/qniu-download.sh">shell脚本</a>，把资源全部转移到自己的服务器上了，慢就慢吧。。</p>
<p>2021年11月10日21:03:38</p>
<p>删除了一些之前流水账博文，并且很久没有写新的博文了，因为最近在考驾照，然后还开启了健身计划。。<br>对学习的东西也有些迷茫，长时间不学习就会变懒。。。（叹气~）</p>
<p>2021年06月14日21:30:20</p>
<p>力扣被动态规划整麻了，加上时间问题，暂时搁置了，每日打卡刷了300道题提升不是太明显，感觉需要按标签刷。</p>
<p>最近找了两个比较好的学习go的外国网站，都是实战的：</p>
<ul>
<li><a href="https://gophercises.com/">https://gophercises.com/</a></li>
<li><a href="https://www.hackerrank.com/">https://www.hackerrank.com/</a>  hackerrank这么牛逼的网站我之前居然不知道。。。</li>
</ul>
<p>一直在敲代码，博客更的比较慢，已经敲了不少了，收获还是蛮大的。</p>
<p>2021年03月28日22:02:44</p>
<p>封闭开发快结束了！抽时间想了一下学习方向。</p>
<span id="more"></span>

<ol>
<li><p>力扣继续打开每日一题，先坚持个一年看看效果（目前4/12），以提高整体水平为主，不为面试。</p>
</li>
<li><p>继续看《你不知道的JavaScript》系列，感觉之前对js的很多困惑瞬间想明白了。（目前上卷刚看完）</p>
</li>
<li><p>新语言的话：</p>
<ul>
<li><p>go 还是先只是用来刷题，有空找个demo练练手，转的话还有难度的，因为现在公司没有go的技术栈。</p>
</li>
<li><p>typescript 肯定是要学的，顺便学习一下 oop 的思想。</p>
</li>
<li><p>前端准备学习下 vue，公司有这个技术栈，抽时间看一看之后，也有项目练手。</p>
</li>
<li><p>最后是 c#，暂时没有学习的计划，无聊可以了解一下。主要因为公司桌面端主要技术栈是 c#，如果考虑长期待下去的话，可以观望一下，而且 c# 和 winform devexpress这些了解了一下，也不是一下子学得会的。</p>
</li>
</ul>
</li>
</ol>
<p>2021年2月28日18:06:47:</p>
<p>过完年又开始封闭了,听说要到三月底,一周90多小时的上班时长,也没加班费,真的想跑了。</p>
<p>2021年2月7日15:05:48:</p>
<p>结束了一个多月的封闭开发，完全打乱了我的学习计划和状态，只能过年期间调整一下了。</p>
<p>2020年10月28日23:11:15:</p>
<p>可以使用<a href="http://blog.seeln.com/">blog.seeln.com</a>访问博客了^_^。</p>
<p>2020年8月15日13:59:31:</p>
<p>新公司入职一周，抓紧熟悉新新环境新技术中。。每天下班回来也只有刷一道leet-code的时间，就睡觉了。</p>
<p>2020年06月27日18:43:51:</p>
<p>上周六截止今天，去青海湖环湖骑行去了，没有更新，尽量补上……</p>
<p>2020年05月24日22:57:45:</p>
<p>最近疯狂充电</p>
<p>2020年05月13日13:10:48:</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>go的接口和类型</title>
    <url>/2022/02/27/go%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>二刷 the go programming language，接口这块第一遍没太懂，第二遍大概懂了。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>go语言的接口的独特之处在于，它是隐式实现的。</p>
<p>对于一个具体的类型，你不需要声明它实现了哪些接口，只需要提供接口所必须的方法即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// io.go</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123;</span><br><span class="line">	*file <span class="comment">// os specific</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Write(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">//... 此处省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像标准库的  file 类型，提供了 Write 方法后，就会隐式的实现 Writer 接口。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>对于传统的面向对象语言，实现接口的目的是可以使用不同的类型调用接口值的方法，即<strong>多态</strong>。</p>
<p>go 语言中的类型可以分为 具体类型 和 接口类型：</p>
<ul>
<li>具体类型，比如 string、slice 等。</li>
<li>接口类型：接口类型是一种 抽象类型，它并没有暴露所含数据的布局和结构，它所提供的仅仅是一些方法而已。如果你拿到一个接口类型，你不能知道它是什么，但你可以知道它能做什么（提供的方法）。</li>
<li>从具体类型出发，提取其共性而得出的每一种分组方式，都可以表示为一种接口类型。</li>
</ul>
<h2 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h2><p>一个接口的接口值分为两个部分：</p>
<ul>
<li>具体类型，又称为 接口的动态类型。</li>
<li>具体类型的值，又称为 接口的动态值。</li>
</ul>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/go%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E5%9E%8B.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">w = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>分析代码片段：</p>
<table>
<thead>
<tr>
<th>行数</th>
<th>接口类型</th>
<th>接口值</th>
<th>动态类型</th>
<th>动态值</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>io.Writer</td>
<td>nil</td>
<td>nil</td>
<td>nil</td>
<td>一个接口值是否为 nil，取决于它的动态类型和动态值是否都是 nil</td>
</tr>
<tr>
<td>2</td>
<td>io.Writer</td>
<td></td>
<td>*os.File</td>
<td>一个指向代表进程标准输出的 os.File 的指针</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>io.Writer</td>
<td></td>
<td>*bytes.Buffer</td>
<td>一个指向新分配缓冲区的指针</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>io.Writer</td>
<td>nil</td>
<td>nil</td>
<td>nil</td>
<td></td>
</tr>
</tbody></table>
<h3 id="含有空指针的非空接口"><a href="#含有空指针的非空接口" class="headerlink" title="含有空指针的非空接口"></a>含有空指针的非空接口</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> debug = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line">	fmt.Println(reflect.ValueOf(buf))</span><br><span class="line">	<span class="keyword">if</span> debug &#123;</span><br><span class="line">		buf = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	f(buf)</span><br><span class="line">	<span class="keyword">if</span> debug &#123;</span><br><span class="line">		<span class="comment">// do something...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out io.Writer)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...其他代码...</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T, %v\n&quot;</span>, out, reflect.ValueOf(out))</span><br><span class="line">	<span class="keyword">if</span> out != <span class="literal">nil</span> &#123;</span><br><span class="line">		out.Write([]<span class="type">byte</span>(<span class="string">&quot;done!\n&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码在 debug=false 时会报错。</p>
<p>因为如果 debug=false，f 函数调用时，out参数是一个<strong>含有空指针的非空接口</strong>（  一个接口值是否为 nil，取决于它的动态类型和动态值是否都是 nil，这里out的动态类型不是nil，而动态值是nil）。</p>
<p>此时 out != nil 的结果为 true，但当调用 out.Write 时，会发现 动态值为 nil， 所以会报错。 </p>
<p>如果把 <code>var buf *bytes.Buffer</code> 改为 <code>var buf io.Writer</code> 就可以了。</p>
<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>类型断言就是一个作用在接口值上的操作，写作<code>x.(T)</code>，其中 x 是一个接口类型，T 是一个类型（称为断言类型）。</p>
<ol>
<li>当 T 是一个具体类型时，类型断言就是从来从它的操作数中把<strong>具体类型的值</strong>提取出来的操作。如果检查失败，程序崩溃。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer <span class="comment">// w 接口类型为 io.Writer</span></span><br><span class="line">w = os.Stdout <span class="comment">// w 具体类型为 *os.File, 具体值 os.Stdout 副本（一个指针）</span></span><br><span class="line">f := w.(*os.File) <span class="comment">// f == os.Stdout</span></span><br><span class="line">c := w.(*bytes.Buffer) <span class="comment">// 程序崩溃</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>当 T 是一个接口类型时，那么类型断言检查 x 的动态类型是否满足 T。无论是否成功，只有<strong>结果的接口类型</strong>变为 T，其他都没变。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">rw := w.(io.ReadWriter) <span class="comment">// 成功，*os.File有 Read 和 Write 方法， rw 的接口类型为 io.ReadWriter</span></span><br><span class="line"></span><br><span class="line">w = <span class="built_in">new</span>(ByteCounter)</span><br><span class="line">rw := w.(io.ReadWriter) <span class="comment">// 崩溃：*ByteCounter 没有 Read 方法</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如果操作数是一个空接口，类型断言总会失败。</li>
</ol>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解nodejs内存分配</title>
    <url>/2021/12/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3nodejs%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<p>因为最近遇到很多关于内存的问题，所以决定再次探究回顾一下 node.js 相关的内存知识。</p>
<p>再次删除了一些之前的关于node.js内存的博文，因为在现在看来那些写的太垃圾了。</p>
<h2 id="内存的生命周期"><a href="#内存的生命周期" class="headerlink" title="内存的生命周期"></a>内存的生命周期</h2><ul>
<li>内存分配：由 JavaScript 内部为我们分配内存。</li>
<li>内存使用：由代码来读取内存的数据，或向内存写入数据（比如赋值语句）。</li>
<li>内存释放：由 JavaScript 引擎来进行，内存释放后，可以被 JavaScript 重新分配。</li>
</ul>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/node.js%E5%86%85%E5%AD%98%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p>
<h2 id="栈（Stack）和堆（Heap）"><a href="#栈（Stack）和堆（Heap）" class="headerlink" title="栈（Stack）和堆（Heap）"></a>栈（Stack）和堆（Heap）</h2><h3 id="堆栈和堆的概念"><a href="#堆栈和堆的概念" class="headerlink" title="堆栈和堆的概念"></a>堆栈和堆的概念</h3><p>在数据结构中：</p>
<blockquote>
<p>栈的结构比较好理解，一种线性结构，限制：只允许一端出入。所以栈的特点是<strong>LIFO(Last In First Out)后进先出</strong>。</p>
<p>堆在数据结构中是一种特殊的完全二叉树，所以是一种树状结构。</p>
</blockquote>
<p>在计算机内存分配中：</p>
<blockquote>
<p><strong>堆（heap）和栈（stack）是两种内在的管理形式</strong>。</p>
<p>它们的主要区别是stack按次序排放，大小明确；heap结构则不固定，是一种可动态分配和释放的内存。单从这一点看，stack的寻址速度要比heap快，heap的灵活性则比较高。一般来说，每个线程分配一个stack，每个进程分配一个heap。</p>
</blockquote>
<h3 id="栈内存分配"><a href="#栈内存分配" class="headerlink" title="栈内存分配"></a>栈内存分配</h3><p>栈是 JavaScript 用来存储静态数据的数据结构。</p>
<p>静态数据就是引擎在编译时就知道大小的数据。</p>
<p>在程序运行前分配内存的过程称为<strong>静态内存分配</strong>。</p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/nodejs%E6%A0%88%E5%86%85%E5%AD%98.png"></p>
<span id="more"></span>
<p>原始值在进行相互赋值时，内存是如何分配的呢？</p>
<p>可以发现，变量指向的还是一个内存地址，由于栈内存中存储的原始值是不可变的，所以对 nextAge 进行 +1 操作时，会重新分配一个地址存储新的值，并且把 nextAge 指向新的地址。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">25</span></span><br><span class="line"><span class="keyword">let</span> nextAge = age</span><br><span class="line">nextAge = nextAge + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/nodejs%E6%A0%88%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D2.png"></p>
<h3 id="堆内存分配"><a href="#堆内存分配" class="headerlink" title="堆内存分配"></a>堆内存分配</h3><p>ps : 堆内存 和 数据结构里的堆，是没有任何关系的。。只是 Heap 这个单词背沿用了下来。参见：<a href="https://www.zhihu.com/question/276016774/answer/385381844">堆内存和数据结构堆之间的关系是什么？ - 詹姆斯.通的回答 - 知乎</a></p>
<hr>
<p>堆是 JavaScript 用来存储 对象和函数等数据类型的空间。</p>
<p>JavaScript 在编译期间无法知道它们所需内存大小，所以只有在运行时进行内存分配。</p>
<p>在程序运行时分配内存的过程称为<strong>动态内存分配</strong>。</p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/nodejs%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.png"></p>
<p>并且如果修改了 newCat 的 name 字段。 cat 的 name 字段也会改变：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cat = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;mimi&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> target.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newCat = cat</span><br><span class="line">newCat.<span class="property">name</span> = <span class="string">&#x27;miaomiao&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getName</span>(cat)) <span class="comment">// miaomiao</span></span><br></pre></td></tr></table></figure>

<h3 id="堆栈溢出"><a href="#堆栈溢出" class="headerlink" title="堆栈溢出"></a>堆栈溢出</h3><p>JavaScript 中使用没有终止条件的递归调用，会产生堆栈溢出的报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">recurse</span> () &#123;</span><br><span class="line">  <span class="title function_">recurse</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">recurse</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// RangeError: Maximum call stack size exceeded</span></span><br><span class="line"><span class="comment">//     at recurse (/Users/zhangming/ownspace/local-test/test9/index.js:17:13)</span></span><br><span class="line"><span class="comment">//     at recurse (/Users/zhangming/ownspace/local-test/test9/index.js:18:3)</span></span><br><span class="line"><span class="comment">//     at recurse (/Users/zhangming/ownspace/local-test/test9/index.js:18:3)</span></span><br><span class="line"><span class="comment">//     at recurse (/Users/zhangming/ownspace/local-test/test9/index.js:18:3)</span></span><br><span class="line"><span class="comment">//     at recurse (/Users/zhangming/ownspace/local-test/test9/index.js:18:3)</span></span><br><span class="line"><span class="comment">//     at recurse (/Users/zhangming/ownspace/local-test/test9/index.js:18:3)</span></span><br><span class="line"><span class="comment">//     at recurse (/Users/zhangming/ownspace/local-test/test9/index.js:18:3)</span></span><br><span class="line"><span class="comment">//     at recurse (/Users/zhangming/ownspace/local-test/test9/index.js:18:3)</span></span><br><span class="line"><span class="comment">//     at recurse (/Users/zhangming/ownspace/local-test/test9/index.js:18:3)</span></span><br><span class="line"><span class="comment">//     at recurse (/Users/zhangming/ownspace/local-test/test9/index.js:18:3)</span></span><br></pre></td></tr></table></figure>

<p>但是这里的堆栈，指的是 调用堆栈（call stack），不一定和上文的堆栈使用同一内存空间。</p>
<h3 id="OOM（out-of-memory）"><a href="#OOM（out-of-memory）" class="headerlink" title="OOM（out of memory）"></a>OOM（out of memory）</h3><p>这个报错可以说时很常见了。</p>
<p>因为本地默认的堆内存比较大，要使用<code>node --max-old-space-size=10 index.js</code>命令可以更快得到 oom 错误信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; memoryUsage &#125; = <span class="built_in">require</span>(<span class="string">&#x27;process&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">oom</span> () &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000000</span>; i++) &#123;</span><br><span class="line">    obj[i] = &#123; [i * i]: i * i&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">oom</span>()</span><br></pre></td></tr></table></figure>

<p>日志太多了，截取一部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;--- Last few GCs ---&gt;</span><br><span class="line"></span><br><span class="line">[11306:0x1048f3000]     1098 ms: Mark-sweep 4.9 (8.3) -&gt; 3.9 (8.3) MB, 3.4 / 0.0 ms  (average mu = 0.932, current mu = 0.932) allocation failure scavenge might not succeed</span><br><span class="line">[11306:0x1048f3000]     1147 ms: Mark-sweep 5.0 (8.3) -&gt; 4.0 (8.6) MB, 2.3 / 0.0 ms  (average mu = 0.943, current mu = 0.954) allocation failure scavenge might not succeed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;--- JS stacktrace ---&gt;</span><br><span class="line"></span><br><span class="line">FATAL ERROR: MarkCompactCollector: young object promotion failed Allocation failed - JavaScript heap out of memory</span><br><span class="line"> 1: 0x10130d6e5 node::Abort() (.cold.1) [/Users/zhangming/.nvm/versions/node/v14.17.0/bin/node]</span><br><span class="line"> 2: 0x1000b1c49 node::Abort() [/Users/zhangming/.nvm/versions/node/v14.17.0/bin/node]</span><br><span class="line"> 3: 0x1000b1daf node::OnFatalError(char const*, char const*) </span><br></pre></td></tr></table></figure>

<h2 id="大对象内存占用"><a href="#大对象内存占用" class="headerlink" title="大对象内存占用"></a>大对象内存占用</h2><h3 id="如何查看对象的内存占用"><a href="#如何查看对象的内存占用" class="headerlink" title="如何查看对象的内存占用"></a>如何查看对象的内存占用</h3><ul>
<li><a href="https://www.npmjs.com/package/object-sizeof">object-sizeof</a></li>
<li>chrome 的内存快照</li>
</ul>
<p>object-sizeof 是根据 <a href="https://262.ecma-international.org/5.1/#sec-4.3.16">ECMAScript标准</a>，对对象大小的一个估算，一般会比 chrome 的内存快照大一些，因为引擎在最终存储时可能会做一些优化。</p>
<ul>
<li>String 2字节</li>
<li>Boolean 4字节</li>
<li>Number 8字节</li>
</ul>
<p>举例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sizeof = <span class="built_in">require</span>(<span class="string">&#x27;object-sizeof&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;mimi&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">isMale</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sizeof</span>(cat)) <span class="comment">// 58</span></span><br></pre></td></tr></table></figure>



<h3 id="JSON和对象"><a href="#JSON和对象" class="headerlink" title="JSON和对象"></a>JSON和对象</h3><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul>
<li>JSON（JavaScript Object Notation）虽然全程含有 JavaScript，但不是只有 JavaScript 可以使用，JSON 是 JavaScript 的一个子集。</li>
<li>JSON 是一种轻量级的资料交换格式。 类似的还有 protobuf 等。</li>
<li>Object 是 JavaScript 的一种 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures">数据类型</a> 。它用于存储各种键值集合和更复杂的实体。</li>
<li>在 JavaScript 中 json 数据可以很简单的转化为 object ，当然其它语言使用对应的解析器也可以做到。</li>
</ul>
<h4 id="互相转换"><a href="#互相转换" class="headerlink" title="互相转换"></a>互相转换</h4><p>JavaScript 内置了 <code>JSON.parse()</code> 和 <code>JSON.stringify()</code> 来进行 JSON 和 Object 的相互转换。</p>
<p>json方法的实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">global</span>.<span class="property">JSON</span>.<span class="property">parse</span>.<span class="title function_">toString</span>()</span><br><span class="line"><span class="comment">//  function parse() &#123; [native code] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">global</span>.<span class="property">JSON</span>.<span class="property">stringify</span>.<span class="title function_">toString</span>()</span><br><span class="line"><span class="comment">// function stringify() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>

<p>关于 native code：</p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/WX20211226-125734.png"></p>
<p>json源码的位置：deps/v8/src/json-parser.cc</p>
<h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p>上面可以看到，一个json对象，转换成JavaScript对象后，占用内存会几倍的增大。</p>
<p>所以开发中会遇到 JSON.parse 一个大对象后，内存容易OOM。</p>
<p>这里有两个简单的节省内存的方法：</p>
<p>第一种，减少key的数量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123;<span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为:</span></span><br><span class="line">[</span><br><span class="line">  [a, b],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>第二种，大json使用分隔符分隔：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化为一个文件</span></span><br><span class="line">&#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;\n&#123;<span class="attr">a</span>:<span class="number">3</span>, <span class="attr">b</span>:<span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

<p>因为解析小的json速度会更快：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;[&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;,&#123;&quot;a&quot;:3,&quot;b&quot;:4&#125;]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(a)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&#x27;big&#x27;</span>) <span class="comment">// 0.315ms</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a1 = <span class="string">&#x27;&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;&#x27;</span></span><br><span class="line"><span class="keyword">const</span> a2 = <span class="string">&#x27;&#123;&quot;a&quot;:3,&quot;b&quot;:4&#125;&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&#x27;small&#x27;</span>)</span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(a1)</span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(a2)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&#x27;small&#x27;</span>) <span class="comment">// 0.01ms</span></span><br></pre></td></tr></table></figure>



<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>垃圾回收前面已经讲过很多了，参见：</p>
<p><a href="https://www.seeln.com/2018/07/31/V8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6/#V8%E7%9A%84%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6">V8的垃圾回收机制和内存限制</a></p>
<p><a href="https://www.seeln.com/2021/05/15/golang%E7%9A%84gc/">golang的gc</a></p>
]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>囚徒健身</title>
    <url>/2021/12/11/%E5%9B%9A%E5%BE%92%E5%81%A5%E8%BA%AB/</url>
    <content><![CDATA[<p>最近天气冷了，里三件外三件，去健身房换衣服太麻烦还容易感冒，不太想去了。</p>
<p>之前别人安利过《囚徒健身》这本书，看了下感觉理念还不错，还可以在家练，记录一下关键动作，方便查阅。（目前每个动作先记录了前两式，后面的根本做不到，等前面能做到了再记录后面更难的动作）</p>
<h2 id="俯卧撑"><a href="#俯卧撑" class="headerlink" title="俯卧撑"></a>俯卧撑</h2><h3 id="第一式-墙壁俯卧撑"><a href="#第一式-墙壁俯卧撑" class="headerlink" title="第一式 墙壁俯卧撑"></a>第一式 墙壁俯卧撑</h3><p>面对墙壁站立，双脚并拢，双臂伸直，与肩 同宽，双手平放在墙上，手掌与胸等高。这是该 动作的起始姿势（图 1）。</p>
<p>弯曲肘部，直到前额 轻触墙面。这是该动作的结束姿势（图 2）。</p>
<p>然后将自己推回到起始姿势，如此重复。</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsfwc1-1.png" style="zoom:50%;" />

<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsfwc1-2.png" style="zoom:50%;" />

<ul>
<li>初级标准：1 组， 10次</li>
<li>中级标准：2 组， 各25次</li>
<li>高级标准：3组，各50次</li>
</ul>
<h3 id="第二式-上斜俯卧撑"><a href="#第二式-上斜俯卧撑" class="headerlink" title="第二式 上斜俯卧撑"></a>第二式 上斜俯卧撑</h3><p>做这个动作需要借助一个稳固的物体，高度 大约是你身高的一半（大概到臀部位置）。</p>
<p>双脚并拢，身体成一条直线，然后 前倾上身，双臂伸直，双手抓住所选物体，与肩 同宽。这是该动作的起始姿势（图 3）。</p>
<p>弯曲肘部，放低身体，直到胸部轻触物体顶 部。如果你选择的物体高度合适，那么此时你的 身体与地面的夹角约为 45°（图 4）。</p>
<p>暂停一 会，然后将自己推回到起始姿势，如此重复。</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsfwc1-3.png" style="zoom:50%;" />

<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsfwc1-4.png" style="zoom:50%;" />

<ul>
<li>初级标准：1 组， 10次</li>
<li>中级标准：2 组， 各20次</li>
<li>高级标准：3组，各40次</li>
</ul>
<h3 id="第三式-膝盖俯卧撑"><a href="#第三式-膝盖俯卧撑" class="headerlink" title="第三式 膝盖俯卧撑"></a>第三式 膝盖俯卧撑</h3><p>双脚并拢，双膝着地。双臂伸直，与肩同宽。双手在胸部的正下方，两个手掌平放在地面上。</p>
<p>脚踝搭在一起，大腿与上身及头部成一条直线，不要撅屁股或者塌腰。这是该动作的起始姿势（图 5）。</p>
<p>然后以膝盖为支点，弯曲肘部，直到胸部与地面仅一拳之隔（图 6）。</p>
<p>暂停一下，然后将自己推回到起始姿势，如此重复。</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsfwc1-5.png" style="zoom:50%;" />

<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsfwc1-6.png" style="zoom:50%;" />

<ul>
<li>初级标准：1 组， 10次</li>
<li>中级标准：2 组， 各15次</li>
<li>高级标准：3组，各30次</li>
</ul>
<h3 id="第四式-半俯卧撑"><a href="#第四式-半俯卧撑" class="headerlink" title="第四式 半俯卧撑"></a>第四式 半俯卧撑</h3><p>跪在地板上，双手撑地，双腿向后蹬直。双手与肩同宽，并处于上胸部的正下方。</p>
<p>双腿双脚并拢，锁紧身体，使上身、髋部和双腿成一条直线。</p>
<p>先伸直手臂，然后降低身体到大约一半臂长的高度，或者直到肘部弯成直角。</p>
<p>控制下降高度的绝佳方式就是使用篮球或橄榄球——将球放在髋部下方。这是该动作的起始姿势（图 7）。</p>
<p>接下来，弯曲肘部，直到髋部与球轻轻接触（图8）。</p>
<p>对大多数人来说，这样可以方便且客观地标示这个动作的最低点。暂停一下，然后用力将自己推回到起始姿势。</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsfwc1-7.png" style="zoom:50%;" />

<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsfwc1-8.png" style="zoom:50%;" />

<ul>
<li>初级标准：1 组， 8次</li>
<li>中级标准：2 组， 各12次</li>
<li>高级标准：2 组，各25次</li>
</ul>
<h3 id="第五式-标准俯卧撑"><a href="#第五式-标准俯卧撑" class="headerlink" title="第五式 标准俯卧撑"></a>第五式 标准俯卧撑</h3><p>跪在地板上，双手撑地，双腿向后蹬直。双腿双脚并拢，双手与肩同宽，并处于上胸部的正下方。</p>
<p>双臂伸直，臀部与脊椎成一条直线。这是该动作的起始姿势（图 9）。</p>
<p>接着，弯曲肘部，直至胸部与地面仅一拳之隔。监狱里进行俯卧撑比赛时，计数者会握拳，让小拇指一侧紧贴地面，这样只需数参赛者胸部接触自己大拇指的次 </p>
<p>数即可若你是单独锻炼，又想控制动作幅度，并想让身体与地面保持正确距离，可以在胸部正下方放一个棒球或网球（图10）。</p>
<p>你在做动作的过程中，待胸部碰到球后暂停一下，然后回到起始姿势。 </p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsfwc1-9.png" style="zoom:50%;" />

<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsfwc1-10.png" style="zoom:50%;" />

<ul>
<li>初级标准：1 组， 5次</li>
<li>中级标准：2 组， 各10次</li>
<li>高级标准：2 组，各20次</li>
</ul>
<h2 id="深蹲"><a href="#深蹲" class="headerlink" title="深蹲"></a>深蹲</h2><h3 id="第一式-肩倒立深蹲"><a href="#第一式-肩倒立深蹲" class="headerlink" title="第一式 肩倒立深蹲"></a>第一式 肩倒立深蹲</h3><p>平躺，双膝弯曲，双手下压。双脚蹬离地面，直到举到空中。</p>
<p>在将双腿举起的过程中，顺 势把双手撑在下背部，注意上臂要紧贴地面。</p>
<p>你 现在摆出的姿势是肩倒立—靠双肩、上背部以及 上臂支撑身体。</p>
<p>要记住，始终用这几个部位支撑 身体，不要让颈部受到压力。身体要锁定伸直， 髋部不要弯曲。</p>
<p>这是该动作的起始姿势（图 21）。</p>
<p>上半身要尽可能伸直，弯曲髋部与膝关 节，直到膝盖轻触前额，这是该动作的结束姿势 （图 22）。</p>
<p>然后伸直双腿，直到身体回到起始 姿势，如此重复。</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjssd1-1.png" style="zoom:50%;" />

<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjssd1-2.png" style="zoom:50%;" />

<ul>
<li>初级标准：1 组， 10次</li>
<li>中级标准：2 组， 各25次</li>
<li>高级标准：3组，各50次</li>
</ul>
<h3 id="第二式-折刀深蹲"><a href="#第二式-折刀深蹲" class="headerlink" title="第二式 折刀深蹲"></a>第二式 折刀深蹲</h3><p>站在一个稳固的物体前，此物体的高度大约 与你的膝盖等高，至少也要达到胫骨上部，小咖啡桌、椅子、床铺都是不错的选择。</p>
<p>双腿分开， 与肩同宽或略宽。双腿伸直，弯腰俯身，直到双手与面前的物体接触。</p>
<p>身体前倾，使一部分体重 落在双手上。这是该动作的起始姿势 （图 23）。</p>
<p>上半身尽量与地面平行，弯曲 膝关节和髋部，直到大腿后侧紧贴小腿，无法蹲得更低为止。这是该动作的最低点（图 24）。</p>
<p>下蹲过程中你还需要弯曲双臂，在下降到最低点后腿部与手臂要同时发力，将身体推回到起始姿势。在整个动作过程中，脚跟始终不能抬离地面。 </p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjssd1-3.png" style="zoom:50%;" />

<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjssd1-4.png" style="zoom:50%;" />

<ul>
<li>初级标准：1 组， 10次</li>
<li>中级标准：2 组， 各20次</li>
<li>高级标准：3组，各40次</li>
</ul>
<h3 id="第三式-支撑深蹲"><a href="#第三式-支撑深蹲" class="headerlink" title="第三式 支撑深蹲"></a>第三式 支撑深蹲</h3><p>直立，双脚分开，与肩同宽或略宽。</p>
<p>手臂向斜下方伸出，双手放在比自己的大腿略高的稳固物体上，书桌、高脚凳或椅背都可以。这是该动作的起始姿势（图 25）。</p>
<p>弯曲髋部与膝关节，身体慢慢下降，背部尽可能保持挺直，直到大腿后侧紧贴小腿，无法蹲得更低为止，这是该动作的最低点（图 26）。</p>
<p>暂停一会，然后主要靠腿部发力站起来。为了分担双腿的一部分压力，尤其是在最低点时，你要通过向下按压面前的物体，来借用手臂的一部分力量。</p>
<p>手臂要尽量伸直，在整个动作过程中都不要让脚跟抬离地面。 </p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjssd1-5.png" style="zoom:50%;" />

<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjssd1-6.png" style="zoom:50%;" />

<ul>
<li>初级标准：1 组， 10次</li>
<li>中级标准：2 组， 各15次</li>
<li>高级标准：3组，各30次</li>
</ul>
<h3 id="第四式-半深蹲"><a href="#第四式-半深蹲" class="headerlink" title="第四式 半深蹲"></a>第四式 半深蹲</h3><p>站立，双脚分开，与肩同宽或略宽。脚尖不要指向正前方。</p>
<p>双手放在髋部、胸部、肩部都可以——以舒适为前提。这是该动作的起始姿势（图27）。</p>
<p>弯曲髋部和膝 盖，直到膝关节弯曲成 90°—换句话说就是大腿与地面平行。这是该动作的最低点（图28）。</p>
<p>在最低点（半空中）坚持 1秒钟，然后再回到起始姿势。在整个动作过程中，背部始终要挺直，双脚脚跟始终不能抬离地面。</p>
<p>膝盖与脚尖应该始终朝向同一方向，深蹲时膝盖绝不要向内转，脚尖指向外有助于你做到这一点。</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjssd1-7.png" style="zoom:50%;" />

<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjssd1-8.png" style="zoom:50%;" />

<ul>
<li>初级标准：1 组， 8次</li>
<li>中级标准：2 组， 各35次</li>
<li>高级标准：2组，各50次</li>
</ul>
<h3 id="第五式-标准深蹲"><a href="#第五式-标准深蹲" class="headerlink" title="第五式 标准深蹲"></a>第五式 标准深蹲</h3><p>直立，双脚分开，与肩同宽或略宽（取决于个人偏好）。</p>
<p>双脚略微向外转，双臂随意摆放，只要舒服即可。这是该动作的起始姿势（图29）。髋部与膝关节弯曲，背部始终挺直。</p>
<p>当大腿达到几乎与地面平行时，把你的身体重心向后转移，就像要坐下一样。有控制地继续放低身体，直到大腿后侧紧贴小腿。这是该动作的最低点（图 30）。</p>
<p>暂停一会，然后仅靠腿部发力将自己推回到起始姿势。起身过程和下蹲过程应该是完全相反的。脚跟始终不要抬离地面，膝盖也不能向内转。</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjssd1-9.png" style="zoom:50%;" />

<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjssd1-10.png" style="zoom:50%;" />

<ul>
<li>初级标准：1 组， 5次</li>
<li>中级标准：2 组， 各10次</li>
<li>高级标准：2组，各30次</li>
</ul>
<h3 id="第六式-窄距深蹲"><a href="#第六式-窄距深蹲" class="headerlink" title="第六式 窄距深蹲"></a>第六式 窄距深蹲</h3><p>直立，双脚脚跟相碰，脚尖微微向外，双臂前伸。这是该动作的起始姿势（图 31）。</p>
<p>弯曲膝盖和舰部，直到大腿后侧紧贴小腿，无法蹲得更低为止。此时，你的胸部应该紧贴大腿（图32）。</p>
<p>注意，脚跟始终不要抬离地面。为避免后倾，你得收缩胫骨肌肉使身体微微前倾。 </p>
<p>保持这一姿势，然后仅靠腿部发力将自己推回到起始姿势。</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjssd1-11.png" style="zoom:50%;" />

<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjssd1-12.png" style="zoom:50%;" />

<ul>
<li>初级标准：1 组， 5次</li>
<li>中级标准：2 组， 各10次</li>
<li>高级标准：2组，各20次</li>
</ul>
<h2 id="引体向上"><a href="#引体向上" class="headerlink" title="引体向上"></a>引体向上</h2><h3 id="第一式-垂直引体"><a href="#第一式-垂直引体" class="headerlink" title="第一式 垂直引体"></a>第一式 垂直引体</h3><p>找一个可抓握且很稳固的竖直物体，门框和高一点的栏杆都是上好之选。 </p>
<p>靠近物体站立，脚尖与之保持约 8 一15厘米的距离。</p>
<p>以舒服的姿势抓住该物体，理想情况是双手与肩同宽，但不必要——只要双手对称即可。这是该动作的起始姿势（图 41）。</p>
<p>由于你距离物体很近，所以手臂会弯曲。身体慢慢向后倾，在此过程中伸展手臂，直到手臂几乎伸直、身体后倾与地面成一定角度为止。这是该动作的结束姿（图 42）。</p>
<p>此时，你的上背部应该有拉伸感，手臂可能也会有同感。</p>
<p>暂停一会，再并拢肩脚骨并弯曲手臂，把身体拉回到起始姿势。</p>
<p>暂停，然后再重复该动 作。 </p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsytxs1-1.png" style="zoom:50%;" />

<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsytxs1-2.png" style="zoom:50%;" />

<ul>
<li>初级标准：1 组， 10次</li>
<li>中级标准：2 组， 各20次</li>
<li>高级标准：3组，各40次</li>
</ul>
<h3 id="第二式-水平引体向上"><a href="#第二式-水平引体向上" class="headerlink" title="第二式 水平引体向上"></a>第二式 水平引体向上</h3><p>找一个至少与你的髋部等高、稳固且双手可抓握的水平物体。</p>
<p>该物体要能安全地承载你的体重，又大又结实的桌子（如餐桌和书桌）通常是最佳之选。</p>
<p>钻到桌子下面——胸部与下肢都位于桌子下面，抬手抓住桌子边缘（使用正握姿势）。</p>
<p>理想情况是，双手与肩同宽，但这要取决于你用的是什么样的桌子。然后拉起身体，使背部离地，只有脚跟与地面接触。</p>
<p>有时你的手臂可能需要适当弯曲才能使背部离地——这取决于桌子的高度。</p>
<p>身体绷紧，让双手和双脚脚跟承担身体的重量。这是该动作的起始姿势（图 43）。</p>
<p>然后平缓地拉起身体，在此过程中整个身体（尤其是膝盖）要成一条直线，直到胸部触到桌子边缘。这是该动作的结束姿势（图 44）。</p>
<p>暂停一下，然后降低身体，回到起始姿势，如此重复。</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsytxs1-3.png" style="zoom:50%;" />

<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsytxs1-4.png" style="zoom:50%;" />

<ul>
<li>初级标准：1 组， 10次</li>
<li>中级标准：2 组， 各20次</li>
<li>高级标准：3组，各30次</li>
</ul>
<h2 id="举腿"><a href="#举腿" class="headerlink" title="举腿"></a>举腿</h2><h3 id="第一式-坐姿屈膝"><a href="#第一式-坐姿屈膝" class="headerlink" title="第一式 坐姿屈膝"></a>第一式 坐姿屈膝</h3><p>坐在椅子或床的边缘，身体略微向后倾斜，双手抓住边沿，两腿伸直，双脚并拢，脚跟距离地面几厘米。。这是该动作的起始姿势（图 61）。</p>
<p>平缓地抬起膝盖，直到膝盖距胸部约 15 一 25 厘米。在此过程中呼气，动作完成时呼气结束，腹肌保持收缩状态。这是该动作的结束姿势（图 62）。</p>
<p>暂停 1 秒钟，进行反向运动并回 到起始姿势。</p>
<p>伸展膝盖的同时吸气。双脚应该始 终沿着一条直线移动，而且始终保持悬空，直到 一组动作完成方可接触地面。</p>
<p>腹部要始终收缩，动作要慢，要抵制快速完成动作的冲动。如果需要，可以在两次动作之间喘几口气（所有中段练习都一样）</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsjt1-1.png" style="zoom:50%;" />

<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsjt1-2.png" style="zoom:50%;" />

<ul>
<li>初级标准：1 组， 10次</li>
<li>中级标准：2 组， 各25次</li>
<li>高级标准：3组，各40次</li>
</ul>
<h3 id="第二式-平卧抬膝"><a href="#第二式-平卧抬膝" class="headerlink" title="第二式 平卧抬膝"></a>第二式 平卧抬膝</h3><p>平躺在地上，双腿并拢，双手置于身体两侧的地板上。</p>
<p>膝盖弯曲近 90°双脚距离地面约 2 一 5 厘米。</p>
<p>双手用力向下按压地板，这样有助于保持身体稳定。这是该动作的起始姿势（图63）。</p>
<p>然后平缓地抬起膝盖，越过髋部，直到大腿与地面垂直、小腿与地面平行，整个过程中膝盖始终接近 90°。</p>
<p>在此过程中呼气，腹部肌肉保持收紧。这是该动作的结束姿势（图 64）。</p>
<p>暂停 1 秒钟，进行反向动作。降低双脚，回到起始姿势，并在此过程中吸气。</p>
<p>在整组练习中双脚都不能接触地面。 </p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsjt1-3.png" style="zoom:50%;" />

<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsjt1-4.png" style="zoom:50%;" />

<ul>
<li>初级标准：1 组， 10次</li>
<li>中级标准：2 组， 各20次</li>
<li>高级标准：3组，各35次</li>
</ul>
<h3 id="第三式-平卧屈举腿"><a href="#第三式-平卧屈举腿" class="headerlink" title="第三式 平卧屈举腿"></a>第三式 平卧屈举腿</h3><p>平躺在地上，双腿并拢伸展，双手置于身体两侧的地面上。</p>
<p>双腿抬起，膝盖弯曲，使大腿与小腿的夹角大约成 135°双脚距离地面约 2 一5 厘米。这是该动作的起始姿势（图 65）。 </p>
<p>该练习前半部分的动作包括平缓地抬起双腿和双脚，持续大约 2 秒钟，直到双脚位于骨盆正上方（图 66）。</p>
<p>在整个动作过程中，膝盖弯曲的角度应该保持不变——始终“锁定”。双手向下按压地板，这样有助于保持身体稳定。</p>
<p>两脚位于骨盆正上方时，略作停顿，然后进行反向动作。</p>
<p>在回复到起始姿势时也略作停顿，然后重复以上过程。</p>
<p>双脚向上运动时呼气，向下运动时吸气。</p>
<p>在整组练习中，腹部始终都要收紧，双脚始终不能接触地面。 </p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsjt1-5.png" style="zoom:50%;" />

<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsjt1-6.png" style="zoom:50%;" />

<ul>
<li>初级标准：1 组， 10次</li>
<li>中级标准：2 组， 各15次</li>
<li>高级标准：3组，各30次</li>
</ul>
<h3 id="第四式-平卧蛙举腿"><a href="#第四式-平卧蛙举腿" class="headerlink" title="第四式 平卧蛙举腿"></a>第四式 平卧蛙举腿</h3><p>先做第三式前半部分的屈举腿动作，但在最高点的时候（图 66）不要停顿，而是要完全伸直双腿，使其与地面垂直，并与上半身的夹角成90°这是该动作的结束姿势（图 67）。 </p>
<p>应该在这个两部分的动作过程中呼气。</p>
<p>大多数中段练习此时都要反向重复前半部分的动作，但这个练习有所不同。</p>
<p>在有阻力（重力）的情况下降低双腿比抬起双腿要容易，蛙举腿正利用了这一点。</p>
<p>降低双腿并保持完全伸展（图 68），直到双腿距离地面约 2-5 厘米（图 69）。 </p>
<p>大多数练习动作中上与下的过程都要经过 2秒钟，但该练习的下落过程要经过 4 秒钟，以便身体在有利的姿势中获得更多的锻炼。</p>
<p>双腿慢慢下降时吸气，然后重复以上动作。 </p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsjt1-7.png" style="zoom:50%;" />

<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsjt1-8.png" style="zoom:50%;" />

<ul>
<li>初级标准：1 组， 8次</li>
<li>中级标准：2 组， 各15次</li>
<li>高级标准：3组，各 25次</li>
</ul>
<h3 id="第五式-平卧直举腿"><a href="#第五式-平卧直举腿" class="headerlink" title="第五式 平卧直举腿"></a>第五式 平卧直举腿</h3><p>平躺在地上，面部朝上。双脚并拢，双腿伸直，双手置于身体两侧。抬起双脚，使其距离地面约 2-5 厘米。</p>
<p>双手向下按压地板，以保持身体稳定。这是该动作的起始姿势（图 70）。 </p>
<p>双腿锁定，抬起双脚直到它们到达骨盆正上方，即双腿与上半身的夹角成 90°这是该动作的结束姿势（图 71）。</p>
<p>抬脚的过程中呼气，腹部保持收紧。至少要用 2 秒钟平缓地完成该动作，不要用猛劲。</p>
<p>停顿片刻，然后反向动作，降低双腿的过程中吸气。到达起始姿势后略作停顿，再重复。</p>
<p>在整个动作过程中，膝盖始终要锁定，双脚不能接触地面，直到一组完成之后方可。</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsjt1-9.png" style="zoom:50%;" />

<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsjt1-10.png" style="zoom:50%;" />

<ul>
<li>初级标准：1 组， 5次</li>
<li>中级标准：2 组， 各10次</li>
<li>高级标准：2 组，各20次</li>
</ul>
<h2 id="桥"><a href="#桥" class="headerlink" title="桥"></a>桥</h2><h3 id="第一式-短桥"><a href="#第一式-短桥" class="headerlink" title="第一式 短桥"></a>第一式 短桥</h3><p>躺在地上，双手叠放在腹部。</p>
<p>膝盖弯曲，将双脚拉向臀部，直到胫骨与地面接近垂直，此时脚跟距离臀部约 15~20 厘米，脚掌平放在地上。 </p>
<p>双脚与肩同宽或略窄，依个人舒适度而定。这是起始姿势（图 83）。然</p>
<p>然后双脚用力下压，身体向上拱起，使髋部和背部离开地面，直到仅以双肩和双脚支撑整个身体。此时，大腿和躯干应成一条直线，髋部不要下沉。这是结束姿势（图 84）。</p>
<p>暂停一会，然后做反向动作，缓缓地放低身体，直到回到起始姿势，如此重复。身体撑起时呼气身体放低时吸气。</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsq1-1.png" style="zoom:50%;" />

<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsq1-2.png" style="zoom:50%;" />

<ul>
<li>初级标准：1 组， 10次</li>
<li>中级标准：2 组， 各25次</li>
<li>高级标准：3组，各50次</li>
</ul>
<h3 id="第二式-直桥"><a href="#第二式-直桥" class="headerlink" title="第二式 直桥"></a>第二式 直桥</h3><p>坐在地上，双腿伸直，双脚与肩同宽。</p>
<p>手掌平放在髋部两侧的地上，手指朝前。坐直，此时腿和上半身之间的夹角成 90°这是该动作的起始姿势（图 85）。</p>
<p>双手用力下压，双臂绷紧，同时将髋部向上推起，直到双腿与躯干成一条直线。</p>
<p>下巴向上抬起，看向天花板，此时只用手掌和脚跟支撑身体。这是结束姿势（图 86）。</p>
<p>暂停一会，然后反向运动。身体撑起时呼气，身体放低时吸气。 </p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsq1-3.png" style="zoom:50%;" />

<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsq1-4.png" style="zoom:50%;" />

<ul>
<li>初级标准：1 组， 10次</li>
<li>中级标准：2 组， 各20次</li>
<li>高级标准：3组，各40次</li>
</ul>
<h2 id="倒立撑"><a href="#倒立撑" class="headerlink" title="倒立撑"></a>倒立撑</h2><h3 id="第一式-靠墙顶立"><a href="#第一式-靠墙顶立" class="headerlink" title="第一式 靠墙顶立"></a>第一式 靠墙顶立</h3><p>找一堵墙，在墙根处放置一个枕头（坐垫或叠好的毛巾也可）。</p>
<p>双手和双膝着地，将头顶在枕头上，头部距离墙壁约 15 一 25 厘米。</p>
<p>双手稳稳地放在头部两侧，大约与肩同宽。</p>
<p>抬起一条腿的膝盖，让其靠近同侧的肘部，同时伸直另一条腿，使膝盖离地（图 107）。</p>
<p>然后，让靠近肘 部的腿使劲蹬地，同时将另一条腿向上踢，从而让两条腿同时靠向墙壁。</p>
<p>一旦双脚靠在墙壁上，就慢慢伸直双腿，把身体摆正（图 108）。</p>
<p>嘴巴保持闭合，用鼻子平缓呼吸。 </p>
<p>坚持所需时间后，弯曲双腿，并有控制地放下它们。</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsdlc1-1.png" style="zoom:50%;" />

<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsdlc1-2.png" style="zoom:50%;" />

<ul>
<li>初级标准：30秒</li>
<li>中级标准：1分钟</li>
<li>高级标准：2分钟</li>
</ul>
<h3 id="第二式-乌鸦式"><a href="#第二式-乌鸦式" class="headerlink" title="第二式 乌鸦式"></a>第二式 乌鸦式</h3><p>双膝分开，呈蹲坐姿势。</p>
<p>双手手掌放在身体 前面的地板上，与肩同宽。双臂略微弯曲，身体 向前倾斜，然后让双膝稳稳地夹在两肘外侧（图 109）。</p>
<p>身体继续前倾，一点一点把体重转移到 手掌上，双脚的负重则越来越少。</p>
<p>最终重心前 移，双脚离地。双脚用力提起，保持平衡，平缓 呼吸，坚持一定的时间（图 110）。</p>
<p>然后反向运 动，身体重心慢慢后倾，直到脚尖再次接触地面。</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsdlc1-3.png" style="zoom:50%;" />

<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsdlc1-4.png" style="zoom:50%;" />

<ul>
<li>初级标准：10秒</li>
<li>中级标准：30秒</li>
<li>高级标准：1分钟</li>
</ul>
<h3 id="第三式-靠墙倒立"><a href="#第三式-靠墙倒立" class="headerlink" title="第三式 靠墙倒立"></a>第三式 靠墙倒立</h3><p>找一面墙，双手手掌平放在距离墙根约 15- 25 厘米的地面上，双手与肩同宽。</p>
<p>手臂伸直或近乎伸直，膝盖弯曲，撑起身体。</p>
<p>提起一条腿的膝盖，让其靠近同侧的肘部（图 111），然后使劲向下蹬地，同时让另一条腿向后上方摆。</p>
<p>与此同时，让蹬地的腿也离地，紧随另一条腿向墙壁靠近，手臂保持伸展，双脚脚跟应同时接触墙壁。</p>
<p>刚开始练习时，上踢的力量如果过大，你的后背和屁股会猛地撞到墙上，但久而久之你就会掌握完美的上墙技艺。</p>
<p>最后，你的手臂应该是直的，身体摆正，背部略向内弓。这就是标准的靠墙倒立姿势（图 112）。 </p>
<p>保持这一姿势一段时间，整个过程中保持正常呼吸。 </p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsdlc1-5.png" style="zoom:50%;" />

<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/qtjsdlc1-6.png" style="zoom:50%;" />

<ul>
<li>初级标准：30秒</li>
<li>中级标准：1分钟</li>
<li>高级标准：2分钟</li>
</ul>
<p>未完待续~</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>健身</tag>
      </tags>
  </entry>
  <entry>
    <title>博客迁移到私有服务器上</title>
    <url>/2021/08/29/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0%E7%A7%81%E6%9C%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/</url>
    <content><![CDATA[<p>今天把博客，从码云的 gitpages 服务，迁移到了自己的服务器上，记录分享一下。</p>
<h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p>至于为什么不用 github 的 gitpages，主要是打开太慢了。。</p>
<ol>
<li><p>码云的 gitpages  部署之后，需要手动去更新一下才能生效。</p>
</li>
<li><p>码云的 gitpages 有时会抽风，遇到过两次一直在部署中，无法操作的情况。</p>
</li>
<li><p>原来用第三方的原因是，自己的服务器搭梯子经常被封，中间有段时间没买服务器；但是呢，七牛云的免费额度只有 http 请求，所以前端时候在服务器搞了个反向代理。就是 https 站点 -&gt; https图片资源 -&gt; http图片资源 这么一个过程。。所以服务器就不能停了，不然博客的图片就全部要挂了。</p>
</li>
</ol>
<span id="more"></span>

<h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h5><ol>
<li>一台服务器</li>
<li>安装 nginx，go，docker。<a href="http://www.ruanyifeng.com/blog/2018/02/nginx-docker.html">容器化部署nginx教程</a></li>
<li>代码仓库设置一个 webhook</li>
</ol>
<h5 id="自动部署"><a href="#自动部署" class="headerlink" title="自动部署"></a>自动部署</h5><p>自动部署大概流程是这样</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.png" style="zoom:80%;" />

<p>自动部署脚本大概长这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /root/codespace/blog &amp;&amp;</span><br><span class="line">	git checkout hexo &amp;&amp;</span><br><span class="line">	git pull &amp;&amp;</span><br><span class="line">	rm -rf .deploy_git &amp;&amp;</span><br><span class="line">	hexo clean &amp;&amp;</span><br><span class="line">	hexo g &amp;&amp;</span><br><span class="line">	hexo d &amp;&amp;</span><br><span class="line">	git add . &amp;&amp;</span><br><span class="line">	git commit -m &#x27;自动部署博客&#x27; &amp;&amp;</span><br><span class="line">	git push &amp;&amp;</span><br><span class="line">	rm -rf /root/nginx-docker/html/blog/ &amp;&amp;</span><br><span class="line">	cp -r public/ /root/nginx-docker/html/blog &amp;&amp;</span><br><span class="line">	docker restart mynginx</span><br></pre></td></tr></table></figure>

<p>监听 webhook，调用自动部署的服务长这样：</p>
<p><a href="https://github.com/ruomuc/test_demos/tree/master/simple-blog-deploy-server">代码地址</a>，直接编译成二进制文件拖到一个目录下就行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;os/exec&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lastDeployTime time.Time</span><br><span class="line"><span class="keyword">var</span> password *<span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> shellPath *<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	password = flag.String(<span class="string">&quot;p&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;webhook password&quot;</span>)</span><br><span class="line">	shellPath = flag.String(<span class="string">&quot;s&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;shell path&quot;</span>)</span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="comment">// 启动http服务器，等待webhook调用</span></span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/gitee/blog/deploy&quot;</span>, doDeploy)</span><br><span class="line">	err := http.ListenAndServe(fmt.Sprintf(<span class="string">&quot;:%d&quot;</span>, <span class="number">8088</span>), <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;http ListenAndServe fail:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是只是简单地调用一个shell脚本</span></span><br><span class="line"><span class="comment">// 部署功能步骤都在shell脚本里</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doDeploy</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> body <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">	decoder := json.NewDecoder(r.Body)</span><br><span class="line">	decoder.Decode(&amp;body)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> body[<span class="string">&quot;password&quot;</span>] != *password &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s: 密码错误: %s \n&quot;</span>, time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>), body[<span class="string">&quot;password&quot;</span>])</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> time.Now().Sub(lastDeployTime) &lt; <span class="number">120</span>*time.Second &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s: 部署操作冷却中...最后部署时间: %v \n&quot;</span>, time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>), lastDeployTime)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	lastDeployTime = time.Now()</span><br><span class="line"></span><br><span class="line">	cmd := exec.Command(<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, *shellPath)</span><br><span class="line">	output, err := cmd.Output()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Execute shell failed: %+v, commands: %s&quot;</span>, err, <span class="type">string</span>(output))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中，加了一个冷却时间是因为，部署完成之后需要把新的代码提交上去，这时候又会触发 webhook，没有冷却时间会死循环。。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>过程一波三折，遇到的问题基本都能 google 解决掉</p>
<p>最终效果是，写完博客，只需要提交代码，稍等片刻刷新博客就可以看到新的提交内容了</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>初识redo log和binlog</title>
    <url>/2021/08/13/redo-log%E5%92%8Cbinlog/</url>
    <content><![CDATA[<p>整理下 mysql 的 redo log 和 binlog 相关知识。</p>
<p>这个是照着画的一个 mysql 逻辑架构图，方便后面对照着理解。</p>
<span id="more"></span>

<p><strong>需要注意的是：mysql8.0 干掉了查询缓存这个模块。</strong>（因为查询缓存失效的很频繁，本来就很鸡肋，默认都是关闭的）</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/mysql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" style="zoom: 50%;" />

<h5 id="什么是物理日志-和-逻辑日志？"><a href="#什么是物理日志-和-逻辑日志？" class="headerlink" title="什么是物理日志 和 逻辑日志？"></a>什么是物理日志 和 逻辑日志？</h5><p>我的理解是这样的，<strong>物理日志记录的是值得变更结果，逻辑日志记录的是值得变更过程。</strong></p>
<p>比如把 a 值初始为1，我们给 a 加二再减一</p>
<ul>
<li>物理日志为：<code>a:1-&gt;a:3</code> 和 <code>a:3-&gt;a:2</code></li>
<li>逻辑日志为:  <code>a=a+2 </code>和 <code>a=a-1</code>。ps: 在mysql中可以理解为一条条sql语句</li>
</ul>
<h5 id="什么是-redo-log？"><a href="#什么是-redo-log？" class="headerlink" title="什么是 redo log？"></a>什么是 redo log？</h5><p>redo log 是<strong>物理日志</strong>，并且是 <strong>InnoDB 特有的</strong>。</p>
<p> mysql 的 WAL （Write-Ahead Logging）技术就是通过它实现的，WAL 的意思就是先写日志，再写磁盘。</p>
<ul>
<li>这里需要注意一下，所谓的 “先写日志”，其实也是写磁盘，只不过是顺序写，非常快。</li>
<li>”再写磁盘“ 的意思是，向 mysql 真正存储业务数据的地方写数据（也在磁盘上，但是在写之前还要查找、索引B+树节点变动等），很慢。</li>
</ul>
<blockquote>
<p>举个例子，做生意的小商家记账的时候，不可能每一笔账的马上记到总账本里面，因为总账本很厚，找到对应的地方并记录一笔账目是很费时间的，一般都会在一张纸上或者小黑板上先记着，然后等人少的时候，或者晚上关门的时候，再计入总账本；我们的 redo log 就对应这个例子里的小黑板。</p>
</blockquote>
<p>redo log 保证了数据库即使发生异常重启（这种能力称为 crash-safe），之前的记录都不会丢失。</p>
<blockquote>
<p>还是用上面那个小商家举例，假如商家突然有事关门了，重新营业的时候，只需要根据总账本和小黑板的账目，恢复到之前的状态，不会丢失任何一笔账。</p>
</blockquote>
<h5 id="redo-log的记录模式"><a href="#redo-log的记录模式" class="headerlink" title="redo log的记录模式"></a>redo log的记录模式</h5><p>InnoDB 的 redo log 大小是固定的，我们可以使用： <code>show variables like &#39;%innodb_log_file%&#39;;</code>  命令查看。</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/redolog%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE.PNG" style="zoom:150%;" />

<p>默认是两个文件，一个文件 48 M。</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/redolog%E8%AF%BB%E5%86%99%E6%96%B9%E5%BC%8F.jpg" style="zoom: 80%;" />

<ul>
<li>write pos 是当前记录的位置，一边写一边后移。</li>
<li>checkpoint 是当前要擦除的位置，也是往后推移并且循环的。</li>
<li>中间绿色的就是空白位置。</li>
</ul>
<h5 id="如何设置redo-log的大小？"><a href="#如何设置redo-log的大小？" class="headerlink" title="如何设置redo log的大小？"></a>如何设置redo log的大小？</h5><p>当一个日志文件写满后，innodb会自动切换到另一个日志文件，而且会触发数据库的checkpoint，这回导致 innodb 缓存脏页的小批量刷新，会明显降低innodb的性能。</p>
<ul>
<li>如果innodb_log_file_size过小，会导致innodb频繁地checkpoint</li>
<li>如果innodb_log_file_size过大，会导致在崩溃恢复InnoDB时，会导致恢复时间变长。 ps: 其实我倒觉得这不是什么大问题</li>
</ul>
<p>所以说，要根据自己的业务量设置合适的 innodb_log_file_size。网上有很多设置方法，这里就不展开了。</p>
<h5 id="什么是-binlog"><a href="#什么是-binlog" class="headerlink" title="什么是 binlog?"></a>什么是 binlog?</h5><p>前面说了，redo log 是InnoDB 特有的，所以是引擎层的日志模块，而 binglog 是 Server 层的。</p>
<p>binlog 是一个逻辑日志。</p>
<p>为什么会有两份日志呢？</p>
<ul>
<li><p>最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM</p>
</li>
<li><p>MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档</p>
</li>
</ul>
<h5 id="binlog-和-redo-log-的不同点"><a href="#binlog-和-redo-log-的不同点" class="headerlink" title="binlog 和 redo log 的不同点"></a>binlog 和 redo log 的不同点</h5><ul>
<li><p>redo log 是 InnoDB 引擎特有的，binlog 是 mysql 的 Server 层实现的</p>
</li>
<li><p>redo log 是物理日志，binlog 是逻辑日志</p>
</li>
<li><p>redo log 是循环写，binlog 是追加写</p>
</li>
</ul>
<h5 id="执行流程和两阶段提交"><a href="#执行流程和两阶段提交" class="headerlink" title="执行流程和两阶段提交"></a>执行流程和两阶段提交</h5><p>假设有表 tableA，有一条记录 id =2 ，c = 1，我们执行下面这条语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> tableA <span class="keyword">set</span> c <span class="operator">=</span> c<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.png" style="zoom:80%;" />



<p>我们将 redo log 的写入拆成了两个步骤：</p>
<ul>
<li>第一步写 redo log 并且是 prepare 状态</li>
<li>写完 binlog 后，将redo log 由 prepare 变为 commit 状态</li>
</ul>
<p>这样做的目的是为了保持数据一致性，使 redo log 和 binlog 的数据一致。</p>
<p>如果是一段提交，我们分析一下两种场景：</p>
<ol>
<li>先写 redo log，再写 binlog，并且写完redo log 后数据库 crash 了。我们恢复数据时：<ul>
<li>redo log 中 c 的值是 2</li>
<li>binlog 没有日志</li>
<li>虽然我们可以通过 redo log 恢复为 c = 2这一正确数据，但是 binlog 中没有这条记录，使用binlog 恢复数据就和 crash 前不一致。</li>
</ul>
</li>
<li>先写 binlog，再写 redo log，并且写完 binlog 后数据库 crash：<ul>
<li>redo log 没有日志</li>
<li>binlog 日志 “将 c 由 1 改为 2”</li>
<li>binlog 中存在记录“ 把 c 由 1 改为 2”，但是 redo log 中 c 的值仍然是 1</li>
</ul>
</li>
</ol>
<p>两阶段提交如何恢复呢？</p>
<ol>
<li>写redo log，处于 prepare 阶段，还没写 binlog，数据库 crash：<ul>
<li>redo log 中 c =2，但状态是 prepare，并未提交</li>
<li>binlog 没有日志</li>
<li>数据库恢复时，使用 binlog 恢复 c 值为 1，使用 redo log 会忽略掉未提交的日志，c 值也是 1</li>
</ul>
</li>
<li>写 redo log，处于 prepare 阶段，写binlog，还没来得及提交 redo log，数据库 crash：<ul>
<li>redo log 中 c=2, 但状态是 prepare，并未提交</li>
<li>binlog 日志 “将 c 由 1 改为 2”</li>
<li>数据库恢复时，使用 binlog 恢复 c 值 为2，使用redo log，虽然状态为 prepare，但 prepare和binlog日志都是完整的，会自动commit，满足数据一致性。</li>
</ul>
</li>
</ol>
<p>ps: 这里其实每个细节展开都有好多知识，这里只是先有个概念。</p>
<p>参考链接：</p>
<ul>
<li>《MySQL实战45讲》</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>go错误处理最佳实践</title>
    <url>/2021/07/24/go%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>用 go 写过业务代码之后，就会发现，go的错误处理很让人头痛。。（事实上被吐槽的确实很多~）</p>
<p>然后刚好在极客时间薅了一节体验课。整理一下。以供参考。</p>
<p>注：对于初学者而言，最起码你要自己写一个curd的demo，不然看完之后不会有什么感觉。</p>
<span id="more"></span>

<h2 id="Sentinel-Error"><a href="#Sentinel-Error" class="headerlink" title="Sentinel Error"></a>Sentinel Error</h2><p>预定义的特定错误，我们叫为 sentinel error。</p>
<p>这个名字来源于计算机编程中使用一个特定值来表示不可能进行进一步处理的做法。所以对于 Go，我们使用特定的值来表示错误。</p>
<p>常用的比如 io 标准库的 EOF 错误表示读文件读到了结尾，但是它并不属于错误，</p>
<p>所以我们可能会这么写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dosomething</span></span><br></pre></td></tr></table></figure>

<p>包括在使用 gorm 的时候：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != gorm.ErrRecordNotFound &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dosomething</span></span><br></pre></td></tr></table></figure>

<p>这种写法有什么缺点呢：</p>
<ul>
<li>无法携带上下文，携带信息少</li>
<li>Sentinel Error 成为了你的 API 的公共部分，必须暴露给外部。</li>
<li>Sentinel Error 在调用者和被调用者之间创建了依赖关系（强耦合），如果需要改动，必须要兼容。</li>
</ul>
<p><strong>所以尽可能的避免使用 Sentinel Error，尽管标准库中有使用它们。</strong></p>
<br>

<h2 id="Error-types"><a href="#Error-types" class="headerlink" title="Error types"></a>Error types</h2><p>Error types 可以携带更多的上下文</p>
<p>自定义一个 Error类型，然后实现 Error ()方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">	Msg  <span class="type">string</span></span><br><span class="line">	File <span class="type">string</span></span><br><span class="line">	Line <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(me *MyError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s:%d: %s&quot;</span>, me.File, me.Line, me.Msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;MyError&#123;<span class="string">&quot;Something Wrong&quot;</span>, <span class="string">&quot;server.go&quot;</span>, <span class="number">32</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := test()</span><br><span class="line">	<span class="keyword">switch</span> err := err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">	<span class="comment">// doSomething</span></span><br><span class="line">	<span class="keyword">case</span> *MyError:</span><br><span class="line">		fmt.Println(<span class="string">&quot;error occurred on line:&quot;</span>, err.Line)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// doSomething</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: </span></span><br><span class="line"><span class="type">error</span> occurred on line: <span class="number">32</span></span><br></pre></td></tr></table></figure>

<p>os 标准库中的实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Op   <span class="type">string</span></span><br><span class="line">    Path <span class="type">string</span></span><br><span class="line">    Err  <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PathError)</span></span> Error() <span class="type">string</span></span><br></pre></td></tr></table></figure>

<br>

<p>缺点：</p>
<ul>
<li>Error types 需要把自定义Error类型（MyError）暴露出去，比Sentinel Error更加脆弱。</li>
</ul>
<p><strong>虽然 Error types 携带了更多的附加信息，但是并没有解决根本问题。不推荐使用。。</strong></p>
<br>

<h2 id="Opaque-errors"><a href="#Opaque-errors" class="headerlink" title="Opaque errors"></a>Opaque errors</h2><p>我们将这种风格称为不透明错误处理。</p>
<p>不再依赖类型，而依赖方法。</p>
<p>net 标准库中的实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Error <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">error</span></span><br><span class="line">    Timeout() <span class="type">bool</span>   <span class="comment">// Is the error a timeout?</span></span><br><span class="line">    Temporary() <span class="type">bool</span> <span class="comment">// Is the error temporary?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> InvalidAddrError <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e InvalidAddrError)</span></span> Error() <span class="type">string</span>   &#123; <span class="keyword">return</span> <span class="type">string</span>(e) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e InvalidAddrError)</span></span> Timeout() <span class="type">bool</span>   &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e InvalidAddrError)</span></span> Temporary() <span class="type">bool</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br></pre></td></tr></table></figure>

<p>可以这样判断错误类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> e, ok := err.(net.InvalidAddrError); ok &#123;</span><br><span class="line">    <span class="keyword">return</span> e.Temporary()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论内部的错误类型如何改变，只要 Temporary 方法还在，就是兼容的。</p>
<p><strong>推荐使用这种方式</strong></p>
<br>

<h2 id="Wrap-errors"><a href="#Wrap-errors" class="headerlink" title="Wrap errors"></a>Wrap errors</h2><p><strong>日志记录与错误无关，且对调试没有帮助的信息应被视为噪音。</strong></p>
<p>The error has been logged (错误日志要被记录)</p>
<p>The application is back to 100% integrity (应用程序处理错误，)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不应该出现这种处理</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 仅仅打印日志，没有处理错误</span></span><br><span class="line">    fmt.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The current error is not reported any longer (之后不再报告当前错误)</p>
<p>不应该每一层都打印记录错误日志，一种是对错误降级记录后不再向上返回，一种是不记录向上返回错误，由最上层统一记录日志。</p>
<p><strong>主要有 Wrap、WithMessage、Cause 三个方法</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Wrap</span><span class="params">(err <span class="type">error</span>, message <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	err = &amp;withMessage&#123;</span><br><span class="line">		cause: err,</span><br><span class="line">		msg:   message,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;withStack&#123;</span><br><span class="line">		err,</span><br><span class="line">		callers(),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithMessage</span><span class="params">(err <span class="type">error</span>, message <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;withMessage&#123;</span><br><span class="line">		cause: err,</span><br><span class="line">		msg:   message,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Cause</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> causer <span class="keyword">interface</span> &#123;</span><br><span class="line">		Cause() <span class="type">error</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		cause, ok := err.(causer)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		err = cause.Cause()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Wrap，给原始错误添加信息，并携带堆栈信息</li>
<li>WithMessage，给错误添加信息，但不携带堆栈信息</li>
<li>Cause，对应 Wrap 操作，获取原始错误</li>
</ul>
<p><strong>使用 Wrap errors原则：</strong></p>
<ul>
<li>调用第三方库/标准库时，产生错误的地方，应该使用 Wrap 包装。</li>
<li>调用包内的函数时，不应该使用 Wrap（因为上一条已经包装过了），否则堆栈信息会重复。</li>
<li>在程序顶部 或者 goroutine 顶部，适用 <code>%+v</code> 记录堆栈详细信息。</li>
<li>使用 errors.Cause 获取 root error，再和 sentinel error 进行比较判定。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>只有业务代码会使用 pkg/errors 这个库，高度重用的代码（底层库标准库等）不应该使用 Wrap 包装错误。</li>
<li>我们应该在产生错误的地方 Wrap，然后在顶层打日志。</li>
<li>错误一旦被处理，就不应该再往上抛。</li>
</ol>
<br>

<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>视频里大佬分享的一些技巧</p>
<h3 id="case1"><a href="#case1" class="headerlink" title="case1"></a>case1</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line">f, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// handler error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// doSomething</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">f, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// doSomething</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// handler error</span></span><br></pre></td></tr></table></figure>

<p>建议使用方式1，方式2会导致业务代码缩进，我们应该优先处理错误，让业务逻辑成一条直线。</p>
<h3 id="case2"><a href="#case2" class="headerlink" title="case2"></a>case2</h3><p>方式1：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountLines</span><span class="params">(r io.Reader)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		br    = bufio.NewReader(r)</span><br><span class="line">		lines <span class="type">int</span></span><br><span class="line">		err   <span class="type">error</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		_, err = br.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		lines++</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != io.EOF &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lines, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式2：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountLines</span><span class="params">(r io.Reader)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		br    = bufio.NewScanner(r)</span><br><span class="line">		lines <span class="type">int</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> br.Scan() &#123;</span><br><span class="line">		lines++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lines, br.Err()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式2 是对 方式1 代码的优化。</p>
<h3 id="case3"><a href="#case3" class="headerlink" title="case3"></a>case3</h3><p>方式1：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key, value <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> status <span class="keyword">struct</span> &#123;</span><br><span class="line">	Code   <span class="type">int</span></span><br><span class="line">	Reason <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteResponse</span><span class="params">(w io.Writer, st status, headers []Header, body io.Reader)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	_, err := fmt.Fprintf(w, <span class="string">&quot;HTTP/1.1 %d %s\r\n&quot;</span>, st.Code, st.Reason)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, h := <span class="keyword">range</span> headers &#123;</span><br><span class="line">		_, err := fmt.Fprintf(w, <span class="string">&quot;%s: %s\r\n&quot;</span>, h.Key, h.value)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, err = fmt.Fprintf(w, <span class="string">&quot;\r\n&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = io.Copy(w, body)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式2：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> errWrite <span class="keyword">struct</span> &#123;</span><br><span class="line">	io.Writer</span><br><span class="line">	err <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ew *errWrite)</span></span> Write(buf []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> ew.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, ew.err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line">	n, ew.err = ew.Writer.Write(buf)</span><br><span class="line">	<span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteResponse</span><span class="params">(w io.Writer, st status, headers []Header, body io.Reader)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	ew := &amp;errWrite&#123;Writer: w&#125;</span><br><span class="line">	fmt.Fprintf(ew, <span class="string">&quot;HTTP/1.1 %d %s\r\n&quot;</span>, st.Code, st.Reason)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, h := <span class="keyword">range</span> headers &#123;</span><br><span class="line">		fmt.Fprintf(ew, <span class="string">&quot;%s: %s\r\n&quot;</span>, h.Key, h.value)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Fprintf(ew, <span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> ew.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式2自定义 errWrite 对象，并实现 io.Writer 接口，把 err 信息保存起来，最后再 return。</p>
<p>并且在 Write 内部使用 <code>if ew.err != nil</code>，来减少前文中的大量 <code>if err != nil</code>判断。 </p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>编写底层库的时候，可以使用 Opaque errors 这种风格</p>
<p>编写业务代码的时候，使用 Wrap errors 来处理错误</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>错误处理</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2021/06/30/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>因为一直在搞 node.js，对设计模式了解一直比较少，看了书不实践也记不住。最近在补充设计模式的知识。</p>
<p>工厂方法模式是一个比较常见的设计模式。</p>
<p>大部分资料将工厂方法模式分为三种：简单/静态工厂模式、工厂方法模式、抽象工厂模式。</p>
<p>简单工厂是对工厂方法的简化，而抽象工厂是对工厂方法的增强。</p>
<p>本文主要用 golang 来实现以下这三种工厂，然后分析一下优劣。</p>
<p><a href="https://github.com/ruomuc/test_demos/tree/master/blog/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F">本文代码仓库地址</a></p>
<span id="more"></span>

<h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><p>假设我们现在需要实现文件存储的功能：</p>
<ul>
<li>我们开发的时候使用 native 的服务器本地存储</li>
<li>线上环境使用腾讯云oss 存储</li>
</ul>
<p>先定义一个公共接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> oss</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OssImpl <span class="keyword">interface</span> &#123;</span><br><span class="line">	GetObject() <span class="type">error</span></span><br><span class="line">	PutObject() <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前我们有 本地 和 腾讯云oss两个途径，分别实现这个接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> tencentOss <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t tencentOss)</span></span> GetObject() <span class="type">error</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Get object &#x27;%s&#x27; from tencentOSS\n&quot;</span>, t.name)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t tencentOss)</span></span> PutObject() <span class="type">error</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Put object &#x27;%s&#x27; to tencentOSS\n&quot;</span>, t.name)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> native <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n native)</span></span> GetObject() <span class="type">error</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Get object &#x27;%s&#x27; from native\n&quot;</span>, n.name)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n native)</span></span> PutObject() <span class="type">error</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Put object &#x27;%s&#x27; to native\n&quot;</span>, n.name)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为是简单工厂，所以只需要一个工厂方法，根据传入的参数，创建不同对象：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ossType <span class="type">uint8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	TencentOss = <span class="literal">iota</span></span><br><span class="line">	Native</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OssFactory</span><span class="params">(name <span class="type">string</span>, t ossType)</span></span> (OssImpl, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> res OssImpl</span><br><span class="line">	<span class="keyword">if</span> t == TencentOss &#123;</span><br><span class="line">		res = tencentOss&#123;name&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> t == Native &#123;</span><br><span class="line">		res = native&#123;name&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建main.go，模拟调用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	oss <span class="string">&quot;simple-factory/oss&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tencentOss, err := oss.OssFactory(<span class="string">&quot;测试腾讯云OSS文件&quot;</span>, oss.TencentOss)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	_ = tencentOss.GetObject()</span><br><span class="line">	_ = tencentOss.PutObject()</span><br><span class="line"></span><br><span class="line">	native, err := oss.OssFactory(<span class="string">&quot;测试本地文件&quot;</span>, oss.Native)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	_ = native.GetObject()</span><br><span class="line">	_ = native.PutObject()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line">Get object <span class="string">&#x27;测试腾讯云OSS文件&#x27;</span> from tencentOSS</span><br><span class="line">Put object <span class="string">&#x27;测试腾讯云OSS文件&#x27;</span> to tencentOSS</span><br><span class="line">Get object <span class="string">&#x27;测试本地文件&#x27;</span> from native</span><br><span class="line">Put object <span class="string">&#x27;测试本地文件&#x27;</span> to native</span><br></pre></td></tr></table></figure>

<p>分析一下优缺点：</p>
<p>优点：</p>
<ul>
<li>调用方无需关心内部实现，我只需要根据我想要的类型，获得一个对象进行文件操作，符合迪米特法则。</li>
<li>代码量相对 工厂方法和抽象工厂 少许多。。比较简单</li>
</ul>
<p>缺点：</p>
<ul>
<li>如果我想要再加一个 阿里云的oss，那就需要改动 OssFactory 方法，不符合开闭原则。</li>
</ul>
<h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>在上文简单工厂中说道，简单工厂有个缺点，如果我要新增一个 阿里云oss，那就要改动原来的代码。</p>
<p>我们增加阿里云oss，使用工厂方法模式实现一下：</p>
<p>增加 aliOss，实现 OssImpl接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> aliOss <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a aliOss)</span></span> GetObject() <span class="type">error</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Get object &#x27;%s&#x27; from aliOss\n&quot;</span>, a.name)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a aliOss)</span></span> PutObject() <span class="type">error</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Put object &#x27;%s&#x27; to aliOss\n&quot;</span>, a.name)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前的一个工厂，变成了三个工厂：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> oss</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TencentOssFactory</span><span class="params">(name <span class="type">string</span>)</span></span> (OssImpl, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> tencentOss&#123;name: name&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NativeFactory</span><span class="params">(name <span class="type">string</span>)</span></span> (OssImpl, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> native&#123;name: name&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AliOssFactory</span><span class="params">(name <span class="type">string</span>)</span></span> (OssImpl, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> aliOss&#123;name: name&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现main.go 模拟调用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;factory-method/oss&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tencentOss, err := oss.TencentOssFactory(<span class="string">&quot;测试腾讯云OSS文件&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	_ = tencentOss.GetObject()</span><br><span class="line">	_ = tencentOss.PutObject()</span><br><span class="line"></span><br><span class="line">	native, err := oss.NativeFactory(<span class="string">&quot;测试本地文件&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	_ = native.GetObject()</span><br><span class="line">	_ = native.PutObject()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	aliOss, err := oss.AliOssFactory(<span class="string">&quot;测试阿里云OSS文件&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	_ = aliOss.GetObject()</span><br><span class="line">	_ = aliOss.PutObject()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line">Get object <span class="string">&#x27;测试腾讯云OSS文件&#x27;</span> from tencentOSS</span><br><span class="line">Put object <span class="string">&#x27;测试腾讯云OSS文件&#x27;</span> to tencentOSS</span><br><span class="line">Get object <span class="string">&#x27;测试本地文件&#x27;</span> from native</span><br><span class="line">Put object <span class="string">&#x27;测试本地文件&#x27;</span> to native</span><br><span class="line">Get object <span class="string">&#x27;测试阿里云OSS文件&#x27;</span> from aliOss</span><br><span class="line">Put object <span class="string">&#x27;测试阿里云OSS文件&#x27;</span> to aliOss</span><br></pre></td></tr></table></figure>

<p>根据打印日志，我们确实实现了 alioss的工厂方法。</p>
<p>工厂方法的优点：</p>
<ul>
<li>符合开闭原则，如果我们要再加一个 华为云oss， 只需要实现 OssImpl 接口，然后新增一个 hwOssFactory 方法就可以了，对历史代码没有任何改动。</li>
<li>同样对调用方隐藏了复杂的内部逻辑（虽然我们的demo很简单。），符合迪米特法则。</li>
</ul>
<p>缺点：</p>
<ul>
<li>在业务复杂时，会多写很多代码。</li>
</ul>
<h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>抽象工厂就比较复杂了，而且很少会用到。。</p>
<p>实在没想到上面的例子，用抽象工厂如何继续扩充需求。。（消息队列？但是和oss抽离不出来公共接口呀）</p>
<p>看这篇文章吧，虽然例子不够实用，但是也能说明问题：<a href="https://refactoringguru.cn/design-patterns/abstract-factory/go/example#example-0">https://refactoringguru.cn/design-patterns/abstract-factory/go/example#example-0</a></p>
<p>优点：</p>
<ul>
<li>多了一层抽象，减少了工厂的数量。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不符合开闭原则，如果需要增加产品族，那么就需要从头到尾改一遍。。。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>常用的就是简单工厂和工厂方法。</p>
<p>无论是哪种工厂，都隐藏了内部实现，耦合性低，符合迪米特法则。</p>
<p>简单工厂虽然不符合开闭原则，但是在比较简单的场景用的还是比较多。</p>
<p>抽象工厂比较复杂，而且扩展性也不强，一般用不到。。</p>
<p>疑问：</p>
<p>参考链接里有篇文章，使用工厂方法模式时，还多了一步注册工厂，没搞明白为什么要这么做。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/81715661">https://zhuanlan.zhihu.com/p/81715661</a></li>
<li><a href="https://www.zhihu.com/question/27125796">https://www.zhihu.com/question/27125796</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>go的math/rand标准库</title>
    <url>/2021/06/22/go%E7%9A%84math-rand%E6%A0%87%E5%87%86%E5%BA%93/</url>
    <content><![CDATA[<p>go语言中 math/rand 包来提供随机数相关功能。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>为了方便测试，我们新建一个 time_test.go 文件</p>
<span id="more"></span>

<p>执行以下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTime</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		fmt.Println(rand.Int())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="number">5577006791947779410</span></span><br><span class="line"><span class="number">8674665223082153551</span></span><br><span class="line"><span class="number">6129484611666145821</span></span><br></pre></td></tr></table></figure>

<p>我们发现，我们无论执行多少次，输出的结果总是一样的。。</p>
<p>查找标准库文档，我们发现我们可以修改 seed 来获取不一样的结果</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func Seed(seed int64) &#123; globalRand.Seed(seed) &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTime</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	rand.Seed(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		fmt.Println(rand.Int())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="number">1543039099823358511</span></span><br><span class="line"><span class="number">2444694468985893231</span></span><br><span class="line"><span class="number">474893212811123542</span></span><br></pre></td></tr></table></figure>

<p>我们通过 rand.Seed() 来设置一个 seed，seed只要是一个 int64 类型的参数就可以。(ps: 默认使用的seed 是 1)</p>
<p>虽然我们多次执行，输出任然没有变化，但是至少已经和上一段程序不一样了。</p>
<p>我们可以尝试多种不同的值。</p>
<p>这时候我会感到很疑惑？</p>
<ol>
<li>为什么程序每次执行输出的随机数都是一样的？<ul>
<li>这个再下文的伪随机会说到</li>
</ul>
</li>
<li>既然修改 seed ，可以得到不同的随机数，那为什么不每次调用 <code>rand.Int()</code> 前都调用一次 <code>rand.Seed(x)</code>呢？<ul>
<li>个人认为没有意义，还有可能会引起性能问题，哪怕是这么做了，也不能改变伪随机的事实</li>
</ul>
</li>
</ol>
<h2 id="伪随机"><a href="#伪随机" class="headerlink" title="伪随机"></a>伪随机</h2><p>通过前文发现，产生随机数的核心方法好像在于  rand.Seed() 方法。</p>
<p>我们查看 rand.Seed() 源码，核心差不多就是这些：</p>
<p>生成：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	rngLen   = <span class="number">607</span></span><br><span class="line">	rngTap   = <span class="number">273</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Seed uses the provided seed value to initialize the generator to a deterministic state.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rng *rngSource)</span></span> Seed(seed <span class="type">int64</span>) &#123;</span><br><span class="line">	rng.tap = <span class="number">0</span></span><br><span class="line">	rng.feed = rngLen - rngTap</span><br><span class="line"></span><br><span class="line">	seed = seed % int32max</span><br><span class="line">	<span class="keyword">if</span> seed &lt; <span class="number">0</span> &#123;</span><br><span class="line">		seed += int32max</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> seed == <span class="number">0</span> &#123;</span><br><span class="line">		seed = <span class="number">89482311</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	x := <span class="type">int32</span>(seed)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">-20</span>; i &lt; rngLen; i++ &#123;</span><br><span class="line">		x = seedrand(x)</span><br><span class="line">		<span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> u <span class="type">int64</span></span><br><span class="line">			u = <span class="type">int64</span>(x) &lt;&lt; <span class="number">40</span></span><br><span class="line">			x = seedrand(x)</span><br><span class="line">			u ^= <span class="type">int64</span>(x) &lt;&lt; <span class="number">20</span></span><br><span class="line">			x = seedrand(x)</span><br><span class="line">			u ^= <span class="type">int64</span>(x)</span><br><span class="line">			u ^= rngCooked[i]</span><br><span class="line">			rng.vec[i] = u</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Uint64 returns a non-negative pseudo-random 64-bit integer as an uint64.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rng *rngSource)</span></span> Uint64() <span class="type">uint64</span> &#123;</span><br><span class="line">	rng.tap--</span><br><span class="line">	<span class="keyword">if</span> rng.tap &lt; <span class="number">0</span> &#123;</span><br><span class="line">		rng.tap += rngLen</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rng.feed--</span><br><span class="line">	<span class="keyword">if</span> rng.feed &lt; <span class="number">0</span> &#123;</span><br><span class="line">		rng.feed += rngLen</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	x := rng.vec[rng.feed] + rng.vec[rng.tap]</span><br><span class="line">	rng.vec[rng.feed] = x</span><br><span class="line">	<span class="keyword">return</span> <span class="type">uint64</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看起来有些复杂。（<del>完全看不懂 哈哈</del>）</p>
<p>只用知道这里使用的是专业的数学方法，目的是给 的 607 个槽设置对应的值。 </p>
<p>这也导致了相同的 seed, 最终设置到 rng.vec 里面的值是相同的, 通过 Intn 取出的也是相同的值。</p>
<h2 id="并发安全"><a href="#并发安全" class="headerlink" title="并发安全"></a>并发安全</h2><p>查看源码，我们默认使用的 rand 对象是这样创建的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> lockedSource <span class="keyword">struct</span> &#123;</span><br><span class="line">	lk  sync.Mutex</span><br><span class="line">	src *rngSource</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Top-level convenience functions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> globalRand = New(&amp;lockedSource&#123;src: NewSource(<span class="number">1</span>).(*rngSource)&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建出来的对象，我断点出来是这样的：</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/WX20210623-001621%402x.png" style="zoom:50%;" />

<p>以 rand.Int() 为例，差不多是如下调用顺序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Int returns a non-negative pseudo-random int.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rand)</span></span> Int() <span class="type">int</span> &#123;</span><br><span class="line">	u := <span class="type">uint</span>(r.Int63())</span><br><span class="line">	<span class="keyword">return</span> <span class="type">int</span>(u &lt;&lt; <span class="number">1</span> &gt;&gt; <span class="number">1</span>) <span class="comment">// clear sign bit if int == int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Int63 returns a non-negative pseudo-random 63-bit integer as an int64.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rand)</span></span> Int63() <span class="type">int64</span> &#123; <span class="keyword">return</span> r.src.Int63() &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *lockedSource)</span></span> Int63() (n <span class="type">int64</span>) &#123;</span><br><span class="line">	r.lk.Lock()</span><br><span class="line">	n = r.src.Int63()</span><br><span class="line">	r.lk.Unlock()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Int63 returns a non-negative pseudo-random 63-bit integer as an int64.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rng *rngSource)</span></span> Int63() <span class="type">int64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">int64</span>(rng.Uint64() &amp; rngMask)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Uint64 returns a non-negative pseudo-random 64-bit integer as an uint64.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rng *rngSource)</span></span> Uint64() <span class="type">uint64</span> &#123;</span><br><span class="line">	rng.tap--</span><br><span class="line">	<span class="keyword">if</span> rng.tap &lt; <span class="number">0</span> &#123;</span><br><span class="line">		rng.tap += rngLen</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rng.feed--</span><br><span class="line">	<span class="keyword">if</span> rng.feed &lt; <span class="number">0</span> &#123;</span><br><span class="line">		rng.feed += rngLen</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	x := rng.vec[rng.feed] + rng.vec[rng.tap]</span><br><span class="line">	rng.vec[rng.feed] = x</span><br><span class="line">	<span class="keyword">return</span> <span class="type">uint64</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，lockedSource 的所有方法，都会有一个全局共享锁，所以可以保证并发安全。</p>
<p>当然我们也可以创建一个自定义的 rand 对象：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTime</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	r := rand.New(rand.NewSource(<span class="number">1</span>))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		fmt.Println(r.Int())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这样在并发场景下，会出现问题。</p>
<p>参考链接：</p>
<p><a href="https://golang.org/pkg/math/rand/">https://golang.org/pkg/math/rand/</a></p>
<p><a href="https://gocn.vip/topics/11689">https://gocn.vip/topics/11689</a></p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Handle、HandleFunc、Handler和HandlerFunc</title>
    <url>/2021/06/10/%E5%85%B3%E4%BA%8EHandle%E3%80%81HandleFun%E3%80%81Handler%E5%92%8CHandlerFunc/</url>
    <content><![CDATA[<p>在go中，可以很简单实现一个http服务器。</p>
<p>但是在使用过程中，遇到了一些容易使人迷惑的类型、接口或方法名。</p>
<p>于是决定深入了解并记录一下它们的区别。</p>
<p>ps: 本文的前置知识是，需要对go中的面向对象和接口有一定的了解。</p>
<span id="more"></span>

<p>我们可以这样创建一个http server</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Hello <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Hello)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;hello %s&quot;</span>, h.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, indexHandler)</span><br><span class="line">	http.Handle(<span class="string">&quot;/hello&quot;</span>, &amp;Hello&#123;<span class="string">&quot;ruomu&quot;</span>&#125;)</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:8000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时如果你访问 <code>localhost:8080/</code> 会看到 <code>hello world</code></p>
<p>如果访问<code>localhost:8080/hello</code>会看到<code>hello ruomu</code></p>
<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>我们翻看源码<code>net/http/server.go</code>可以看到：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以所有实现了 ServeHTTP 方法的结构体创建出来的对象，都可以看做是一个Handler类型的对象。</p>
<h2 id="Handle"><a href="#Handle" class="headerlink" title="Handle"></a>Handle</h2><p>源码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(pattern <span class="type">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">  DefaultServeMux.Handle(pattern, handler) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，第一个参数不用说了，是绑定的路由，第二个参数是一个 Handler类型的对象。</p>
<p>再回头看前文的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">type</span> Hello <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Hello)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;hello %s&quot;</span>, h.name)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">http.Handle(<span class="string">&quot;/hello&quot;</span>, &amp;Hello&#123;<span class="string">&quot;ruomu&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><code>ServeHTTP</code> 方法其实对应的就是对应路由被访问时，对应的执行处理方法，至于具体什么时候被执行，如果绑定这些细节这里先不说了。</p>
<p>是不是知道为什么，访问 <code>localhost:8080/hello</code> 会出现 <code>hello ruomu</code>了。</p>
<h2 id="HandleFunc"><a href="#HandleFunc" class="headerlink" title="HandleFunc"></a>HandleFunc</h2><p>源码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="type">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span></span>) &#123;</span><br><span class="line">	DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现和 Handle 的区别：</p>
<p>第二个参数不一样，Handle 的第二个参数是一个Handler 类型的对象，而HandleFunc的第二个参数，直接就是一个 <code>func(ResponseWriter, *Request)</code>类型的函数 。</p>
<p>里面执行的语句也有点不大相同，分别是 <code> DefaultServeMux.Handle(pattern, handler)</code> 和 <code>    DefaultServeMux.HandleFunc(pattern, handler)</code>。它们也只是调用了不同的方法，并且第二个参数不同。。。感觉像是在套娃？ 这里先不展开说了，我们只需要知道它们是正正的注册路由的对象就行了。</p>
<p>试想一下，如果我们需要绑定1000个路由和其对应的处理方法，那我们是不是要写1000个struct？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> r1 <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(route r1)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;...&#125;</span><br><span class="line"><span class="keyword">type</span> r2 <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(route r2)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;...&#125;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="keyword">type</span> r1000 <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(route r1000)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.Handle(<span class="string">&quot;/r1&quot;</span>, &amp;r1&#123;&#125;)</span><br><span class="line">  http.Handle(<span class="string">&quot;/r2&quot;</span>, &amp;r2&#123;&#125;)</span><br><span class="line">  ...</span><br><span class="line">	http.Handle(<span class="string">&quot;/r100&quot;</span>, &amp;r1000&#123;&#125;)</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:8000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的代码是难以阅读并且难以维护的，我们根本就不需要这么多结构体，我们最终关心的其实时处理方法 ServeHTTP。</p>
<p>看下前文的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, indexHandler)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>是不是已经知道，如何改造绑定1000个路由的代码了。。</p>
<h2 id="HandlerFunc"><a href="#HandlerFunc" class="headerlink" title="HandlerFunc"></a>HandlerFunc</h2><p>源码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls f(w, r).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="line">	f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个写法很有意思啊。。</p>
<p>其实目的也是解决绑定1000个路由需要定义1000个struct的问题。</p>
<p>使用  HandlerFunc 进行强制类型转换，因为HandlerFunc也实现了 ServeHTTP方法，所以可以当做一个Handler类型的对象作为http.Handle的第二个参数。</p>
<p>然后Handler的ServeHTTP方法中使用 <code>f(w,r)</code>，啊这。。秒啊。。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">http.Handle(<span class="string">&quot;/&quot;</span>, http.HandlerFunc(indexHandler))</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>现在是不是疑惑，HandleFunc 和 HandlerFunc有区别？为什么要两种写法呢。。</p>
<p>其实我们继续看HandleFunc的源码就知道了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="type">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span></span>) &#123;</span><br><span class="line">	DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span></span> HandleFunc(pattern <span class="type">string</span>, handler <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;http: nil handler&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，HandleFunc 最后还是使用了 <code>Handle(pattern, HandlerFunc(handler))</code> 来处理的。。</p>
<h2 id="DefaultServeMux"><a href="#DefaultServeMux" class="headerlink" title="DefaultServeMux"></a>DefaultServeMux</h2><p>这里顺便说一下，本文一开始的代码中，为什么<code>   http.ListenAndServe(&quot;:8000&quot;, nil)</code>第二个参数要传一个 nil 呢。</p>
<p>关于ServeMux到时候另写一片文章，这里直接不细说。</p>
<p>http.ListenAndServe 的第二个参数其实是一个ServeMux对象，如果不传的话，就会使用默认的 DefaultServeMux。</p>
<p>这篇文章代码里使用的所有绑定路由的方法，都是绑定在 DefaultServeMux上的，如果我们使用 NewServeMux创建一个自定义对象，并且当做 http.ListenAndServe 的第二个参数传入的话，它们就会失效。</p>
<p><code>net/http/server.go:2835</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span></span> ServeHTTP(rw ResponseWriter, req *Request) &#123;</span><br><span class="line">	handler := sh.srv.Handler</span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		handler = DefaultServeMux</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> req.RequestURI == <span class="string">&quot;*&quot;</span> &amp;&amp; req.Method == <span class="string">&quot;OPTIONS&quot;</span> &#123;</span><br><span class="line">		handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Handler 是一个接口，只有一个 ServeHTTP方法。</li>
<li>Handle 绑定路由第二个参数需要传一个Handler类型的对象。</li>
<li>HandlerFunc 写法比较有意思，他也实现了 ServeHTTP方法，可以强转一个函数为Handler类型的对象，并当做Handle 的第二个参数。</li>
<li> <code>HandleFunc(pattern, handle)</code> 写法等于 <code>Handle(pattern, HandlerFunc(handle)) </code></li>
</ul>
<p>ps: 如果看不懂我写得东西很正常，本来就是记录不是什么教程，写得很随意。这里建议直接看参考链接里的文章。多看多练。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://perennialsky.medium.com/understand-handle-handler-and-handlefunc-in-go-e2c3c9ecef03">https://perennialsky.medium.com/understand-handle-handler-and-handlefunc-in-go-e2c3c9ecef03</a></li>
<li><a href="https://cizixs.com/2016/08/17/golang-http-server-side/">https://cizixs.com/2016/08/17/golang-http-server-side/</a></li>
<li><a href="https://learnku.com/articles/37867">https://learnku.com/articles/37867</a></li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>关于tcp的”粘包“和“拆包”</title>
    <url>/2021/06/04/%E5%85%B3%E4%BA%8Etcp%E7%9A%84%E2%80%9D%E7%B2%98%E5%8C%85%E2%80%9C%E5%92%8C%E2%80%9C%E6%8B%86%E5%8C%85%E2%80%9D/</url>
    <content><![CDATA[<p>第一次听到“粘包”这个名词，还是用 websocket 做游戏的时候，当时服务端收到的消息出现了乱码，因为中文汉字在utf-8中用三个字节表示，如果被截断了话，解析出来就是乱码。</p>
<p>后面就一直做的传统的http服务端开发，就没有太关注这个问题了。</p>
<p>最近在看一个《趣谈网络协议》课，就顺便把这个问题搞明白。</p>
<span id="more"></span>

<h2 id="为什么会出现”粘包“和“拆包”"><a href="#为什么会出现”粘包“和“拆包”" class="headerlink" title="为什么会出现”粘包“和“拆包”"></a>为什么会出现”粘包“和“拆包”</h2><p>知乎上有些说什么 “中式伪科学” 之类的来鄙视称呼“粘包”和“拆包”的人。</p>
<p>关于“粘包”这个名词，我们不去讨论它的正确性，我觉得只要能使大家达成共识，明白表达的意思就行。</p>
<p>关于tcp的知识也不详细说了，上一篇文章就是<a href="http://ruomuc.gitee.io/blog/2021/05/19/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-%E7%AC%94%E8%AE%B0/">《趣谈网络协议的笔记》</a>。</p>
<p>首先tcp是一个面向流的全双工协议，并且在发送端和接收端分别有一个 发送缓冲区和接收缓冲区。</p>
<p>因为 tcp 是一个面向流的协议，而流是没有边界的，使用流来传输数据时，tcp 并不能理解这些数据在业务层含义，并且有缓冲区的存在，tcp不会及时的读取和发送数据。</p>
<p>所以发生“粘包”和”拆包“的原因差不多就是：</p>
<ul>
<li>要发送的数据大于tcp缓冲区的大小，会发生“拆包”</li>
<li>待发送数据大于MSS（最大报文长度），TCP在传输前将进行”拆包“</li>
<li>要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生“粘包”</li>
<li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生“粘包”</li>
</ul>
<p><a href="http://ruomuc.gitee.io/blog/2018/08/15/%E5%85%B3%E4%BA%8EBuffer/">关于buffer</a>这篇文章中，也有使用流读取取数据，被buffer截断的列子。</p>
<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>一般来说，只要让接收方知道，每一个有效数据包的大小就可以了。</p>
<p>解决方法：</p>
<ol>
<li>使用分隔符：比如换行符这种作为一个包的结束标记。</li>
<li>定义数据包长度：在数据包中增加一个长度字段，标记这个数据包的大小。</li>
</ol>
<p>更多解决方法网上有很多，但是比较推荐的就是定义数据包的长度这种做法。</p>
<h2 id="http协议是如何做的？"><a href="#http协议是如何做的？" class="headerlink" title="http协议是如何做的？"></a>http协议是如何做的？</h2><p>我一直有个疑问，自从没有做游戏开发（没有用websocket）后，好像就在也没有遇到过这类问题。</p>
<p>http 是基于tcp的应用层协议，tcp会遇到的问题，理论上来说它也会遇到。</p>
<p>但是为什么我从来不用关心，也没有遇到“粘包”问题呢？</p>
<p>推荐看一下这篇文章：<a href="https://blog.fundebug.com/2019/09/10/understand-http-content-length/">https://blog.fundebug.com/2019/09/10/understand-http-content-length/</a></p>
<p>所以，我的理解就是，http 通过请求头的 content-length 来指定数据包的长度，所以每次解析出来的数据都和发送的数据一样大。</p>
<p>ps: 不知道理解的对不对。希望有人可以给我解惑。。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/nsgeG5h1xiVO2Ny5bfM57w">https://mp.weixin.qq.com/s/nsgeG5h1xiVO2Ny5bfM57w</a></li>
<li><a href="https://blog.fundebug.com/2019/09/10/understand-http-content-length/">https://blog.fundebug.com/2019/09/10/understand-http-content-length/</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络与操作系统</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>go的defer关键字</title>
    <url>/2021/05/30/go%E7%9A%84defer%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>go 语言中的 defer 关键字常用语关闭文件描述符、数据库连接或解锁资源。（这是 node.js 没有的）</p>
<p>本文主要研究一下，defer 如何使用以及它的执行机制。</p>
<span id="more"></span>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>假设有如下方法，用于处理一个文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DealFile</span> <span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  file, err := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略业务操作</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  file.Close()</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段程序有一个问题。。如果 os.Open() 返回了一个错误，那么将永远不会执行 file.Close()，当打开的文件数过多时，就会触发”too many open files“的系统错误，从而让整个系统陷入崩溃。</p>
<p>那么如何避免呢，可以使用 defer 关键字，在 os.Open() 之后马上调用 file.Close()：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DealFile</span> <span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  file, err := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> file.Close()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略业务操作</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="执行规则"><a href="#执行规则" class="headerlink" title="执行规则"></a>执行规则</h2><p>defer 的使用看起来很简单，但是如果没有真正理解 defer 的执行规则，会遇到很多奇怪的问题。</p>
<h3 id="defer-的执行顺序"><a href="#defer-的执行顺序" class="headerlink" title="defer 的执行顺序"></a>defer 的执行顺序</h3><p>多个 defer 调用，如何执行：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  i := <span class="number">1</span></span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">  i++</span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">  i++</span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">  i++</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>很简单可以看出，多个 defer 的执行顺序是<strong>后进先出</strong>。</p>
<h3 id="defer-的参数解析"><a href="#defer-的参数解析" class="headerlink" title="defer 的参数解析"></a>defer 的参数解析</h3><p>看三个代码片段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  i := <span class="number">1</span></span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">  i++</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  i := <span class="number">1</span></span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>&#123;fmt.Println(i)&#125;() </span><br><span class="line">  i++</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  i := <span class="number">1</span></span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span> <span class="params">(i <span class="type">int</span>)</span></span>&#123;fmt.Println(i)&#125;(i) </span><br><span class="line">  i++</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol>
<li>defer 关键字的参数是实时调用并解析计算的。</li>
<li>使用不传参的匿名函数可以解决这一点。</li>
</ol>
<h3 id="defer链式调用"><a href="#defer链式调用" class="headerlink" title="defer链式调用"></a>defer链式调用</h3><p>还有一种还少见的情况，链式调用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> f(n <span class="type">int</span>) T &#123;</span><br><span class="line">  fmt.Println(n)</span><br><span class="line">  <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> t T</span><br><span class="line">  <span class="keyword">defer</span> t.f(<span class="number">1</span>).f(<span class="number">2</span>)</span><br><span class="line">  fmt.Println(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>这段代码是我在某大佬博客里整理的面试题里看到的，是这样解释的：</p>
<p>defer 延迟调用时，需要保存函数指针和参数，因此链式调用的情况下，除了最后一个函数/方法外的函数/方法都会在调用时直接执行。也就是说 t.f(1) 直接执行，然后执行 fmt.Print(3)，最后函数返回时再执行 .f(2)，因此输出是 132。</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>趣谈网络协议-笔记</title>
    <url>/2021/05/19/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>公司开了个极客时间企业版，一人挑五门课</p>
<p>看了下这个《趣谈网络协议》挺有意思的</p>
<p>只看了前两讲就感觉收获挺大，所以记记笔记方便以后查找知识</p>
<h2 id="通信协议综述"><a href="#通信协议综述" class="headerlink" title="通信协议综述"></a>通信协议综述</h2><h3 id="协议三要素"><a href="#协议三要素" class="headerlink" title="协议三要素"></a>协议三要素</h3><ul>
<li><strong>语法</strong>： 符合一定的规则和格式。例如括号要成对，换行要有分号。</li>
<li><strong>语义</strong>： 代表某种意义。例如数字可以相间，字符串相减没有意义。</li>
<li><strong>顺序</strong>： 就是先干什么后干什么。例如 1+1-1 就是 先执行 1+1 在用结果减 1。</li>
</ul>
<span id="more"></span>

<h3 id="网络协议和层级"><a href="#网络协议和层级" class="headerlink" title="网络协议和层级"></a>网络协议和层级</h3><table>
<thead>
<tr>
<th>层级</th>
<th>协议</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>DHCP HTTP HTTPS RTMP P2P DNS GTP RPC</td>
</tr>
<tr>
<td>传输层 （TCP/UDP 层）</td>
<td>UPD TCP</td>
</tr>
<tr>
<td>网络层 （IP层）</td>
<td>ICMP IP OSPF BGP IPSec GRE</td>
</tr>
<tr>
<td>链路层 （MAC层）</td>
<td>ARP VLAN STP</td>
</tr>
<tr>
<td>物理层</td>
<td>网络跳线</td>
</tr>
</tbody></table>
<p><strong>当网络包到达一个城关的时候，可以通过路由表得到下一个城关的 IP 地址，直接通过 IP 地址找就可以了，为什么还要通过本地的 MAC 地址呢？</strong></p>
<ol>
<li>mac地址 相当于身份证号（网卡厂商分配，理论上是唯一的但可以被修改），ip地址 相当于现居住地（连接到网络时，网络运营商分配）。</li>
<li>历史原因，网络发展史是先有 <strong>数据链路层(MAC地址)</strong> 再有 <strong>网路层(IP地址)</strong> 的。</li>
<li>网络分层，只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层。也就是说在网络分层的角度 数据包不可能只有<strong>IP地址</strong>没有<strong>MAC地址</strong>。</li>
</ol>
<p><strong>为什么要网络分层？</strong></p>
<p>​    <strong>复杂的程序都要分层，这是程序设计的要求。</strong>比如，复杂的电商还会分数据库层、缓存层、Compose 层、Controller 层和接入层，每一层专注做本层的事情。</p>
<img src="https://static001.geekbang.org/resource/image/5c/76/5c00f6e610f533d17fb4ad7decacc776.jpg" alt="img" style="zoom:15%;" />

<h3 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h3><p><strong>如何查看ip地址?</strong></p>
<ul>
<li>windows：ipconfig</li>
<li>linux：ifconfig  和  ip addr</li>
</ul>
<p><strong>ip地址的组成?</strong></p>
<p>10.100.122.2 就是一个 IP 地址。这个地址被点分隔为四个部分，每个部分 8 个 bit，所以 IP 地址总共是 32 位。</p>
<p><strong>ip地址被分为五类</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>IP地址范围</th>
<th>最大主机数</th>
<th>私有IP地址范围</th>
</tr>
</thead>
<tbody><tr>
<td>A类</td>
<td>0丨网络号(7位)丨主机号(24位)</td>
<td>0.0.0.0 - 127.255.255.255</td>
<td>16777214</td>
<td>10.0.0.0 - 10.255.255.255</td>
</tr>
<tr>
<td>B类</td>
<td>10丨网络号(14位)丨主机号(16位)</td>
<td>128.0.0.0 - 191.255.255.255</td>
<td>65534</td>
<td>172.16.0.0 - 172.31.255.255</td>
</tr>
<tr>
<td>C类</td>
<td>110丨网络号(21位)丨主机号(16位)</td>
<td>192.0.0.0 - 223.255.255.255</td>
<td>254</td>
<td>192.168.0.0 - 192.168.255.255</td>
</tr>
<tr>
<td>D类</td>
<td>1110丨多播组号(28位)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E类</td>
<td>11110丨留待后用(27位)</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>无类型域间选路（CIDR）</strong></p>
<p>由于 C 类地址包含的最大主机数太少，只有 254个。而 B 类地址包含主机数又太多。</p>
<p>所以有了一种折中的方式叫 <strong>无类型域间选路</strong>，简称 <strong>CIDR</strong>。</p>
<p>CIDR 将 32 位IP地址一分为二，前面是网络号，后面是主机号。</p>
<p>比如 10.100.122.2/24，这个IP地址有一个斜杠，斜杠后的 24 代表前24位是网络号，后8位是主机号。</p>
<p>伴随 CIDR 存在的是<strong>广播地址</strong>和<strong>子网掩码</strong>。</p>
<ul>
<li>10.100.122.2/24 的广播地址是 10.100.122.255</li>
<li>10.100.122.2/24 的子网掩码是 255.255.255.0</li>
</ul>
<p>将<strong>子网掩码</strong>和<strong>IP地址</strong>进行<strong>按位与</strong>运算就可以得到<strong>网络号</strong></p>
<ul>
<li>10.100.122.2 按位与 255.255.255.0 就是 10.100.122.0</li>
</ul>
<p><strong>计算 CIDR 表示的 IP地址 16.158.165.91/22 的第一个地址、子网掩码 和 广播地址。</strong></p>
<ul>
<li>第一个地址是 16.158.&lt;101001&gt;&lt;00&gt;.1 即 16.158.164.1</li>
<li>子网掩码是 255.255.&lt;111111&gt;&lt;00&gt;.0 即 255.255.252.0</li>
<li>广播地址是 16.158.&lt;101001&gt;&lt;11&gt;.255 即 16.158.167.255</li>
</ul>
<p><strong>小结</strong></p>
<ul>
<li>IP 是地址，有定位功能；MAC 是身份证，无定位功能</li>
<li>CIDR 可以用来判断是不是本地人</li>
<li>IP 分公有的 IP 和私有的 IP</li>
</ul>
<h3 id="DHCP-和-PXE"><a href="#DHCP-和-PXE" class="headerlink" title="DHCP 和 PXE"></a>DHCP 和 PXE</h3><p><strong>如何获取目标MAC地址？</strong></p>
<ol>
<li>linux 会判断<strong>目标IP地址</strong>和<strong>我</strong>是一个网段的吗，或者和<strong>我的一个网卡</strong>是同一网段的吗？如果是一个网段的，会发送 <strong>ARP</strong> 请求，获取MAC地址。</li>
<li>如果不是，linux 会认为这个一个<strong>跨网关调用</strong>，会获取<strong>网关</strong>的 <strong>MAC地址</strong>，然后将包发到网关。</li>
<li>每经过一个网关，MAC地址都会被替换下一次要去的网关的MAC地址，直到到达和<strong>目标IP地址</strong>同网段的网关时，发送 ARP请求获取目标IP的主机 MAC 地址。</li>
</ol>
<p><strong>DHCP 的工作方式</strong></p>
<ol>
<li><p>当一台新机器假如网络时，只知道自己的 MAC地址，先”吼”一句告诉别人我来了。这一步称为 <strong>DHCP Discover</strong>。</p>
<ul>
<li>新来的机器使用 IP地址 0.0.0.0 发送一个广播包，目的IP为 255.255.255.255</li>
<li>广播包封装了 UDP，UDP封装了BOOTP</li>
</ul>
<img src="https://static001.geekbang.org/resource/image/90/81/90b4d41ee38e891031705d987d5d8481.jpg" alt="img" style="zoom:25%;" /></li>
<li><p>如果网络管理员配置了 DHCP Server的话，它就会立刻知道来了”新人”，这时候会验证 MAC地址的唯一性，并且租给新人一个IP地址。这个过程我们称为 <strong>DHCP Offer</strong>。</p>
<ul>
<li><p>DHCP Server 会保留为该”新人”分配的IP地址，防止分配给其他人</p>
</li>
<li><p>DHCP Server仍然使用广播地址作为目的地址，因为”新人”还没有IP地址</p>
</li>
</ul>
<img src="https://static001.geekbang.org/resource/image/a5/6b/a52c8c87b925b52059febe9dfcd6be6b.jpg" alt="img" style="zoom:25%;" /></li>
<li><p>新来的机器收到了 “吼”的回复，并且如果同时收到多个 DHCP Server的回复，它会决定使用谁提供的IP地址，一般是第一个回复的，并且告诉其它 DHCP服务，请求它们撤销提供的IP地址，以便可以分配给其他人。</p>
<ul>
<li>由于还没有得到 DHCP Server 的最后确认，客户端仍然使用 0.0.0.0 为源 IP 地址、255.255.255.255 为目标地址进行广播。</li>
</ul>
</li>
<li><p>当 DHCP Server 接收到新来的机器的 <strong>DHCP request</strong> 之后，会<strong>广播</strong>返回给它一个 <strong>DHCP ACK</strong> 消息包，表明已经接受客户机的选择，并将这一 IP 地址的合法租用信息和其他的配置信息都放入该广播包，发给客户机，欢迎它加入网络大家庭。</p>
<img src="https://static001.geekbang.org/resource/image/cd/fa/cdbcaad24e1a4d24dd724e38f6f043fa.jpg" alt="img" style="zoom:25%;" /></li>
</ol>
<p><strong>PXE（预启动执行环境）工作过程</strong></p>
<p>可以自动安装操作系统。</p>
<p>ps： 了解一下工作过程就行了。。</p>
<img src="https://static001.geekbang.org/resource/image/bb/8e/bbc2b660bba0ad00b5d1179db158498e.jpg" alt="img" style="zoom:15%;" />



<h2 id="从2层-MAC层-到3层-网络层"><a href="#从2层-MAC层-到3层-网络层" class="headerlink" title="从2层(MAC层)到3层(网络层)"></a>从2层(MAC层)到3层(网络层)</h2><h3 id="从物理层到链路层"><a href="#从物理层到链路层" class="headerlink" title="从物理层到链路层"></a>从物理层到链路层</h3><p><strong>物理层</strong></p>
<ul>
<li>电脑连电脑。</li>
<li>集线器。</li>
</ul>
<p><strong>数据链路层（MAC层）</strong></p>
<p>数据链路层其实包含:</p>
<ul>
<li>LLC（The logical link control），逻辑控制链路</li>
<li>MAC（Medium Access Control），媒体访问控制</li>
</ul>
<blockquote>
<p>由于TCP/IP 体系经常使用的局域网是 DIX Ethernet V2而不是 IEEE 802 标准中的几种局域网，因此现在 802 委员会制定的逡辑链路控制子层 LLC （即 802.2 标准）的作用已经不大了。 </p>
<p>很多厂商生产的网卡上就仅装有 MAC 协议而没有 LLC 协议</p>
</blockquote>
<p>所以一般不考虑 LLC 层，只考虑MAC层。</p>
<p>主要解决这几个问题：</p>
<ol>
<li>这个包是发给谁的？谁应该接收？<ul>
<li>这里用到一个物理地址，叫作<strong>链路层地址</strong>。但是因为第二层主要解决媒体接入控制的问题，所以它常被称为<strong>MAC 地址</strong></li>
</ul>
</li>
<li>大家都在发，会不会产生混乱？有没有谁先发、谁后发的规则？<ul>
<li><strong>信道划分</strong>：分多个车道，每个车一个车道，你走你的我走我的</li>
<li><strong>轮流协议</strong>：今天单号，明天双号，轮流出行</li>
<li><strong>随机接入协议</strong>：不管三七二十一，有事儿先出门，发现特堵，就回去，错过高峰再出。以太网就是这个方式。</li>
</ul>
</li>
<li>如果发送的时候出现了错误，怎么办？<ul>
<li><strong>CRC</strong>(循环冗余检测)：通过 XOR 异或的算法，来计算整个包是否在发送的过程中出现了错误</li>
</ul>
</li>
</ol>
<p><strong>ARP协议</strong></p>
<p>ARP协议是一个网络层协议，也就是已知 IP 地址，求 MAC 地址的协议。</p>
<p>原理是发送广播包，目标IP回答。</p>
<p>为避免每次都是用ARP请求，机器会进行ARP缓存（ARP缓存表），并且该缓存会有过期时间。</p>
<p><strong>交换机</strong></p>
<p>交换机一般工作在 数据链路层（MAC层）</p>
<p>交换机可以通过学习记录连接某个口的MAC地址。交换机的学习结果称为<strong>转发表</strong>，并且有过期时间。</p>
<blockquote>
<p>一台 MAC1 电脑将一个包发送给另一台 MAC2 电脑，当这个包到达交换机的时候，一开始交换机也不知道 MAC2 的电脑在哪个口，所以没办法，它只能将包转发给除了来的那个口之外的其他所有的口。但是，这个时候，交换机会干一件非常聪明的事情，就是交换机会记住，MAC1 是来自一个明确的口。以后有包的目的地址是 MAC1 的，直接发送到这个口就可以了。</p>
</blockquote>
<p><strong>RARP协议</strong></p>
<p>根据MAC地址获取IP的协议。。知道就行了。。</p>
<p><strong>如果一个局域网里面有多个交换机，ARP 广播的模式会出现什么问题呢？</strong></p>
<blockquote>
<p>ARP广播时，交换机会将一个端口收到的包转发到其它所有的端口上。<br>比如数据包经过交换机A到达交换机B，交换机B又将包复制为多份广播出去。<br>如果整个局域网存在一个环路，使得数据包又重新回到了最开始的交换机A，这个包又会被A再次复制多份广播出去。<br>如此循环，数据包会不停得转发，而且越来越多，最终占满带宽，或者使解析协议的硬件过载，行成广播风暴。</p>
</blockquote>
<h3 id="交换机与VLAN"><a href="#交换机与VLAN" class="headerlink" title="交换机与VLAN"></a>交换机与VLAN</h3><p><strong>拓扑结构是如何形成的</strong></p>
<p>假设现在两台交换机，连接着三个局域网，机器1想要访问机器4，但是机器1只知道机器4的IP地址，不知道MAC地址。</p>
<img src="https://static001.geekbang.org/resource/image/08/29/0867321c36cc52bd3dd4d7622583fa29.jpg" alt="img" style="zoom:15%;" />

<ol>
<li>机器1发起一个广播，机器2收到广播，但跟自己没关系。</li>
<li>交换机A也收到了广播，但是它不知道任何拓扑信息，于是它向除了广播包的来源方向外，转发给其它所有网口。</li>
<li>机器3收到了广播信息，发现也不是找自己的。</li>
<li>交换机B收到广播后，采用交换机A相同操作。</li>
<li>机器4和机器5也收到广播，机器4发现是找自己的（IP地址一致），于是响应说这是找我的。</li>
<li>最后，交换机A和交换机B现在都知道机器1是左边这个网口的。</li>
<li>如果这时机器3需要访问机器1，交换A和交换机B就不会再广播右边的网口了。</li>
</ol>
<p><strong>如何解决环路问题</strong></p>
<ol>
<li>STP协议就是使用最小生成树的思想。关于最小生成树可以看我之前分享的：<a href="http://ruomuc.gitee.io/blog/2021/02/28/Kruskal%E7%AE%97%E6%B3%95/">Kruskal算法</a></li>
<li><strong>物理隔离</strong>和<strong>虚拟隔离</strong>（VLAN形成虚拟局域网隔离）</li>
</ol>
<h3 id="ICMP和ping"><a href="#ICMP和ping" class="headerlink" title="ICMP和ping"></a>ICMP和ping</h3><p><strong>ICMP协议</strong></p>
<p>ICMP 全称 Internet Control Message Protocol，就是<strong>互联网控制报文协议</strong>。</p>
<p>ICMP是一个网络层协议。</p>
<table>
<thead>
<tr>
<th>类型值</th>
<th>ICMP消息类型</th>
<th>错误消息</th>
<th>查询消息</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Echo Reply<br />回送响应消息</td>
<td></td>
<td>✅</td>
</tr>
<tr>
<td>3</td>
<td>Destination Unreachable<br />目的不可达</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>Redirect<br />重定向</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>Echo Request<br />回送请求消息</td>
<td></td>
<td>✅</td>
</tr>
<tr>
<td>11</td>
<td>Time Exceeded<br />超时</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>Parameter Problem<br />参数问题</td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>13</td>
<td>Timestamp Request<br />时间戳请求</td>
<td></td>
<td>✅</td>
</tr>
<tr>
<td>14</td>
<td>Timestamp Reply<br />时间戳响应</td>
<td></td>
<td>✅</td>
</tr>
</tbody></table>
<p><strong>ping</strong></p>
<p>ping是ICMP最著名的一个应用，可以测试 <strong>网络的可达性</strong></p>
<img src="https://static001.geekbang.org/resource/image/57/21/57a77fb89bc4a5653842276c70c0d621.jpg" alt="img" style="zoom:15%;" />

<p><strong>tracert</strong></p>
<p>ping 工具只能测试目的设备的连通性，但是看不到数据包的传输路径</p>
<p>tracert 工具可以查看数据包的<strong>整条传输路径</strong>，包括途中经过的<strong>中间设备</strong></p>
<p>IP 头部的 <strong>TTL</strong> 字段是为避免数据包循环转发而设计的。每经过一个路由器，数据包头中的 TTL 值减 1 。如果 TTL 值为 0 则丢弃报文，并向源设备回应一个 Time Exceeded 消息，告知错误类型。</p>
<p>使用 tracert 命令时，源设备的 tracert <strong>逐跳发送数据包</strong>，并等待每一个响应报文。发送第一个数据包时，TTL 值设为 1 。第一个路由器收到数据包后 TTL 值减 1 ，随即丢弃数据包，并返回一个 <em>Time Exceeded</em> 消息。</p>
<p>怎么知道 UDP 有没有到达目的主机呢？Traceroute 程序会发送一份 UDP 数据报给目的主机，但它会选择一个不可能的值作为 UDP 端口号（大于 30000）。当该数据报到达时，将使目的主机的 UDP 模块产生一份“端口不可达”错误 ICMP 报文。如果数据报没有到达，则可能是超时。</p>
<h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p><strong>一台机器访问另一个ip地址</strong></p>
<ol>
<li>先判断 目标IP和当前机器的IP地址，是不是一个网段的。</li>
<li>如果是一个网段的，那就使用ARP协议获取目标IP的MAC地址。没网关什么事情。</li>
<li>如果不是同一网段的，那请求就要发往默认网关（通过ARP协议获取网关MAC地址）。</li>
</ol>
<p><strong>IP 头和 MAC 头哪些变、哪些不变？</strong></p>
<p>静态路由： IP不变，MAC地址变。</p>
<p>NAT（Network Address Translation）路由：IP变，MAC地址变。</p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><h4 id="UDP包头"><a href="#UDP包头" class="headerlink" title="UDP包头"></a>UDP包头</h4><img src="https://static001.geekbang.org/resource/image/2c/84/2c9a109f3be308dea901004a5a3b4c84.jpg" alt="img" style="zoom:20%;" />

<h4 id="UDP和TCP的区别"><a href="#UDP和TCP的区别" class="headerlink" title="UDP和TCP的区别"></a>UDP和TCP的区别</h4><h5 id="面向连接"><a href="#面向连接" class="headerlink" title="面向连接"></a>面向连接</h5><p>什么是连接？<strong>连接其实就是 客户端和服务端建立一个数据结构来维护双方交互状态。</strong></p>
<ul>
<li>TCP是面向连接的</li>
<li>UDP是面向无连接的</li>
</ul>
<h5 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h5><p>IP包是没有任何可靠性保证的，一旦发出去，不管是超时了还是丢了，都随它而去</p>
<ul>
<li>TCP提供可靠交付，通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达</li>
<li>UDP 继承了 IP 包的特性，不保证不丢失，不保证按顺序到达</li>
</ul>
<h5 id="面向字节流"><a href="#面向字节流" class="headerlink" title="面向字节流"></a>面向字节流</h5><p>IP包不是流，而是一个个的IP包。</p>
<ul>
<li>TCP是面向字节流的，发送的是一个流，没头没尾</li>
<li>UDP发送是基于数据包的，一个个的发，一个个的收</li>
<li><font color ="red"> 所以TCP会发生粘包和拆包，而UDP不会</font></li>
</ul>
<p>ps:  粘包和拆包是一个通俗的说法，在知乎上会被很多大佬喷成是伪命题、伪科学。这里我们知道原理就行了。</p>
<h5 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h5><ul>
<li>TCP意识到包丢弃了或者网络环境不好了的时候，会根据情况调整自己的行为，看看是不是发快了，要不要发慢点</li>
<li>UDP则不会</li>
</ul>
<blockquote>
<p>如果 MAC 层定义了本地局域网的传输行为，IP 层定义了整个网络端到端的传输行为，这两层基本定义了这样的基因：网络传输是以包为单位的，<strong>二层叫帧</strong>，<strong>网络层叫包</strong>，<strong>传输层叫段</strong>。我们笼统地称为包。包单独传输，自行选路，在不同的设备封装解封装，不保证到达。基于这个基因，生下来的孩子 UDP 完全继承了这些特性，几乎没有自己的思想。</p>
</blockquote>
<h4 id="UDP的特点"><a href="#UDP的特点" class="headerlink" title="UDP的特点"></a>UDP的特点</h4><ul>
<li><strong>沟通简单</strong>：UDP的包头比起TCP来说相当简单</li>
<li><strong>轻信他人</strong>：UDP不需要建立连接，谁都可以给它发送数据，它也可以传给任何人数据</li>
<li><strong>愣头青</strong>：不会根据网络的情况进行发包的拥塞控制，无论网络丢包丢成啥样了，它该怎么发还怎么发。</li>
</ul>
<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><h4 id="TCP包头"><a href="#TCP包头" class="headerlink" title="TCP包头"></a>TCP包头</h4><img src="https://static001.geekbang.org/resource/image/64/bf/642947c94d6682a042ad981bfba39fbf.jpg" alt="img" style="zoom:20%;" />



<h4 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h4><p>tcp是面向连接的，双方都需要维护一个状态机，三次握手状态变化时序图：</p>
<img src="https://static001.geekbang.org/resource/image/c0/08/c067fe62f49e8152368c7be9d91adc08.jpg" alt="img" style="zoom:25%;" />

<ol>
<li>一开始，客户端和服务端都处于 CLOSED 状态</li>
<li>服务端主动监听某个端口，处于 LISTEN 状态</li>
<li>客户端发起连接发送 SYN，之后客户端处于 SYN_SENT 状态</li>
<li>服务端收到 SYN包后，应答发送 SYN + ACK 包，之后服务端处于 SYN_REVD状态</li>
<li>客户端收到 SYN + ACK 后应答发送 ACK 包， 客户端处于 ESTABLISHED 状态，因为客户端已经完成了一次发送一次接收</li>
<li>服务端收到 ACK后，也处于 ESTABLISHED 状态，它也完成了一次发送，一次接收</li>
</ol>
<h4 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h4><img src="https://static001.geekbang.org/resource/image/bf/13/bf1254f85d527c77cc4088a35ac11d13.jpg" alt="img" style="zoom:25%;" />

<ol>
<li>一开始，客户端和服务端都处于 ESTABLISHED 状态</li>
<li>客户端：我不玩了。发送 FIN 包并进入 FIN_WAIT_1 状态</li>
<li>服务端：我知道你不玩了。发送 ACK 包，进入等待关闭 CLOSED_WAIT 状态</li>
<li>客户端：我知道了。收到 ACK 包，进入 FIN_WAIT_2 状态<ul>
<li>如果服务端在这个时候跑路了，客户端将永远处于这个状态</li>
</ul>
</li>
<li>服务端：我这边处理完了，我也不玩了。 发送 FIN+ACK 包，进入 LAST_ACK 状态</li>
<li>客户端：我知道你不玩了。发送 ACK 包，进入 TIME_WAIT 状态<ul>
<li>这里的 TIME_WAIT 时间要足够长，长到如果服务端没有收到这次的 ACK 包的话，会重复第五步，重发 FIN+ACK 包</li>
<li>等待的时间设为 2MSL，MSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃</li>
</ul>
</li>
<li>服务端收到客户端最后一个 ACK 包后，进入 CLOSED 状态</li>
<li>客户端在 TIME_WAIT 时间过了之后，进入CLOSED 状态</li>
</ol>
<h4 id="TCP状态机"><a href="#TCP状态机" class="headerlink" title="TCP状态机"></a>TCP状态机</h4><p>将连接建立和连接断开的两个时序状态图综合起来，就是这个著名的 TCP 的状态机。</p>
<img src="https://static001.geekbang.org/resource/image/fd/2a/fd45f9ad6ed575ea6bfdaafeb3bfb62a.jpg" alt="img" style="zoom:15%;" />

<blockquote>
<p>在这个图中，加黑加粗的部分，是上面说到的主要流程，其中阿拉伯数字的序号，是连接过程中的顺序，而大写中文数字的序号，是连接断开过程中的顺序。加粗的实线是客户端 A 的状态变迁，加粗的虚线是服务端 B 的状态变迁。</p>
</blockquote>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>TCP 包头很复杂，但是主要关注五个问题，顺序问题，丢包问题，连接维护，流量控制，拥塞控制。</p>
<p>连接的建立是经过三次握手，断开的时候四次挥手</p>
<p><strong>TCP 的连接有这么多的状态，如何在系统中查看某个连接的状态吗？</strong></p>
<p>linux中可以使用 netstat 命令</p>
<h3 id="套接字Socket"><a href="#套接字Socket" class="headerlink" title="套接字Socket"></a>套接字Socket</h3><h4 id="基于TCP"><a href="#基于TCP" class="headerlink" title="基于TCP"></a>基于TCP</h4><p>在内核中，为每个 Socket 维护两个队列。一个是已经建立了连接的队列，这时候连接三次握手已经完毕，处于 established 状态；一个是还没有完全建立连接的队列，这个时候三次握手还没完成，处于 syn_rcvd 的状态。</p>
<p>工作过程：</p>
<ul>
<li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li>
<li>服务端调用 <code>bind</code>，将绑定在 IP 地址和端口;</li>
<li>服务端调用 <code>listen</code>，进行监听；</li>
<li>服务端调用 <code>accept</code>，等待客户端连接；</li>
<li>客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求；</li>
<li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li>
<li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li>
<li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li>
</ul>
<p>这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p>
<p>所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p>
<p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p>
<h4 id="基于UDP"><a href="#基于UDP" class="headerlink" title="基于UDP"></a>基于UDP</h4><p>对于 UDP 来讲，过程有些不一样。UDP 是没有连接的，所以不需要三次握手，也就不需要调用 listen 和 connect。</p>
<p>但是，UDP 的交互仍然需要 IP 和端口号，因而也需要 bind。UDP 是没有维护连接状态的，因而不需要每对连接建立一组 Socket，而是只要有一个 Socket，就能够和多个客户端通信。</p>
<p>也正是因为没有连接状态，每次通信的时候，都调用 sendto 和 recvfrom，都可以传入 IP 地址和端口。</p>
<img src="https://static001.geekbang.org/resource/image/6b/31/6bbe12c264f5e76a81523eb8787f3931.jpg" alt="img" style="zoom:25%;" />

<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><h4 id="http请求格式"><a href="#http请求格式" class="headerlink" title="http请求格式"></a>http请求格式</h4><img src="https://static001.geekbang.org/resource/image/85/c1/85ebb0396cbaa45ce00b505229e523c1.jpeg?" alt="img" style="zoom:25%;" />



<h4 id="http请求过程"><a href="#http请求过程" class="headerlink" title="http请求过程"></a>http请求过程</h4><ol>
<li>DNS解析：域名解析为IP地址。</li>
<li>http 是基于 tcp协议的，请求前需要先通过三次握手建立连接，如果开启了 keep-alive，该连接就可以多次复用。<ul>
<li>http1.1 是默认开启 keep-alive的</li>
<li>keep-alive 也有超时时间，超时关闭之后，后面需要的http请求需要重新建立连接</li>
</ul>
</li>
<li>tcp层，拼接源和目标端口。</li>
<li>ip层，拼接源和目标IP地址。<ul>
<li>如果网段相同，通过arp协议获取mac地址，直接发送</li>
<li>否则通过arp协议获取网关mac地址，发送给网关</li>
</ul>
</li>
<li>mac层，拼接mac地址。</li>
</ol>
<p>tcp报文段：</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/49777632-5e7b1dea989c0_fix732.png" style="zoom:55%;" />

<h4 id="http响应格式"><a href="#http响应格式" class="headerlink" title="http响应格式"></a>http响应格式</h4><img src="https://static001.geekbang.org/resource/image/6b/63/6bc37ddcb4e7a61ca3275790820f2263.jpeg" alt="img" style="zoom:25%;" />

<h3 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h3><ul>
<li>对称加密：加密和解密用的密钥相同。优点是效率高、性能好。</li>
<li>非对称加密：加密和解密的密钥不同，一般是一个公钥一个私钥。效率比较低。</li>
<li>CA（ Certificate Authority）：一个权威的颁发证书的机构，证书里有公钥等信息。最高级的ca机构成为 root CA。</li>
</ul>
<h4 id="https协议握手过程："><a href="#https协议握手过程：" class="headerlink" title="https协议握手过程："></a>https协议握手过程：</h4><p>这里老师讲的感觉有点不太清晰，推荐这篇文章：<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a></p>
<ul>
<li>客户端-&gt;服务端：给出协议版本号、一个客户端生成的随机数（Client random）、以及客户端支持的加密方法。</li>
<li>服务端-&gt;客户端：服务端选取确认双方使用的加密方法、给出数字证书、以及一个服务端生成的随机数（Server random）。</li>
<li>客户端-&gt;服务端：客户端验证数字证书是否有效，生成一个随机数（Premaster secret），并使用约定的加密方法和公钥加密这个随机数。</li>
<li>服务端：使用自己的私钥，解密获取上一步客户端发过来的随机数（Premaster secret）。</li>
<li>之后，双方使用约定的加密方法和前面的三个随机数，生成<strong>“对话密钥”</strong>（session key），用来<strong>对称加密</strong>接下来的对话。</li>
</ul>
<h2 id="陌生的数据中心"><a href="#陌生的数据中心" class="headerlink" title="陌生的数据中心"></a>陌生的数据中心</h2><h3 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h3><h4 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h4><img src="https://static001.geekbang.org/resource/image/89/4d/890ff98fde625c6a60fb71yy22d8184d.jpg" alt="img" style="zoom:25%;" />

<h4 id="DNS解析流程"><a href="#DNS解析流程" class="headerlink" title="DNS解析流程"></a>DNS解析流程</h4><ol>
<li>电脑客户端会发出一个 DNS 请求，问 <a href="http://www.163.com/">www.163.com</a> 的 IP 是啥啊，并发给本地域名服务器 (本地 DNS)。那本地域名服务器 (本地 DNS) 是什么呢？如果是通过 DHCP 配置，本地 DNS 由你的网络服务商（ISP），如电信、移动等自动分配，它通常就在你网络服务商的某个机房。</li>
<li>本地 DNS 收到来自客户端的请求。你可以想象这台服务器上缓存了一张域名与之对应 IP 地址的大表格。如果能找到 <a href="http://www.163.com,它就直接返回/">www.163.com，它就直接返回</a> IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大，能告诉我 <a href="http://www.163.com/">www.163.com</a> 的 IP 地址吗？”根域名服务器是最高层次的，全球共有 13 套。它不直接用于域名解析，但能指明一条道路。</li>
<li>根 DNS 收到来自本地 DNS 的请求，发现后缀是 .com，说：“哦，<a href="http://www.163.com/">www.163.com</a> 啊，这个域名是由.com 区域管理，我给你它的顶级域名服务器的地址，你去问问它吧。”</li>
<li>本地 DNS 转向问顶级域名服务器：“老二，你能告诉我 <a href="http://www.163.com/">www.163.com</a> 的 IP 地址吗？”顶级域名服务器就是大名鼎鼎的比如 .com、.net、 .org 这些一级域名，它负责管理二级域名，比如 163.com，所以它能提供一条更清晰的方向。</li>
<li>顶级域名服务器说：“我给你负责 <a href="http://www.163.com/">www.163.com</a> 区域的权威 DNS 服务器的地址，你去问它应该能问到。”</li>
<li>本地 DNS 转向问权威 DNS 服务器：“您好，<a href="http://www.163.com/">www.163.com</a> 对应的 IP 是啥呀？”163.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li>
<li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li>
<li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li>
</ol>
<img src="https://static001.geekbang.org/resource/image/71/e8/718e3a1a1a7927302b6a0f836409e8e8.jpg" alt="img" style="zoom:25%;" />

<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>某个应用要访问另外一个应用，如果配置另外一个应用的 IP 地址，那么这个访问就是一对一的。但是当被访问的应用撑不住的时候，我们其实可以部署多个。但是，访问它的应用，如何在多个之间进行负载均衡？只要配置成为域名就可以了。在域名解析的时候，我们只要配置策略，这次返回第一个 IP，下次返回第二个 IP，就可以实现负载均衡了。</p>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><h4 id="CDN分发系统架构"><a href="#CDN分发系统架构" class="headerlink" title="CDN分发系统架构"></a>CDN分发系统架构</h4><p>CDN 系统的缓存，也是一层一层的，能不访问后端真正的源，就不打扰它。这也是电商网站物流系统的思路，北京局找不到，找华北局，华北局找不到，再找北方局。</p>
<img src="https://static001.geekbang.org/resource/image/5f/25/5fbe602d9b85966d9a1748d2e6aa6425.jpeg" alt="img" style="zoom:25%;" />


]]></content>
      <categories>
        <category>计算机网络与操作系统</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>go程序设计语言-slice课后练习</title>
    <url>/2021/05/17/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8Fslice%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p>本来想写一片关于 slice 切片的文章，但是又复习了一下《go程序设计语言》，并且网上类似的东西数不胜数。。</p>
<p>于是想着把课后练习题做了吧，(ps：当时看第一遍的时候不太明白所以没做)。</p>
<p>本文代码可以直接在 playground 中运行。</p>
<span id="more"></span>

<h2 id="练习-4-3"><a href="#练习-4-3" class="headerlink" title="练习 4.3:"></a>练习 4.3:</h2><blockquote>
<p>重写reverse函数，使用数组指针代替slice。</p>
</blockquote>
<br>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums:=[<span class="number">10</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;</span><br><span class="line">	Reverse(&amp;nums)</span><br><span class="line">	fmt.Println(nums) <span class="comment">// [10 9 8 7 6 5 4 3 2 1]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(nums *[10]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>; i &lt; j; i,j = i+<span class="number">1</span>,j<span class="number">-1</span> &#123;</span><br><span class="line">		nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tips: 在 golang 中，建立了 <code>arrPtr := &amp;arr</code> 这种类似地址关系后，* 允许不写。</p>
<p>所以等同于：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums:=[<span class="number">10</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;</span><br><span class="line">	Reverse(&amp;nums)</span><br><span class="line">	fmt.Println(nums) <span class="comment">// [10 9 8 7 6 5 4 3 2 1]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(numPtr *[10]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(*numPtr)<span class="number">-1</span>; i &lt; j; i,j = i+<span class="number">1</span>,j<span class="number">-1</span> &#123;</span><br><span class="line">		(*numPtr)[i], (*numPtr)[j] = (*numPtr)[j], (*numPtr)[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要用 () 吧 *numPtr 括起来呢。</p>
<p>因为在 <strong>Golang</strong> 中 * 寻址运算符和 [] 中括号运算符的优先级是不同的！</p>
<ul>
<li>[] 中括号是<strong>初等运算符</strong></li>
<li>寻址运算符是<strong>单目运算符</strong></li>
</ul>
<p>初等运算符的优先级是大于单目运算符的，因此先参与计算的是 arrPtr[0]，arrPtr[0] 其实就是数组的第一个元素，就是数字 1。<br>数字 1 必然是 int 类型，而不是一个地址，因此针对数字 1 使用 * 寻址运算符自然也就发生了错误。</p>
<h2 id="练习-4-4"><a href="#练习-4-4" class="headerlink" title="练习 4.4:"></a>练习 4.4:</h2><blockquote>
<p>编写一个rotate函数，通过一次循环完成镟转。</p>
</blockquote>
<br>

<p>说让通过一次循环翻转，没说要原地翻转。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;</span><br><span class="line">	fmt.Println(Rotate(nums, <span class="number">2</span>)) <span class="comment">// [3 4 5 6 7 8 9 10 1 2]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Rotate</span><span class="params">(nums []<span class="type">int</span>, r <span class="type">int</span>)</span></span> []<span class="type">int</span>&#123;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">  <span class="comment">// 声明一个切片,用于存储旋转后的结果</span></span><br><span class="line">	ans := <span class="built_in">make</span>([]<span class="type">int</span>, n, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		index := i+r</span><br><span class="line">		<span class="keyword">if</span> index &gt;= n &#123;</span><br><span class="line">			index = index - n</span><br><span class="line">		&#125;</span><br><span class="line">		ans[i] = nums[index] <span class="comment">// 这个是向左旋转</span></span><br><span class="line">		<span class="comment">// ans[index] = nums[i] // 这个是向右旋转</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="练习-4-5"><a href="#练习-4-5" class="headerlink" title="练习 4.5:"></a>练习 4.5:</h2><blockquote>
<p>写一个函数在原地完成消除[]string中相邻重复的字符串的操作。</p>
</blockquote>
<br>

<p>关键是原地，不开辟额外空间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	strs := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">	fmt.Println(Clear(strs)) <span class="comment">// [a b c]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Clear</span><span class="params">(strs []<span class="type">string</span>)</span></span> []<span class="type">string</span>&#123;</span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="number">1</span>; j &lt; <span class="built_in">len</span>(strs)<span class="number">-1</span>; i, j = i+<span class="number">1</span> ,j+<span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> strs[i] == strs[j] &#123;</span><br><span class="line">			<span class="built_in">copy</span>(strs[j:],strs[j+<span class="number">1</span>:])</span><br><span class="line">			strs = strs[:<span class="built_in">len</span>(strs)<span class="number">-1</span>]</span><br><span class="line">			i--</span><br><span class="line">			j--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> strs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="练习-4-6"><a href="#练习-4-6" class="headerlink" title="练习 4.6:"></a>练习 4.6:</h2><blockquote>
<p>编写一个函数，原地将一个UTF-8编码的[]byte类型的slice中相邻的空格(参考 unicode.IsSpace)替换成一个空格返回</p>
</blockquote>
<br>

<p>空格的 unicode 码是 32。 </p>
<p>和上一题没有区别。只是多了一个 unicode.IsSpace() 的判断。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unicode&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	strs := []<span class="type">byte</span>&#123;<span class="number">228</span>, <span class="number">184</span>, <span class="number">173</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">33</span>, <span class="number">229</span>, <span class="number">155</span>, <span class="number">189</span> &#125; <span class="comment">// 中&lt;空格&gt;&lt;空格&gt;!!国</span></span><br><span class="line">	fmt.Println(<span class="type">string</span>(clear(strs)))                                                    <span class="comment">// 中&lt;空格&gt;!!国</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clear</span><span class="params">(strList []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="number">1</span>; i &lt; <span class="built_in">len</span>(strList)<span class="number">-1</span>; i, j = i+<span class="number">1</span>, j+<span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> strList[i] == strList[j] &amp;&amp; unicode.IsSpace(<span class="type">rune</span>(strList[i])) &#123;</span><br><span class="line">			<span class="built_in">copy</span>(strList[j:], strList[j+<span class="number">1</span>:])</span><br><span class="line">			strList = strList[:<span class="built_in">len</span>(strList)<span class="number">-1</span>]</span><br><span class="line">			i--</span><br><span class="line">			j--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> strList</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="练习-4-7"><a href="#练习-4-7" class="headerlink" title="练习 4.7:"></a>练习 4.7:</h2><blockquote>
<p>修改reverse函数用于原地反转UTF-8编码的[]byte。是否可以不用分配额外的内存?</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	strs := <span class="string">&quot;asadqweq&quot;</span></span><br><span class="line">	fmt.Println(<span class="type">string</span>(reverse([]<span class="type">byte</span>(strs))))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(strs []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(strs)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">		strs[i], strs[j] = strs[j], strs[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> strs</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>2022年2月3日17:59:16：</p>
<p>可以在这里查看 The Go Programming Language 其它的课后习题答案代码：</p>
<p><a href="https://github.com/ruomuc/go-programming-language">https://github.com/ruomuc/go-programming-language</a></p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>golang的gc</title>
    <url>/2021/05/15/golang%E7%9A%84gc/</url>
    <content><![CDATA[<p>和node.js一样，go语言也是有 GC 的，但是 GC 的方式和 node.js 有很大的区别。</p>
<p>本片文章主要对照着 node.js ，分析一下 go 的 GC 机制。</p>
<span id="more"></span>
<h2 id="常见的gc算法"><a href="#常见的gc算法" class="headerlink" title="常见的gc算法"></a>常见的gc算法</h2><p>这里整理一下常见的几种垃圾回收算法，为后文做一下铺垫。。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>引用计数 （Reference counting）会为每个对象维护一个计数器，当该对象被其他对象引用时加一，引用失效时减一，当引用次数归零后即可回收对象。</p>
<p>主要使用语言：</p>
<p>python、php、objective-C 和 C++ 标准库中的<code>std::shared_ptr</code>等。</p>
<p>优点：</p>
<ul>
<li>原理和实现都比较简单</li>
<li>回收的即时性：当对象的引用计数为<code>0</code>时立即回收，不像其他<code>GC</code>机制需要等待特定时机再回收，提高了内存的利用率</li>
<li>不需要暂停应用即可完成回收</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法解决循环引用的回收问题：当<code>ObjA</code>引用了<code>ObjB</code>，<code>ObjB</code>也引用<code>ObjA</code>时，这两个对象的引用次数使用大于<code>0</code>，从而占用的内存无法被回收。</li>
<li>时间和空间成本较高：一方面是因为每个对象需要额外的空间存储引用计数器变量，另一方面是在栈上的赋值时修改引用次数时间成本较高</li>
<li>引用计数是一种摊销算法，会将内存的回收分摊到整个程序的运行过程，但是当销毁一个很大的树形结构时无法保证响应时间</li>
</ul>
<h3 id="标记-清除-算法"><a href="#标记-清除-算法" class="headerlink" title="标记-清除 算法"></a>标记-清除 算法</h3><p>标记-清除<code>Mark-Sweep</code>算法是最基础的追踪式算法，分为“标记”和“清除”两个步骤：</p>
<ul>
<li>标记：记录需要回收的垃圾对象</li>
<li>清除：在标记完成后回收垃圾对象的内存空间</li>
</ul>
<p>优点：</p>
<ul>
<li>算法吞吐量较高，即运行用户代码时间 / （运行用户代码时间 + 运行垃圾收集时间）较高</li>
<li>空间利用率高：同标记-复制相比不需要额外空间复制对象，也不需要像引用计数算法为每个对象设置引用计数器</li>
</ul>
<p>缺点：</p>
<ul>
<li>清除后会产生大量的内存碎片空间，导致程序在运行时可能没法为较大的对象分配内存空间，导致提前进行下一次垃圾回收</li>
</ul>
<h3 id="标记-复制-算法"><a href="#标记-复制-算法" class="headerlink" title="标记-复制 算法"></a>标记-复制 算法</h3><p>标记-复制<code>Mark-Copy</code>算法将内存分成大小相同的两块，当某一块的内存使用完了之后就将使用中的对象挨个复制到另一块内存中，最后将当前内存恢复未使用的状态。</p>
<p>优点：</p>
<ul>
<li>标记-清除法需要在清除阶段对大量垃圾对象进行扫描，标记-复制则只需要从<code>GC Root</code>对象出发，将“可到达”的对象复制到另一块内存后直接清理当前这块的内存，因此提升了垃圾回收的效率</li>
<li>解决了内存碎片化的问题，防止分配较大连续空间时的提前<code>GC</code>问题</li>
</ul>
<p>缺点：</p>
<ul>
<li>同标记-清除法相比，在“可达”对象占比较高的情况下有复制对象的开销</li>
<li>内存利用率较低，相当于可利用的内存仅有一半</li>
</ul>
<h3 id="标记-整理-算法"><a href="#标记-整理-算法" class="headerlink" title="标记-整理 算法"></a>标记-整理 算法</h3><p>标记-整理<code>Mark-Compact</code>算法综合了标记-清除法和标记-复制法的优势，既不会产生内存碎片化的问题，也不会有一半内存空间浪费的问题。</p>
<p>该方法首先标记出所有“可达”的对象，然后将存活的对象移动到内存空间的一端，最后清理掉端边界以外的内存。</p>
<p>优点：</p>
<ul>
<li>避免了内存碎片化的问题</li>
<li>在对象存活率较高的情况下，标记-整理算法由于不需要复制对象效率更高，因此更加适合老生代算法</li>
</ul>
<p>缺点：</p>
<ul>
<li>整理过程较为复杂，需要多次遍历内存导致<code>STW</code>时间比标记-清除算法更长</li>
</ul>
<h3 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h3><p>前面提到的“标记”类算法都有一个共同的瑕疵，即在进行垃圾回收的时候会暂停整个程序（<code>STW</code>问题）。</p>
<p>三色标记法是对“标记”阶段的改进，在不暂停程序的情况下即可完成对象的可达性分析。</p>
<p>三色标记法将对象分为三类：</p>
<ul>
<li>白色：未搜索的对象，在回收周期开始时所有对象都是白色，在回收周期结束时所有的白色都是垃圾对象</li>
<li>灰色：正在搜索的对象，但是对象身上还有一个或多个引用没有扫描</li>
<li>黑色：已搜索完的对象，所有的引用已经被扫描完</li>
</ul>
<p>具体的实现如下：</p>
<ul>
<li>初始时所有对象都是白色对象</li>
<li>从<code>GC Root</code>对象出发，扫描所有可达对象并标记为灰色，放入待处理队列</li>
<li>从队列取出一个灰色对象并标记为黑色，将其引用对象标记为灰色放入队列</li>
<li>重复上一步骤，直到灰色对象队列为空</li>
<li>此时所有剩下的白色对象就是垃圾对象</li>
</ul>
<p>优点：</p>
<ul>
<li>不需要暂停整个程序进行垃圾回收</li>
</ul>
<p>缺点：</p>
<ul>
<li>如果程序垃圾对象的产生速度大于垃圾对象的回收速度时，可能导致程序中的垃圾对象越来越多而无法及时收集</li>
<li>线程切换和上下文转换的消耗会使得垃圾回收的总体成本上升，从而降低系统吞吐量</li>
</ul>
<h2 id="node-js和go-GC的区别"><a href="#node-js和go-GC的区别" class="headerlink" title="node.js和go GC的区别"></a>node.js和go GC的区别</h2><h3 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h3><p>以前整理过node.js的垃圾回收机制：<a href="https://www.seeln.com/2018/07/31/V8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6/#2-Scavenge%E7%AE%97%E6%B3%95-%E6%96%B0%E7%94%9F%E4%BB%A3%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86%E7%AE%97%E6%B3%95">原文</a></p>
<p>node.js 用的是<strong>分代收集算法</strong>，实质是对上述算法的混用：</p>
<ul>
<li>分代：将堆分为新生代和老生代。</li>
<li>新生代：使用 标记-复制 算法</li>
<li>老生代：<ul>
<li>使用 标记-清除 算法进行回收</li>
<li>结合使用 标记-整理 算法，处理内存碎片，防止大对象无法分配，频繁触发GC</li>
</ul>
</li>
</ul>
<h3 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h3><p>golang 没有使用分代算法，也没有 mark-compact 去整理内存碎片。</p>
<p>golang GC 的发展史：</p>
<ul>
<li><code>go v1.1</code>：标记-清除法，整个过程都需要<code>STW</code></li>
<li><code>go v1.3</code>：标记-清除法，标记过程仍然需要<code>STW</code>但清除过程并行化，<code>gc pause</code>约几百<code>ms</code></li>
<li><code>go v1.5</code>：引入插入写屏障技术的三色标记法，仅在堆空间启动插入写屏障，全部扫描后需要<code>STW</code>重新扫描栈空间，<code>gc pause</code>耗时降到<code>10ms</code>以下</li>
<li><code>go v1.8</code>：引入混合写屏障技术的三色标记法，仅在堆空间启动混合写屏障，不需要在<code>GC</code>结束后对栈空间重新扫描，<code>gc pause</code>时间降低至<code>0.5ms</code>以下</li>
<li><code>go v1.14</code>：引入新的页分配器用于优化内存分配的速度</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>比起 node.js 的 GC，golang的 GC 显得更加简单粗暴。</p>
<p>相同点：</p>
<ul>
<li>node.js 和 golang 都使用三色标记法优化 ”标记“阶段</li>
<li>都引入了 <strong>读写屏障技术</strong> 来解决 三色标记法的并发性问题</li>
</ul>
<p>不同点：</p>
<ul>
<li>node.js 采用的是 分代收集算法，而 golang 没有分代</li>
<li>node.js 采用 标记-整理算法 来处理内存碎片，而 golang 没有处理</li>
</ul>
<p>写在最后： 关于读写屏障技术，看了下没有很懂，只是知道了它的目的。所以就没有详细说明，可以去参考链接里面看原文。</p>
<p>参考链接：</p>
<p><a href="https://zhuanlan.zhihu.com/p/245214547">https://zhuanlan.zhihu.com/p/245214547</a></p>
<p><a href="https://studygolang.com/articles/29930">https://studygolang.com/articles/29930</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/297177002">https://zhuanlan.zhihu.com/p/297177002</a></p>
<p><a href="https://v8.js.cn/blog/concurrent-marking/">https://v8.js.cn/blog/concurrent-marking/</a></p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>gc</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go中的rune类型</title>
    <url>/2021/05/01/go%E4%B8%AD%E7%9A%84rune%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>在 java 等语言中，有char类型，而在go语言中，使用的是 rune 类型。</p>
<p>char 类型在 java中是16位的，因为用的是unicode编码。</p>
<p>而 rune 类型在 go中是32位的，因为go用的是utf-8编码。</p>
<p>可以在这个网站查看码点：<a href="https://utf8-chartable.de/unicode-utf8-table.pl?start=19840&names=-&utf8=dec">UTF-8 encoding table and Unicode characters</a></p>
<span id="more"></span>
<h2 id="什么是rune"><a href="#什么是rune" class="headerlink" title="什么是rune"></a>什么是rune</h2><p>源码中，rune是这样定义的：</p>
<p>rune 是int32的别名，在所有方面都等同于int32</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rune is an alias for int32 and is equivalent to int32 in all ways. It is</span></span><br><span class="line"><span class="comment">// used, by convention, to distinguish character values from integer values.</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">rune</span> = <span class="type">int32</span></span><br></pre></td></tr></table></figure>

<p>我们做个测试：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(<span class="string">&quot;z中国&quot;</span>)) <span class="comment">// 7</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(<span class="string">&quot;zhong&quot;</span>)) <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 ”中“ 和 ”国“ 两个字的unicode码 ，都在utf-8 的第三个区段 <code>U+ 0800 ~ U+  FFFF</code> ，所以都占三个字节，长度就是 7。</p>
<p>而且由于编码的原因，我们不知道字符串应该按照几个字节处理，如果处理不当，就会出现乱码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> str = <span class="string">&quot;a中国&quot;</span></span><br><span class="line">	fmt.Println(str[:<span class="number">3</span>]) <span class="comment">// a��</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，在 go 语言中，使用 range 来遍历字符串，会自动按照 rune 类型去处理，很方便</p>
<p>或者你可以使用 <code>[]rune(str)</code> 将字符串转为 rune 数组类型，然后使用下标遍历。。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> str = <span class="string">&quot;a中国&quot;</span></span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> str &#123;</span><br><span class="line">		fmt.Println(s)</span><br><span class="line">	&#125;</span><br><span class="line">    fmt.Println([]<span class="type">rune</span>(str))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="number">97</span></span><br><span class="line"><span class="number">20013</span></span><br><span class="line"><span class="number">22269</span></span><br><span class="line">[<span class="number">97</span> <span class="number">20013</span> <span class="number">22269</span>]</span><br></pre></td></tr></table></figure>



<h2 id="rune-和-byte的区别"><a href="#rune-和-byte的区别" class="headerlink" title="[]rune 和 []byte的区别"></a>[]rune 和 []byte的区别</h2><p>看下源码对 byte 的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is</span></span><br><span class="line"><span class="comment">// used, by convention, to distinguish byte values from 8-bit unsigned</span></span><br><span class="line"><span class="comment">// integer values.</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">byte</span> = <span class="type">uint8</span></span><br></pre></td></tr></table></figure>
<p>和 rune 差不多，只不过是 uint8 类型的别名</p>
<p>使用 []byte遍历一下字符串，看看有什么不同：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> str = <span class="string">&quot;a中国&quot;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> []<span class="type">byte</span>(str) &#123;</span><br><span class="line">		fmt.Println(s)</span><br><span class="line">	&#125; </span><br><span class="line">	fmt.Println([]<span class="type">byte</span>(str))</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="number">97</span></span><br><span class="line"><span class="number">228</span></span><br><span class="line"><span class="number">184</span></span><br><span class="line"><span class="number">173</span></span><br><span class="line"><span class="number">229</span></span><br><span class="line"><span class="number">155</span></span><br><span class="line"><span class="number">189</span></span><br><span class="line">[<span class="number">97</span> <span class="number">228</span> <span class="number">184</span> <span class="number">173</span> <span class="number">229</span> <span class="number">155</span> <span class="number">189</span>]</span><br></pre></td></tr></table></figure>

<p>去文章开头放的链接里查一下 “中” 和 “国” 这两个字的码点如下：</p>
<table>
<thead>
<tr>
<th>Unicode<br/>code point (hex)</th>
<th>Unicode<br/>code point (octal)</th>
<th>character</th>
<th>UTF-8<br/>(dec.)</th>
</tr>
</thead>
<tbody><tr>
<td>U+4E2D</td>
<td>20013</td>
<td>中</td>
<td>228 184 173</td>
</tr>
<tr>
<td>U+56FD</td>
<td>22269</td>
<td>国</td>
<td>229 155 189</td>
</tr>
</tbody></table>
<p>这样一看，是不是全部都对上了。。</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>关于event-loop</title>
    <url>/2021/04/19/%E5%85%B3%E4%BA%8Eevent-loop/</url>
    <content><![CDATA[<p>首先，js 不同宿主环境对 event loop 的实现是有区别的，这里说的都是 node.js 中的 event loop</p>
<p>关于 node.js 的 event loop ，之前写过两篇文章，最近回头看的时候，看不下去给删了</p>
<p>其实我的理解主要来源于：</p>
<ul>
<li><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/">node官方文档</a></li>
<li><a href="https://cnodejs.org/topic/5a9108d78d6e16e56bb80882">cnode论坛一位大佬的文章</a></li>
<li>由于cnode论坛挂过一次，并且部署在境外，如果上面的连接访问不了，可以<a href="https://github.com/ruomuc/test_demos/blob/master/blog/%E5%85%B3%E4%BA%8Eevent-loop/%E4%B8%8D%E8%A6%81%E6%B7%B7%E6%B7%86nodejs%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84event%20loop.md">访问我复制的这个</a></li>
</ul>
<p>之前不过是照虎画猫，写的太拉胯了，这里就不在分析和探究原理了。。</p>
<p>这里主要是用代码来验证一下 event loop 的执行顺序，以便回顾知识的时候更加直观。</p>
<p>下面的代码都在<a href="https://github.com/ruomuc/test_demos/tree/master/blog/%E5%85%B3%E4%BA%8Eevent-loop">github仓库</a></p>
<span id="more"></span>

<hr>
<blockquote>
<p>setTimeout 和 setInterval 的执行顺序？</p>
</blockquote>
<p>根据代码输出，可以知道，timers阶段的 setTimeout 和 setInterval 执行顺序是一个 FIFO 的队列。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> time = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout1&#x27;</span>)</span><br><span class="line">&#125;, time)</span><br><span class="line"><span class="keyword">const</span> interval1 = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;interval1&#x27;</span>)</span><br><span class="line">  <span class="built_in">clearInterval</span>(interval1)</span><br><span class="line">&#125;, time)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout2&#x27;</span>)</span><br><span class="line">&#125;, time)</span><br><span class="line"><span class="keyword">const</span> interval2 = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;interval2&#x27;</span>)</span><br><span class="line">  <span class="built_in">clearInterval</span>(interval2)</span><br><span class="line">&#125;, time)</span><br><span class="line"></span><br><span class="line"><span class="comment">// timeout1</span></span><br><span class="line"><span class="comment">// interval1</span></span><br><span class="line"><span class="comment">// timeout2</span></span><br><span class="line"><span class="comment">// interval2</span></span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>setTimeout 和 setImmediate ？</p>
</blockquote>
<p>分析代码和输出：</p>
<ul>
<li>运行多次发现，<code>immediate callback</code> 都在 <code>timeout callback</code> 先后顺序是随机的</li>
<li>node.js里面<code>setTimeout(fn, 0)</code>会被强制改为<code>setTimeout(fn, 1)</code><ul>
<li>When <code>delay</code> is larger than <code>2147483647</code> or less than <code>1</code>, the <code>delay</code> will be set to <code>1</code>. Non-integer delays are truncated to an integer.</li>
<li> <a href="https://nodejs.org/api/timers.html#timers_settimeout_callback_delay_args">官方文档说明</a></li>
</ul>
</li>
<li>所以说它们的执行顺序，取决于同步代码的耗时，如果执行到timers时，刚好过去1ms，那么就会先输出 <code>timeout callback</code> ，反之</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setImmediate</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;immediate callback&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout callback&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// immediate callback</span></span><br><span class="line"><span class="comment">// timeout callback</span></span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>poll 的 I/O callback 和 check 阶段的 setImmediate</p>
</blockquote>
<p>分析代码和输出：</p>
<p><code>open empty callback</code> 始终第一个输出，<code>open file callback</code> 和 <code>immediate callback</code> 先后顺序会变化</p>
<p>执行顺序取决于 fs.open(…) 的耗时。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;immediate callback&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">fs.<span class="title function_">open</span>(<span class="string">&#x27;&#x27;</span>, <span class="number">1</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;open empty callback&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">open</span>(<span class="string">&#x27;./不要混淆nodejs和浏览器中的event loop&#x27;</span>, <span class="number">1</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;open file callback&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">open empty callback</span><br><span class="line">immediate callback</span><br><span class="line">open file callback</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">open empty callback</span><br><span class="line">open file callback</span><br><span class="line">immediate callback</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>close callbacks 阶段和 check 阶段</p>
</blockquote>
<p>这个执行顺序没什么好说的，和文档描述的一致。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readStream = fs.<span class="title function_">createReadStream</span>(</span><br><span class="line">  __dirname + <span class="string">&#x27;/不要混淆nodejs和浏览器中的event loop.md&#x27;</span></span><br><span class="line">)</span><br><span class="line">readStream.<span class="title function_">close</span>()</span><br><span class="line">readStream.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;close callback&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;immediate callback&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// immediate callback</span></span><br><span class="line"><span class="comment">// close callback</span></span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>process.nextTick()</p>
</blockquote>
<p>上面大佬的文章中从源码层面分析了 process.nextTick() 的执行时机， 即每个阶段结束都会执行。</p>
<p>可以看到输出中，每个 process.nextTick() 都是在该阶段结束立即执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout callback&#x27;</span>)</span><br><span class="line">  process.<span class="title function_">nextTick</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout tick&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;immediate callback&#x27;</span>)</span><br><span class="line">  process.<span class="title function_">nextTick</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;immediate tick&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readStream = fs.<span class="title function_">createReadStream</span>(</span><br><span class="line">  __dirname + <span class="string">&#x27;/不要混淆nodejs和浏览器中的event loop.md&#x27;</span></span><br><span class="line">)</span><br><span class="line">readStream.<span class="title function_">close</span>()</span><br><span class="line">readStream.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;close callback&#x27;</span>)</span><br><span class="line">  process.<span class="title function_">nextTick</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;close callback tick&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">open</span>(<span class="string">&#x27;&#x27;</span>, <span class="number">1</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;open empty callback&#x27;</span>)</span><br><span class="line">  process.<span class="title function_">nextTick</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;open empty tick&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">timeout callback</span><br><span class="line">timeout tick</span><br><span class="line">open empty callback</span><br><span class="line">open empty tick</span><br><span class="line">immediate callback</span><br><span class="line">immediate tick</span><br><span class="line">close callback</span><br><span class="line">close callback tick</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>microtasks 和 process.nextTick()</p>
</blockquote>
<p>分析一下：</p>
<ul>
<li>nextTick 和 microtasks 都是一个 FIFO 的队列</li>
<li>microtasks 会在执行完 nextTick 之后执行</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;microtasks2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;microtasks&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick2&#x27;</span>)</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;microtasks3&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">fs.<span class="title function_">open</span>(<span class="string">&#x27;&#x27;</span>, <span class="number">1</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;====我是分界线====&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nextTick</span><br><span class="line">nextTick2</span><br><span class="line">microtasks</span><br><span class="line">microtasks2</span><br><span class="line">microtasks3</span><br><span class="line">====我是分界线====</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>制造死循环</p>
</blockquote>
<p>下面两段代码都可以制造死循环。。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">nextTick</span> () &#123;</span><br><span class="line">  process.<span class="title function_">nextTick</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">nextTick</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">nextTick</span>()</span><br><span class="line">fs.<span class="title function_">open</span>(<span class="string">&#x27;&#x27;</span>, <span class="number">1</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;====永远都不会轮到我====&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">runMicrotask</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">runMicrotask</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">runMicrotask</span>()</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">open</span>(<span class="string">&#x27;&#x27;</span>, <span class="number">1</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;====永远都不会轮到我====&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>golang的“占位符”整理</title>
    <url>/2021/04/18/golang%E7%9A%84%E5%8D%A0%E4%BD%8D%E7%AC%A6%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>在 golang 中，格式化输出的占位符有很多种。这里整理一下方便用的时候查阅</p>
<span id="more"></span>

<h2 id="通用占位符"><a href="#通用占位符" class="headerlink" title="通用占位符"></a>通用占位符</h2><table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%v</td>
<td>值的默认格式表示</td>
</tr>
<tr>
<td>%+v</td>
<td>类似 %v，但是输出结构体时，会添加字段名（key）</td>
</tr>
<tr>
<td>%#v</td>
<td>值得go语法表示</td>
</tr>
<tr>
<td>%T</td>
<td>打印值得类型</td>
</tr>
<tr>
<td>%%</td>
<td>百分号</td>
</tr>
</tbody></table>
<p>测试代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, <span class="number">123</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">	obj := <span class="keyword">struct</span> &#123;</span><br><span class="line">		name <span class="type">string</span></span><br><span class="line">	&#125;&#123;<span class="string">&quot;测试一下&quot;</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, obj)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, obj)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, obj)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, obj)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d%%\n&quot;</span>,<span class="number">99</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line">hello</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&#123;测试一下&#125;</span><br><span class="line">&#123;name:测试一下&#125;</span><br><span class="line"><span class="keyword">struct</span> &#123; name <span class="type">string</span> &#125;&#123;name:<span class="string">&quot;测试一下&quot;</span>&#125;</span><br><span class="line"><span class="keyword">struct</span> &#123; name <span class="type">string</span> &#125;</span><br><span class="line"><span class="number">99</span>%</span><br></pre></td></tr></table></figure>

<h2 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h2><table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%b</td>
<td>表示为二进制</td>
</tr>
<tr>
<td>%c</td>
<td>该值对应的unicode码</td>
</tr>
<tr>
<td>%d</td>
<td>表示为十进制</td>
</tr>
<tr>
<td>%o</td>
<td>表示为八进制</td>
</tr>
<tr>
<td>%x</td>
<td>表示为十六进制，使用a-f</td>
</tr>
<tr>
<td>%X</td>
<td>表示为十六进制，使用A-F</td>
</tr>
<tr>
<td>%U</td>
<td>表示为Unicode格式：U+xxx</td>
</tr>
<tr>
<td>%q</td>
<td>单引号围绕的字符字面值，由Go语法安全地转义</td>
</tr>
</tbody></table>
<p>测试代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	num := <span class="number">99</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%b\n&quot;</span>,num)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%c\n&quot;</span>,num)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d\n&quot;</span>,num)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%o\n&quot;</span>,num)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%x\n&quot;</span>,num)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%X\n&quot;</span>,num)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%U\n&quot;</span>,num)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%q\n&quot;</span>,num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="number">1100011</span></span><br><span class="line">c</span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="number">143</span></span><br><span class="line"><span class="number">63</span></span><br><span class="line"><span class="number">63</span></span><br><span class="line">U+<span class="number">0063</span></span><br><span class="line"><span class="string">&#x27;c&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="浮点数与复数"><a href="#浮点数与复数" class="headerlink" title="浮点数与复数"></a>浮点数与复数</h2><table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%b</td>
<td>无小数部分的，指数为二的幂的科学计数法，与 strconv.FormatFloat 的 ‘b’ 转换格式一致。例如 -123456p-78</td>
</tr>
<tr>
<td>%e</td>
<td>科学计数法，例如 -1234.456e+78</td>
</tr>
<tr>
<td>%E</td>
<td>科学计数法，例如 -1234.456E+78</td>
</tr>
<tr>
<td>%f</td>
<td>有小数点而无指数，例如 123.456</td>
</tr>
<tr>
<td>%g</td>
<td>根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出</td>
</tr>
<tr>
<td>%G</td>
<td>根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出</td>
</tr>
</tbody></table>
<p>测试代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := <span class="number">3.1415926</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%b\n&quot;</span>, f)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%e\n&quot;</span>, f)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%E\n&quot;</span>, f)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%f\n&quot;</span>, f)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%g\n&quot;</span>, f)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%G\n&quot;</span>, f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="number">7074237631354954</span>p<span class="number">-51</span></span><br><span class="line"><span class="number">3.141593e+00</span></span><br><span class="line"><span class="number">3.141593E+00</span></span><br><span class="line"><span class="number">3.141593</span></span><br><span class="line"><span class="number">3.1415926</span></span><br><span class="line"><span class="number">3.1415926</span></span><br></pre></td></tr></table></figure>
<h3 id="宽度标识符"><a href="#宽度标识符" class="headerlink" title="宽度标识符"></a>宽度标识符</h3><table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%f</td>
<td>和上面的一样（有小数点而无指数，例如 123.456）</td>
</tr>
<tr>
<td>%9f</td>
<td>宽度9，默认精度</td>
</tr>
<tr>
<td>%.2f</td>
<td>默认宽度，精度2</td>
</tr>
<tr>
<td>%9.2f</td>
<td>宽度9，精度2</td>
</tr>
<tr>
<td>%9.f</td>
<td>宽度9，精度0</td>
</tr>
</tbody></table>
<p>这里的默认宽度和默认精度，我猜都是根据科学记数法不要指数部分。</p>
<p>测试代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := <span class="number">3.1415926</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%e\n&quot;</span>, f)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%f\n&quot;</span>, f)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%9f\n&quot;</span>, f)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>, f)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%9.2f\n&quot;</span>, f)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%9.f\n&quot;</span>, f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="number">3.141593e+00</span></span><br><span class="line"><span class="number">3.141593</span></span><br><span class="line"> <span class="number">3.141593</span></span><br><span class="line"><span class="number">3.14</span></span><br><span class="line">     <span class="number">3.14</span></span><br><span class="line">        <span class="number">3</span></span><br></pre></td></tr></table></figure>


<h2 id="字符串与-byte"><a href="#字符串与-byte" class="headerlink" title="字符串与[]byte"></a>字符串与[]byte</h2><table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%s</td>
<td>直接输出字符串或[]byte</td>
</tr>
<tr>
<td>%q</td>
<td>该值对应的双引号括起来的go语法字符串字面值，采用安全转义</td>
</tr>
<tr>
<td>%x</td>
<td>每个字节用两个字符十六进制表示 a-f</td>
</tr>
<tr>
<td>%X</td>
<td>每个字节用两个字符十六进制表示 A-F</td>
</tr>
</tbody></table>
<p>测试代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">&quot;中国&quot;</span></span><br><span class="line">	b := []<span class="type">byte</span>(s)</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s，%s\n&quot;</span>, s, b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%q，%q\n&quot;</span>, s, b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%x，%x\n&quot;</span>, s, b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%X，%X\n&quot;</span>, s, b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line">[<span class="number">228</span> <span class="number">184</span> <span class="number">173</span> <span class="number">229</span> <span class="number">155</span> <span class="number">189</span>]</span><br><span class="line">中国，中国</span><br><span class="line"><span class="string">&quot;中国&quot;</span>，<span class="string">&quot;中国&quot;</span></span><br><span class="line">e4b8ade59bbd，e4b8ade59bbd</span><br><span class="line">E4B8ADE59BBD，E4B8ADE59BBD</span><br></pre></td></tr></table></figure>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%p</td>
<td>十六进制表示，前缀 0x</td>
</tr>
<tr>
<td>%#p</td>
<td>十六进制表示，无前缀 0x</td>
</tr>
</tbody></table>
<p>测试代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">12</span></span><br><span class="line">	ptr := &amp;a</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, ptr)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#p\n&quot;</span>, ptr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="number">0xc00000a0f8</span></span><br><span class="line">c00000a0f8</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。</td>
</tr>
<tr>
<td>-</td>
<td>在右侧而非左侧填充空格（左对齐该区域）</td>
</tr>
<tr>
<td>#</td>
<td>备用格式：为八进制添加前导 0（%#o）</td>
</tr>
<tr>
<td>‘ ‘</td>
<td>(空格)为数值中省略的正负号留出空白（% d）；以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开</td>
</tr>
<tr>
<td>0</td>
<td>填充前导的0而非空格；对于数字，这会将填充移到正负号之后</td>
</tr>
</tbody></table>
<p>这些占位符，是结合上面的去使用的（%+ %#），比较灵活，这里就不一一列举了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%+q\n&quot;</span>, <span class="string">&quot;中国&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%-9.2f\n&quot;</span>, <span class="number">3.1415926</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#o\n&quot;</span>, <span class="number">17</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;% X\n&quot;</span>, <span class="string">&quot;中国&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%09.2f\n&quot;</span>, <span class="number">3.1415926</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="string">&quot;\u4e2d\u56fd&quot;</span></span><br><span class="line"><span class="number">3.14</span>     </span><br><span class="line"><span class="number">021</span></span><br><span class="line">E4 B8 AD E5 <span class="number">9</span>B BD</span><br><span class="line"><span class="number">000003.14</span></span><br></pre></td></tr></table></figure>

<p>最后有个疑问：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+	always print a sign for numeric values;</span><br><span class="line">	guarantee ASCII-only output for %q (%+q)</span><br></pre></td></tr></table></figure>

<p>官方文档是这么描述 + 占位符的。</p>
<p>我打印“中国”，输出的是 ”\u4e2d\u56fd“，为什么官方说的是，保证输出ASCII码呢（guarantee ASCII-only output）？</p>
<p>我理解的ASCII 吗不就是 128 个，扩展了也就 256个。</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>WeekMap和WeekSet</title>
    <url>/2021/04/10/WeekMap%E5%92%8CWeekSet/</url>
    <content><![CDATA[<p>在es6中，不仅引入了 Map 和 Set， 还有 WeekMap和WeekSet，不过我没怎么用过。</p>
<p>首先WeekMap 和 WeekSet 的键只能是对象；其次垃圾回收不会考虑它们对对象的引用，本文主要分析它们对于 gc 的区别。</p>
<p>测试代码地址:<a href="https://github.com/ruomuc/test_demos/tree/master/blog/WeekMap%E5%92%8CWeekSet">https://github.com/ruomuc/test_demos/tree/master/blog/WeekMap%E5%92%8CWeekSet</a></p>
<span id="more"></span>

<p>首先分析一下Map，看这样一段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; printHeap &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./util&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testMap</span> () &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123; [<span class="string">`key_<span class="subst">$&#123;i&#125;</span>`</span>]: i &#125;</span><br><span class="line">    map.<span class="title function_">set</span>(obj, i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printHeap</span>(<span class="string">&#x27;tesMap begin--&#x27;</span>)</span><br><span class="line"><span class="title function_">testMap</span>()</span><br><span class="line"><span class="title function_">printHeap</span>(<span class="string">&#x27;tesMap end--&#x27;</span>)</span><br><span class="line"><span class="variable language_">global</span>.<span class="title function_">gc</span>()</span><br><span class="line"><span class="title function_">printHeap</span>(<span class="string">&#x27;testMap clear--&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>使用<code>node --expose-gc map.js</code> 启动，该参数表示允许我们手动调用 gc，一般只在测试时候使用。。不推荐在生产代码使用。</p>
<p>分析日志：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">=============tesMap begin--===========================</span><br><span class="line">     <span class="attr">rss</span>: 18M</span><br><span class="line">     <span class="attr">heapTotal</span>: 4M</span><br><span class="line">     <span class="attr">heapUsed</span>: 2M</span><br><span class="line">     <span class="attr">external</span>:0M</span><br><span class="line">     <span class="attr">arrayBuffers</span>:0M</span><br><span class="line">=============tesMap end--===========================</span><br><span class="line">     <span class="attr">rss</span>: 351M</span><br><span class="line">     <span class="attr">heapTotal</span>: 327M</span><br><span class="line">     <span class="attr">heapUsed</span>: 298M</span><br><span class="line">     <span class="attr">external</span>:0M</span><br><span class="line">     <span class="attr">arrayBuffers</span>:0M</span><br><span class="line">=============testMap clear--===========================</span><br><span class="line">     <span class="attr">rss</span>: 349M</span><br><span class="line">     <span class="attr">heapTotal</span>: 306M</span><br><span class="line">     <span class="attr">heapUsed</span>: 252M</span><br><span class="line">     <span class="attr">external</span>:0M</span><br><span class="line">     <span class="attr">arrayBuffers</span>:0M</span><br></pre></td></tr></table></figure>

<p>可以看到，尽管 testMap 方法调用完成，其中的 obj 临时对象都失去引用，但是内存并没有降下来。</p>
<p>这是因为 map 中的键对生成的对象引用，gc 无法释放这些对象。</p>
<p>如果我们在调用 gc 前，手动清空 map：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...<span class="comment">//</span></span><br><span class="line"><span class="title function_">printHeap</span>(<span class="string">&#x27;tesMap end--&#x27;</span>)</span><br><span class="line">map.<span class="title function_">clear</span>()</span><br><span class="line"><span class="variable language_">global</span>.<span class="title function_">gc</span>()</span><br><span class="line"><span class="title function_">printHeap</span>(<span class="string">&#x27;testMap clear--&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>日志如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">=============tesMap begin--===========================</span><br><span class="line">     <span class="attr">rss</span>: 18M</span><br><span class="line">     <span class="attr">heapTotal</span>: 4M</span><br><span class="line">     <span class="attr">heapUsed</span>: 2M</span><br><span class="line">     <span class="attr">external</span>:0M</span><br><span class="line">     <span class="attr">arrayBuffers</span>:0M</span><br><span class="line">=============tesMap end--===========================</span><br><span class="line">     <span class="attr">rss</span>: 352M</span><br><span class="line">     <span class="attr">heapTotal</span>: 328M</span><br><span class="line">     <span class="attr">heapUsed</span>: 297M</span><br><span class="line">     <span class="attr">external</span>:0M</span><br><span class="line">     <span class="attr">arrayBuffers</span>:0M</span><br><span class="line">=============testMap clear--===========================</span><br><span class="line">     <span class="attr">rss</span>: 349M</span><br><span class="line">     <span class="attr">heapTotal</span>: 53M</span><br><span class="line">     <span class="attr">heapUsed</span>: 18M</span><br><span class="line">     <span class="attr">external</span>:0M</span><br><span class="line">     <span class="attr">arrayBuffers</span>:0M</span><br></pre></td></tr></table></figure>

<p>可以到，内存被大量释放了。</p>
<hr>
<p>然后我们看一下 WeekMap：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; printHeap &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./util&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> wkMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testWeekMap</span> () &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123; [<span class="string">`key_<span class="subst">$&#123;i&#125;</span>`</span>]: <span class="literal">null</span> &#125;</span><br><span class="line">    wkMap.<span class="title function_">set</span>(obj, i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printHeap</span>(<span class="string">&#x27;tesWeekMap begin--&#x27;</span>)</span><br><span class="line"><span class="title function_">testWeekMap</span>()</span><br><span class="line"><span class="title function_">printHeap</span>(<span class="string">&#x27;tesWeekMap end--&#x27;</span>)</span><br><span class="line"><span class="variable language_">global</span>.<span class="title function_">gc</span>()</span><br><span class="line"><span class="title function_">printHeap</span>(<span class="string">&#x27;tesWeekMap clear--&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>日志如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">=============tesWeekMap begin--===========================</span><br><span class="line">     <span class="attr">rss</span>: 19M</span><br><span class="line">     <span class="attr">heapTotal</span>: 4M</span><br><span class="line">     <span class="attr">heapUsed</span>: 2M</span><br><span class="line">     <span class="attr">external</span>:0M</span><br><span class="line">     <span class="attr">arrayBuffers</span>:0M</span><br><span class="line">=============tesWeekMap end--===========================</span><br><span class="line">     <span class="attr">rss</span>: 106M</span><br><span class="line">     <span class="attr">heapTotal</span>: 83M</span><br><span class="line">     <span class="attr">heapUsed</span>: 64M</span><br><span class="line">     <span class="attr">external</span>:0M</span><br><span class="line">     <span class="attr">arrayBuffers</span>:0M</span><br><span class="line">=============tesWeekMap clear--===========================</span><br><span class="line">     <span class="attr">rss</span>: 102M</span><br><span class="line">     <span class="attr">heapTotal</span>: 46M</span><br><span class="line">     <span class="attr">heapUsed</span>: 10M</span><br><span class="line">     <span class="attr">external</span>:0M</span><br><span class="line">     <span class="attr">arrayBuffers</span>:0M</span><br></pre></td></tr></table></figure>

<p>可以看到，内存确实也下降了，大家可以把 global.gc() 去掉跑一变做个对比。</p>
<p>emm… 但是我有两个问题没搞明白，如果有大佬看到了，并且知道的话，请留言区指教一下。。</p>
<blockquote>
<ol>
<li>同样是 100w个对象，weekMap 内存占用就比较少？</li>
</ol>
</blockquote>
<p>我的猜测是 WeekMap 支持的方法没有 Map多，比如不支持迭代，所以实现比较简洁？</p>
<blockquote>
<ol start="2">
<li>为什么，对象失去引用 并且 gc 了之后， 内存占用没有恢复到一开始的状态？</li>
</ol>
</blockquote>
<p>想了一下，那几个变量应该用不了好几M 的内存，不知道还有些什么东西没释放掉呢。。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>gc</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript强制类型转换</title>
    <url>/2021/04/09/JavaScript%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>类型转换和强制类型转换？</p>
<ul>
<li>类型转换发生在静态类型语言的编译阶段。</li>
<li>强制类型转换发生在动态类型语言的运行时。</li>
</ul>
<p>并且大家所说的隐式和显式，也是取决于不同开发者的认知，在JavaScript中统称为<strong>强制类型转换</strong>。</p>
<span id="more"></span>

<p>举个显式和隐式转换的栗子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">22</span></span><br><span class="line"><span class="keyword">var</span> b = a + <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">var</span> c = +b</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a,a) <span class="comment">// number 22</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> b,b) <span class="comment">// string 22</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> c,c) <span class="comment">// number 22</span></span><br></pre></td></tr></table></figure>

<p>如果说 <code>a+ &#39;&#39;</code>是隐式转换的话，那么 <code>+b</code> 呢？ 事实上在 JavaScript 开源社区，一元操作符  <code>+ </code>被认为是显式强制类型转换，所以显式和隐式取决于开发者的经验。</p>
<h2 id="转为字符串"><a href="#转为字符串" class="headerlink" title="转为字符串"></a>转为字符串</h2><p>字符串的基本转化规则就是加上 <code>&quot;&quot;</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span>+<span class="string">&#x27;&#x27;</span>) <span class="comment">// &quot;null&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span> +<span class="string">&#x27;&#x27;</span>) <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span>+<span class="string">&#x27;&#x27;</span>) <span class="comment">// &quot;true&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">false</span>+<span class="string">&#x27;&#x27;</span>) <span class="comment">// &quot;false&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>,<span class="number">100</span>)+<span class="string">&#x27;&#x27;</span>) <span class="comment">// &quot;1.2676506002282294e+30&quot;</span></span><br></pre></td></tr></table></figure>

<p>对于对象：</p>
<ol>
<li>如果对象没有 valueOf 和 toString 方法，比如Object.create(null) 创建的对象，那么就会报错。</li>
<li>如果对象没有 toString() 方法，或者 toString() 方法返回的值不是一个原始值，那么调用 valueOf() 方法，并将返回值强制类型转换为字符串。</li>
<li>如果对象有 toString() 方法，并且返回值是一个原始值，那么调用 toString() 方法，并将返回值强制类型转换为字符串。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(a)) <span class="comment">// Uncaught TypeError: Cannot convert object to primitive value</span></span><br><span class="line"></span><br><span class="line">a.<span class="property">valueOf</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="number">123</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(a)) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">a.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123; <span class="keyword">return</span> &#123;&#125; &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(a)) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">a.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="number">456</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(a)) <span class="comment">// 456</span></span><br></pre></td></tr></table></figure>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">JSON.stringify</a> 并不是严格意义上的强制类型转换，但是也涉及到了转换为字符串的规则。</p>
<ol>
<li>对于简单值，JSON 字符串化和 toString() 效果基本相同。</li>
<li>对于循环引用的对象会报错。</li>
<li>对于 undefined、function、symbol 会自动忽略，如果在数组中会返回null。</li>
<li>如果对象定义了 toJSON() 方法，会先调用该方法，并使用该方法的返回值进行序列化。</li>
</ol>
<h2 id="转为数字"><a href="#转为数字" class="headerlink" title="转为数字"></a>转为数字</h2><p>基本规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>对于对象：</p>
<ol>
<li>如果对象没有 valueOf 和 toString 方法，比如Object.create(null) 创建的对象，那么就会报错。</li>
<li>如果对象没有 valueOf() 方法，或者 valueOf() 方法返回的值不是一个原始值，那么调用 toString() 方法，并将返回值强制类型转换为字符串。</li>
<li>如果对象有 valueOf() 方法，并且返回值是一个原始值，那么调用 valueOf() 方法，并将返回值强制类型转换为字符串。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(a)) <span class="comment">// Uncaught TypeError: Cannot convert object to primitive value</span></span><br><span class="line"></span><br><span class="line">a.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="number">123</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(a)) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">a.<span class="property">valueOf</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123; <span class="keyword">return</span> &#123;&#125; &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(a)) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">a.<span class="property">valueOf</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="number">456</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(a)) <span class="comment">// 456</span></span><br></pre></td></tr></table></figure>

<h2 id="转为布尔值"><a href="#转为布尔值" class="headerlink" title="转为布尔值"></a>转为布尔值</h2><p>JavaScript 中的假值：</p>
<ul>
<li>undefined</li>
<li>null</li>
<li>false</li>
<li>+0、-0、NaN</li>
<li>“”</li>
</ul>
<p>除了以上假值外的都是真值，转换为布尔值后都是 true。</p>
<h2 id="Number-和-parseInt"><a href="#Number-和-parseInt" class="headerlink" title="Number() 和 parseInt()"></a>Number() 和 parseInt()</h2><ul>
<li>Number() 是强制类型转换， 而 parseInt() 是解析数字字符串</li>
<li>解析允许字符串中存在非数字字符串，从左向右解析，遇到非数字字符串就停止。</li>
<li>并且 parseInt() 的参数只能是字符串，遇到非字符串会将其转为字符串在进行解析。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;123c4m&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(a)) <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(a)) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(b)) <span class="comment">// NaN</span></span><br><span class="line">b.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> <span class="string">&#x27;1234abc&#x27;</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(b)) <span class="comment">// 1234</span></span><br></pre></td></tr></table></figure>

<h2 id="a-’’-和-String-a"><a href="#a-’’-和-String-a" class="headerlink" title="a+’’ 和 String(a)"></a>a+’’ 和 String(a)</h2><p>这两种转换字符串的方式有什么区别呢。其实大部分情况下是没有区别的，只有 a 是一个对象的时候有些坑。</p>
<p>前文对于对象转数字和字符串的过程说的都十分清楚了，下面直接看代码。</p>
<p><strong>a + ‘’ 执行过程：</strong></p>
<ol>
<li>会先 a 转为数字。</li>
<li>然后将数字转为字符串</li>
<li>然后拼接字符串</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">a.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="number">123</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a + <span class="string">&#x27;&#x27;</span>) <span class="comment">// &quot;123&quot;</span></span><br><span class="line"></span><br><span class="line">a.<span class="property">valueOf</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="number">456</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a + <span class="string">&#x27;&#x27;</span>) <span class="comment">// &quot;456&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>String(a) 执行过程</strong></p>
<p>直接调用 a 的 toString() 方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">a.<span class="property">valueOf</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="number">456</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(a)) <span class="comment">// &quot;456&quot;</span></span><br><span class="line"></span><br><span class="line">a.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="number">123</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(a)) <span class="comment">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript属性设置和屏蔽</title>
    <url>/2021/03/28/JavaScript%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%B1%8F%E8%94%BD/</url>
    <content><![CDATA[<p>本篇文章需要对 JavaScript 的<strong>原型链</strong>和<strong>属性描述符</strong>有一定的了解。</p>
<p>本篇文章主要分析一下，在 JavaScript 给对象设置属性或是修改对象的属性值背后的过程。</p>
<p>首先看这样一段代码，熟悉一下原型链：</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">obj.<span class="property">a</span> = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="number">233</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">a</span>) <span class="comment">// 233</span></span><br></pre></td></tr></table></figure>

<p>我们分析一下：</p>
<ol>
<li>obj1 没什么好说的，给当前对象上设置一个属性 a，然后读取该值。</li>
<li>obj2 虽然没有属性 a，但是  js 会在 obj2 的原型链上查找 a 属性，然后输出  233。</li>
</ol>
<p><strong>属性存在于原型链上而不存在于要赋值对象的三种情况</strong></p>
<p><strong>第一种情况：</strong></p>
<p><font color ="brow">如果在**[[prototype]]**链上存在同名属性，并且没有被标记为只读 <strong>writable:false</strong>，创建屏蔽属性。</font></p>
<p>我们思考一下，如果有一个  obj3 原型链上有一个属性 foo ，然后仍然我们给 obj3 设置一个同名属性 foo，会发生什么？<br>实践一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj3 = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">foo</span> = <span class="string">&#x27;i am prototype foo&#x27;</span></span><br><span class="line">obj3.<span class="property">foo</span> = <span class="string">&#x27;i am obj3 foo&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj3.<span class="property">foo</span>) <span class="comment">// i am obj3 foo</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">foo</span>) <span class="comment">// i am prototype foo</span></span><br></pre></td></tr></table></figure>

<p>这样的输出是符合预期的，我们给 obj3 添加了一个 foo 属性，而不是修改 Object.prototype.foo 的值。</p>
<p>这种行为称之为<strong>属性屏蔽</strong>，obj3 的 foo 属性屏蔽了原型链上层的 foo 属性。</p>
<p><strong>第二种情况：</strong></p>
<p><font color ="brow">如果在**[[prototype]]**链上存在同名属性，并且被被标记为只读 <strong>writable:false</strong> 。</font></p>
<ul>
<li><font color ="brow">非严格模式下：无法创建屏蔽属性，也无法修改链上的属性。</font></li>
<li><font color ="brow">严格模式下，报错。</font></li>
</ul>
<p>非严格模式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj3 = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="number">333</span></span><br><span class="line">&#125;)</span><br><span class="line">obj3.<span class="property">foo</span> = <span class="string">&#x27;i am obj3 foo&#x27;</span> <span class="comment">// 该语句被忽略</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj3.<span class="property">foo</span>) <span class="comment">// 333</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">foo</span>) <span class="comment">// 333</span></span><br></pre></td></tr></table></figure>

<p>严格模式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj3 = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="number">333</span></span><br><span class="line">&#125;)</span><br><span class="line">obj3.<span class="property">foo</span> = <span class="string">&#x27;i am obj3 foo&#x27;</span> <span class="comment">// TypeError: Cannot assign to read only property &#x27;foo&#x27; of object &#x27;#&lt;Object&gt;&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj3.<span class="property">foo</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">foo</span>)</span><br></pre></td></tr></table></figure>

<p><strong>第三种情况：</strong></p>
<p><font color ="brow">如果在**[[prototype]]<strong>链上存在同名属性，并且它是一个</strong>[[setter]]**，那么就会调用它。</font></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj3 = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;i am a setter!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">obj3.<span class="property">foo</span> = <span class="string">&#x27;i am obj3 foo&#x27;</span> <span class="comment">// i am a setter!</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj3.<span class="property">foo</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">foo</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>可以到执行 obj3.foo 时，输出了 <code>i am a setter! </code>，并且也没有发生<strong>属性屏蔽</strong>。</p>
<p>可以看到，js 中设置一个属性并没有那个简单，除了第一种情况，剩下两种情况的行为都比较 “奇怪”，需要注意。</p>
<p>那么我们如何让 <strong>属性屏蔽</strong> 总是发生？</p>
<p><strong>使用Object.defineProperty来屏蔽属性</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二种情况</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;foo1&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;Object.prototype.foo1&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;foo1&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;obj.foo1&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">foo1</span>) <span class="comment">// obj.foo1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">foo1</span>) <span class="comment">// Object.prototype.foo1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种情况</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;foo2&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;i am foo2 setter&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;get foo2 success!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj2, <span class="string">&#x27;foo2&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;obj.foo2&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">foo2</span>) <span class="comment">// obj.foo2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">foo2</span>) <span class="comment">// get foo2 success!</span></span><br></pre></td></tr></table></figure>

<p>可以看到，第二种和第三种情况都成功屏蔽了原型链上的同名属性！</p>
<p>参考链接：</p>
<ul>
<li>《你不知道的JavaScript上卷》p144</li>
<li><a href="http://ruomuc.gitee.io/blog/2021/02/21/js%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/">js对象的属性描述符</a></li>
<li><a href="http://ruomuc.gitee.io/blog/2020/05/21/javascript%E5%8E%9F%E5%9E%8B%E9%93%BE/">javascript原型链</a></li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript行为委托</title>
    <url>/2021/03/21/JavaScript%E8%A1%8C%E4%B8%BA%E5%A7%94%E6%89%98/</url>
    <content><![CDATA[<p>在 java 、c# 等语言中，类是一种必须使用的”设计模式“，但是在 JavaScript 等语言中，它是可选的，并且在JavaScript中实现类总是会有各种缺陷。</p>
<p>还有要注意的一点是，JavaScript中没有类，只有对象，没有继承，只有委托（prototype）。</p>
<p>包括 es6 的 class 语法在内的各种语法糖，也不会改变这个事实。</p>
<p><strong>首先要了解两个技巧</strong></p>
<ol>
<li> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call#%E4%BD%BF%E7%94%A8_call_%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">使用 call 方法调用父构造函数可以实现继承</a></li>
<li> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create#%E7%94%A8_object.create%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%BC%8F%E7%BB%A7%E6%89%BF">用 <code>Object.create</code>实现类式继承</a></li>
</ol>
<p><strong>“类”风格的代码</strong></p>
<p>基于 原型链的 ”继承” 不是真正的继承（拷贝副本），只是”引用“而已。</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params">who</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">me</span> = who</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">identify</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;I am &quot;</span> + <span class="variable language_">this</span>.<span class="property">me</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">speak</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Foo name is , &quot;</span> + <span class="variable language_">this</span>.<span class="title function_">identify</span>() + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Bar</span>(<span class="params">who</span>)&#123;</span><br><span class="line">    <span class="comment">// ”继承“ me属性</span></span><br><span class="line">    <span class="title class_">Foo</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>,who)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// “继承” identify 和 speak 方法</span></span><br><span class="line"><span class="title class_">Bar</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写 speak 方法</span></span><br><span class="line"><span class="title class_">Bar</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">speak</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="title function_">identify</span>() + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="keyword">new</span> <span class="title class_">Bar</span>(<span class="string">&quot;b1&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="keyword">new</span> <span class="title class_">Bar</span>(<span class="string">&quot;b2&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span>  <span class="title class_">Foo</span>(<span class="string">&quot;f1&quot;</span>)</span><br><span class="line"></span><br><span class="line">b1.<span class="title function_">speak</span>() <span class="comment">// Hello, I am b1.</span></span><br><span class="line">b2.<span class="title function_">speak</span>() <span class="comment">// Hello, I am b2.</span></span><br><span class="line">f1.<span class="title function_">speak</span>() <span class="comment">// Foo name is , I am f1. 实现了“多态”</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是如果父类修改了它的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">identify</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Foo modified identify  &quot;</span> + <span class="variable language_">this</span>.<span class="property">me</span></span><br><span class="line">&#125;</span><br><span class="line">b1.<span class="title function_">speak</span>() <span class="comment">// Hello, Foo modified identify  b1.</span></span><br></pre></td></tr></table></figure>

<p><strong>委托风格</strong></p>
<p>委托意味着某些对象找不到属性或者方式时，会把这个请求委托给另一个对象。</p>
<ol>
<li> 没有父子级的关系，无需继承。</li>
<li>b1 把 speak 需要的一些行为放在 Foo 中，两个对象协同完成 speak 这一动作。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="attr">init</span>: <span class="keyword">function</span> (<span class="params">who</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">me</span> = who</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">identify</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;I am &#x27;</span> + <span class="variable language_">this</span>.<span class="property">me</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Bar</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Foo</span>)</span><br><span class="line"><span class="title class_">Bar</span>.<span class="property">speak</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, &#x27;</span> + <span class="variable language_">this</span>.<span class="title function_">identify</span>() + <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Bar</span>)</span><br><span class="line">b1.<span class="title function_">init</span>(<span class="string">&#x27;b1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Bar</span>)</span><br><span class="line">b2.<span class="title function_">init</span>(<span class="string">&#x27;b2&#x27;</span>)</span><br><span class="line">b1.<span class="title function_">speak</span>() <span class="comment">// Hello, I am b1.</span></span><br><span class="line">b2.<span class="title function_">speak</span>() <span class="comment">// Hello, I am b2.</span></span><br></pre></td></tr></table></figure>

<p>类的代码组织方式类似一棵树，是垂直的， 而委托的代码组织方式是并排的。</p>
<p>ps: 因为我工作使用的第一门语言就是 JavaScript ，中间也没有怎么用过OOP，所以对于 js 的这一套是很好接受的。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title>js判断数据类型</title>
    <url>/2021/03/03/js%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>之前对js的类型判断用到的比较少，只知道typeof 和 instanceof。。</p>
<p>MDN上面其实介绍的挺详细的。。这里随便记一下</p>
<h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof">typeof</a></h2><p>typeof 是一个<strong>一元</strong>操作符，返回被操作数类型的字符串。</p>
<p>typeof 可以在你基本可以确定数据是哪一类数据，需要稍加区分的时候使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;1&#x27;</span> <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>(<span class="string">&quot;a&quot;</span>) <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="title class_">Object</span>() <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="title class_">Date</span>() <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> /\w/ <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，null、数组和对象等。类型都被判断为了”object”。</p>
<p>并且<code>typeof null=== &quot;object&quot; </code>是一个很蛋疼的bug。</p>
<p>在《你不知道的JavaScript》一书中译者说道：原理是这样的，不同的对象在底层都表示为二进制，在JavaScript中二进制前三位都为0的话，就会被判断为 object 类型，null的二进制就是全0，自然前三位也是0，所以执行 typeof 时会返回 “object”。</p>
<h2 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString()"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString">Object.prototype.toString()</a></h2><p>每个类在内部都有一个 [[Class]] 属性。</p>
<p>Object.prototype.toString 的原理是当调用的时候, 就取值内部的 [[Class]] 属性值, 然后拼接成 ‘[object ‘ + [[Class]] + ‘]’ 这样的字符串并返回。</p>
<p>对于使用 typeof 无法判断的类型，可以使用 <code>Object.prototype.toString()</code>来检测，该方法会获取对象的 [[Class]] 值。</p>
<span id="more"></span>
<p>因为大部分对象的 toString 方法都被重写过，所以要使用 <code>Object.prototype.toString.call /Object.prototype.toString.apply </code>的方式调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">toString.<span class="title function_">call</span>(<span class="number">1</span>); <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line">toString.<span class="title function_">call</span>(<span class="string">&#x27;1&#x27;</span>); <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line">toString.<span class="title function_">call</span>(<span class="literal">true</span>); <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line">toString.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()); <span class="comment">// [object Date]</span></span><br><span class="line">toString.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">String</span>()); <span class="comment">// [object String]</span></span><br><span class="line">toString.<span class="title function_">call</span>(<span class="title class_">Math</span>); <span class="comment">// [object Math]</span></span><br><span class="line">toString.<span class="title function_">call</span>(<span class="literal">undefined</span>); <span class="comment">// [object Undefined]</span></span><br><span class="line">toString.<span class="title function_">call</span>(<span class="literal">null</span>); <span class="comment">// [object Null]</span></span><br></pre></td></tr></table></figure>

<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof">instanceof</a></h2><p>语法：<code>obj instanceof constructor</code></p>
<p><code>instanceof</code> 运算符用来检测 <code>constructor.prototype </code>是否存在于参数 <code>object</code> 的原型链上。</p>
<p>看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">AA</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">AA</span>()</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">a <span class="keyword">instanceof</span> <span class="variable constant_">AA</span> <span class="comment">// true</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="variable constant_">AA</span> <span class="comment">// false</span></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>看不懂 <code>b instanceof AA === false </code>  和 <code>a instanceof Object === true</code> 的，需要去了解一下原型链。</p>
<p>我之前写过一篇关于原型链的：<a href="http://ruomuc.gitee.io/blog/2020/05/21/javascript%E5%8E%9F%E5%9E%8B%E9%93%BE/">JavaScript原型链</a></p>
<h2 id="isNaN-amp-Number-isNaN"><a href="#isNaN-amp-Number-isNaN" class="headerlink" title="isNaN &amp; Number.isNaN"></a>isNaN &amp; Number.isNaN</h2><p>先看 isNaN</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;string&quot;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">undefined</span>) <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>明显不合理，NaN是一个特殊的值，isNaN 把 “string” 和 undefined 等都判断成了 “NaN”。</p>
<p>所以 ES6 为了弥补这个bug，(并没有修复isNaN)。增加了 Number.isNaN。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&quot;string&quot;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>判断比较简单的，基本可以确定的数据类型，使用 typeof</li>
<li>判断 typeof 无法判断的（大部分”object”类型），使用 <code>Object.prototype.toString</code></li>
<li>判断原型链的方法的 某个”构造函数”的 prototype 是否在 对象的原型链上，使用 instanceof</li>
<li>判断是不是 ”NaN“值，推荐使用 <code>Number.isNaN()</code></li>
</ul>
<p>ps: 关于原型链的文章，后面可能还会写。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>Kruskal算法</title>
    <url>/2021/02/28/Kruskal%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>一月份力扣出了一个月的图论题，可惜那时在封闭开发（爆粗口），有些没时间做。</p>
<p>Kruskal算法是一种用来查找<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91">最小生成树</a>的算法，适合用于查找<strong>稀疏图</strong>的最小生成树。</p>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h4 id="什么是最小生成树"><a href="#什么是最小生成树" class="headerlink" title="什么是最小生成树"></a>什么是最小生成树</h4><p>最小生成树是<strong>一副连通加权无向图</strong>中，<strong>一颗权值最小的生成树</strong>。</p>
<ul>
<li>生成树：在<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E8%AE%BA">图论</a>中，<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)">无向图</a> <em>G</em> 的<strong>生成树</strong>（英语：Spanning Tree）是具有 <em>G</em> 的全部<a href="https://zh.wikipedia.org/wiki/%E9%A1%B6%E7%82%B9_(%E5%9B%BE%E8%AE%BA)">顶点</a>，但边数最少的连通子图。</li>
<li>连通：无向图中，任意两个顶点都有<strong>通路</strong>。</li>
<li>加权：图分为有权图和无权图，权值可以理解为边的权重。</li>
<li>无向：图分为有向图和无向图，可以理解为边是否有方向。</li>
<li>权值最小：所有边的权值之和最小。</li>
</ul>
<p>最小生成树在分布式系统中有非常重要作用。。(我收藏夹里的 MIT6.824 公开课有时间也要看看了。。)</p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集是一种数据结构，不是一种算法。</p>
<p>并查集是Kruskal算法的关键，用于快速判断两个元素是否在同一个集合之中。（结果不能有环）</p>
<p>这里有个大佬的文章，对并查集讲的十分透彻：<a href="https://zhuanlan.zhihu.com/p/93647900">https://zhuanlan.zhihu.com/p/93647900</a></p>
<p>go的代码实现：</p>
<span id="more"></span>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> unionFind <span class="keyword">struct</span> &#123;</span><br><span class="line">	parent []<span class="type">int</span></span><br><span class="line">	rank   []<span class="type">int</span> <span class="comment">// 用于按秩合并</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(uf *unionFind)</span></span> find(x <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> uf.parent[x] == x &#123;</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 路径压缩</span></span><br><span class="line">	uf.parent[x] = uf.find(uf.parent[x])</span><br><span class="line">	<span class="keyword">return</span> uf.parent[x]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(uf *unionFind)</span></span> merge(x, y <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	fx, fy := uf.find(x), uf.find(y)</span><br><span class="line">	<span class="comment">// 如果他们有相同的根节点，无需合并</span></span><br><span class="line">	<span class="keyword">if</span> fx == fy &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> uf.rank[fx] &lt;= uf.rank[fy] &#123;</span><br><span class="line">		uf.parent[fx] = fy</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		uf.parent[fy] = fx</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果秩相同</span></span><br><span class="line">	<span class="keyword">if</span> uf.rank[fx] == uf.rank[fy] &amp;&amp; fx != fy &#123;</span><br><span class="line">		<span class="comment">// 这里为什么要把fy的深度加1呢</span></span><br><span class="line">		<span class="comment">// 因为uf.rank[fx] &lt;= uf.rank[fy]时，uf.parent[fx] = fy</span></span><br><span class="line">		<span class="comment">// 所以他们深度本来相同。但是fx挂载了fy下面，所以反fy的深度增加了</span></span><br><span class="line">		<span class="comment">// 如果这里改为uf.rank[fx] &lt; uf.rank[fy],那么会走到else里面的uf.parent[fy] = fx</span></span><br><span class="line">		<span class="comment">// 这时，fx的深度应该加1</span></span><br><span class="line">		uf.rank[fy]++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newUnionFind</span><span class="params">(n <span class="type">int</span>)</span></span> *unionFind &#123;</span><br><span class="line">	parent := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">	rank := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		parent[i] = i</span><br><span class="line">		rank[i] = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;unionFind&#123;parent, rank&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Kruskal-克鲁斯卡尔"><a href="#Kruskal-克鲁斯卡尔" class="headerlink" title="Kruskal(克鲁斯卡尔)"></a>Kruskal(克鲁斯卡尔)</h2><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>新建图G，G中拥有原图相同的节点，但没有边。</li>
<li>将原图中所有的边，按照权值从小到大排序。（因为要权值和最小，所以从权值小的边开始挑）</li>
<li>从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边到图G中。（避免形成环）</li>
<li>重复3，直至图G中所有节点都在一个连通分量重。（一般重复n-1次，n为节点个数）</li>
</ol>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>力扣中等题： <a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/">连接所有点的最小费用</a></p>
<p>AC代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 前文并查集实现代码省略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCostConnectPoints</span><span class="params">(points [][]<span class="type">int</span>)</span></span> (ans <span class="type">int</span>) &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(points)</span><br><span class="line">	<span class="keyword">type</span> edge <span class="keyword">struct</span>&#123; v, w, dis <span class="type">int</span> &#125;</span><br><span class="line">	edges := []edge&#123;&#125;</span><br><span class="line">	<span class="comment">// 记录边和边的距离信息</span></span><br><span class="line">	<span class="keyword">for</span> i, p := <span class="keyword">range</span> points &#123;</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">			edges = <span class="built_in">append</span>(edges, edge&#123;i, j, dist(p, points[j])&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根据曼哈顿距离从小到大排序,题中的曼哈顿距离就是边的权值</span></span><br><span class="line">	sort.Slice(edges, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> edges[i].dis &lt; edges[j].dis &#125;)</span><br><span class="line"></span><br><span class="line">	uf := newUnionFind(n)</span><br><span class="line">	<span class="comment">// 只需要重复n-1次</span></span><br><span class="line">	left := n - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> _, e := <span class="keyword">range</span> edges &#123;</span><br><span class="line">		<span class="keyword">if</span> uf.merge(e.v, e.w) &#123;</span><br><span class="line">			ans += e.dis</span><br><span class="line">			left--</span><br><span class="line">			<span class="keyword">if</span> left == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dist</span><span class="params">(p, q []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> abs(p[<span class="number">0</span>]-q[<span class="number">0</span>]) + abs(p[<span class="number">1</span>]-q[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> -a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题中没有步骤的第一步，构造图，并且返回的值不是生成树，而是权值和。但是思想是一样的。</p>
<p>ps:  本来算法就比较渣，也没打算从事算法相关岗位(<del>主要因为菜</del>)，只是随便写写吧。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图</tag>
        <tag>最小生成树</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>js对象的属性描述符</title>
    <url>/2021/02/21/js%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h2><p>JavaScript提供了一系列方法来修改和获取对象中属性的行为。</p>
<p>思考下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myobj = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(myobj,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    configurable: true</span></span><br><span class="line"><span class="comment">//    enumerable: true</span></span><br><span class="line"><span class="comment">//    value: 2</span></span><br><span class="line"><span class="comment">//    writable: true</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>

<p>这就是<strong>myobj</strong>中属性”a”的描述符：</p>
<ul>
<li><code>value:2</code> 代表a的值是2</li>
<li><code>enumerable: true</code>  代表属性a是可枚举的</li>
<li><code>configurable: true</code>  代表属性a是可配置的，也就是a的属性描述符是可以修改的，可以使用<code>defineProperty</code>来修改属性描述符。</li>
<li><code>writable: true</code>  代表属性a的值是可写的，也就是值是可以修改的</li>
</ul>
<p>特殊说明：</p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myobj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(myobj, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">myobj.<span class="property">a</span> = <span class="number">3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myobj.<span class="property">a</span>)</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(myobj, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line">myobj.<span class="property">a</span> = <span class="number">3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myobj.<span class="property">a</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(myobj,<span class="string">&quot;a&quot;</span>))</span><br><span class="line"><span class="keyword">delete</span> myobj.<span class="property">a</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myobj.<span class="property">a</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//&#123; value: 2, writable: false, enumerable: true, configurable: false &#125;</span></span><br><span class="line"><span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>观察上面这段代码可以知道：</p>
<ul>
<li>即便属性 <code>configurable:false</code> ，我们还是可以把 writable 状态由 true 改为 false</li>
<li>如果属性的<code>configurable: false</code> ，那么会禁止删除这个属性</li>
</ul>
<h3 id="getter-和-setter"><a href="#getter-和-setter" class="headerlink" title="getter 和 setter"></a>getter 和 setter</h3><p>除了以上属性描述符，还有两个比较特殊的</p>
<p>观察以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  get a () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span> * <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">b</span>) <span class="comment">// 4</span></span><br><span class="line">obj.<span class="property">a</span> = <span class="number">111</span></span><br><span class="line">obj.<span class="property">b</span> = <span class="number">222</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">b</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>甚至可以这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;c&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = <span class="variable language_">this</span>.<span class="property">a</span> * <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">c</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">c</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">c</span>) <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>

<ul>
<li>属性没有 value 值，也可以通过 get 描述符定义的函数来获取值。</li>
<li>如果只定义了get 而没有set 的话，那么无法修改属性值，所以get和set通常是同时出现的。</li>
<li>如果你同时定义了get/set 描述符，那么就不能出现value描述符，否则会报错。</li>
<li>使用set/get，可以定义很灵活且个性化的对象。。</li>
</ul>
<h2 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h2><p>在JavaScript中你有很多方法来使属性或者对象不可改变，但是所有方法创建的都是浅不变性，它们只会影响目标对象的直接属性。</p>
<p>如果目标对象引用了其他对象，其他对象的内容不受影响，仍然是可变的。</p>
<h4 id="对象常量"><a href="#对象常量" class="headerlink" title="对象常量"></a>对象常量</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myobj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(myobj, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用 <code>writable: false</code>和<code>configurable: false</code>就可以创建一个不可修改和删除的常量属性。</p>
<h4 id="禁止扩展"><a href="#禁止扩展" class="headerlink" title="禁止扩展"></a>禁止扩展</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myobj = &#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(myobj)</span><br><span class="line">myobj.<span class="property">b</span> = <span class="number">3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myobj.<span class="property">b</span>)</span><br></pre></td></tr></table></figure>

<p>使用<code>Object.preventExtensions(...)</code>可以禁止向一个对象添加新属性，并保留已有属性。</p>
<ul>
<li>严格模式下添加新属性会报错</li>
<li>非严格模式下回静默失败</li>
</ul>
<h4 id="密封"><a href="#密封" class="headerlink" title="密封"></a>密封</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myobj = &#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">seal</span>(myobj)</span><br></pre></td></tr></table></figure>

<p><code>Object.seal()</code> 等于下面两个的组合：</p>
<ul>
<li><code>Object.preventExtensions()</code></li>
<li><code>configurable: false</code></li>
</ul>
<p>密封之后，不仅不能添加新属性，也不可以重新配置和删除现有属性。但是可以修改现有属性的值。</p>
<h4 id="冻结"><a href="#冻结" class="headerlink" title="冻结"></a>冻结</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myobj = &#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(myobj)</span><br></pre></td></tr></table></figure>

<p><code>Object.freeze()</code> 等于下面三个的组合：</p>
<ul>
<li><code>Object.preventExtensions()</code></li>
<li><code>configurable: false</code></li>
<li><code>writable: false</code></li>
</ul>
<p>冻结就是在密封的基础上，禁止修改现有属性的值。</p>
<p>冻结是你可以应用在对象上的级别最高的不可变性，会禁止对对象本身和其任意属性的修改。但是冻结对象引用的其他对象是不生效的。</p>
<h2 id="存在性"><a href="#存在性" class="headerlink" title="存在性"></a>存在性</h2><h4 id="in操作符"><a href="#in操作符" class="headerlink" title="in操作符"></a>in操作符</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myobj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">myobj.<span class="property">__proto__</span>.<span class="property">b</span> = <span class="number">3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> myobj) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b&quot;</span> <span class="keyword">in</span> myobj) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;c&quot;</span> <span class="keyword">in</span> myobj) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>in 操作符会检查属性是否在对象及其[[Prototype]]原型链中。</p>
<h4 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myobj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">myobj.<span class="property">__proto__</span>.<span class="property">b</span> = <span class="number">3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myobj.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;a&quot;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myobj.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;b&quot;</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>与 in 操作符不同，hasOwnProperty 只会检查属性是否在当前对象中。</p>
<h4 id="枚举属性"><a href="#枚举属性" class="headerlink" title="枚举属性"></a>枚举属性</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myobj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">myobj.<span class="property">__proto__</span>.<span class="property">c</span>= <span class="number">4</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(myobj, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> myobj) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myobj.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;a&quot;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myobj.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&quot;a&quot;</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myobj.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&quot;b&quot;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(myobj)) <span class="comment">// [ &#x27;b&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(myobj)) <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27; ]</span></span><br></pre></td></tr></table></figure>

<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><h5 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h5><p>for…in 遍历对象的可枚举属性，包括原型链上的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myobj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">myobj.<span class="property">__proto__</span>.<span class="property">d</span> = <span class="number">4</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(myobj, <span class="string">&#x27;c&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> myobj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, <span class="string">&#x27;=&#x27;</span>, myobj[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不想遍历原型链上的属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> myobj) &#123;</span><br><span class="line">  <span class="keyword">if</span> (myobj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, <span class="string">&#x27;=&#x27;</span>, myobj[key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h5><p>使用Object.keys() 获取对象的所有可枚举属性（不包含原型链），然后使用普通的数据遍历获取key的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> myobj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">myobj.<span class="property">__proto__</span>.<span class="property">d</span> = <span class="number">4</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(myobj, <span class="string">&#x27;c&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(myobj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, <span class="string">&#x27;=&#x27;</span>, myobj[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> myobj) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这样是会报错的 <code>myobj is not iterable</code>，因为obj对象没有迭代器对象。</p>
<p>但是像其他的，例如 map set 和 数组，都会有迭代器对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()) <span class="comment">// Object [Array Iterator] &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()) <span class="comment">// [Map Entries] &#123;  &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()) <span class="comment">// [Set Iterator] &#123;  &#125;</span></span><br></pre></td></tr></table></figure>

<p>那我我们可以手动添加一个迭代器对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">2</span>, <span class="attr">b</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="title class_">Symbol</span>.<span class="property">iterator</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">var</span> idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> ks = <span class="title class_">Object</span>.<span class="title function_">keys</span>(that)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">value</span>: that[ks[idx++]],</span><br><span class="line">          <span class="attr">done</span>: idx &gt; ks.<span class="property">length</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> iterator <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(iterator) <span class="comment">// 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最后给个对比表格：</p>
<table>
<thead>
<tr>
<th></th>
<th>仅可枚举的</th>
<th>仅对象自身（不包含原型链）</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>in</td>
<td>否</td>
<td>否</td>
<td>返回值为布尔值</td>
</tr>
<tr>
<td>hasOwnProperty()</td>
<td>否</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>Object.keys()</td>
<td>是</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>getOwnPropertyNames()</td>
<td>否</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>propertyIsEnumerable()</td>
<td></td>
<td>是</td>
<td>判断属性是否可枚举</td>
</tr>
<tr>
<td>for…in</td>
<td>是</td>
<td>否</td>
<td>忽略symbol属性</td>
</tr>
</tbody></table>
<p>遍历原型链上所有 enumerable 为 true 或 false 的属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myobj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">myobj.<span class="property">__proto__</span>.<span class="property">d</span> = <span class="number">4</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(myobj, <span class="string">&#x27;c&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>参考链接：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties</a></li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>属性描述符</tag>
      </tags>
  </entry>
  <entry>
    <title>go的结构体和接口</title>
    <url>/2021/02/07/go%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>刚开始学go的时候，第一遍文档看完，没有搞懂结构体和接口的意思，现在大概明白了，记录一下。</p>
<h2 id="函数和方法"><a href="#函数和方法" class="headerlink" title="函数和方法"></a>函数和方法</h2><p>在了解结构体和接口之前</p>
<p>在我写<code>JavaScript</code>的时候，大部分不区分这两个叫法，但是在<code>Java</code>中，定义在类中的函数，习惯称之为”方法”。</p>
<p>我在网上找到这么个说法：</p>
<ul>
<li>函数是独立的功能，与对象无关，需要显示的传递数据</li>
<li>方法与对象和类相关，依赖对象而调用，可以直接处理对象上的数据，也就是隐式传递数据</li>
<li>c语言中只有函数</li>
</ul>
<p>emm…  和我理解的差不多。。</p>
<p>在<code>golang</code>中可以这么理解：</p>
<ul>
<li>函数属于一个包，分为公有函数（首字母大写，其他包可以用），私有函数（首字母小写，只能当前包内部使用）。</li>
<li>方法属于一个结构体。</li>
</ul>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p><strong>结构体的声明和使用：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">	age <span class="type">int</span></span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...省略main函数</span></span><br><span class="line">p := &amp;Person&#123;age:<span class="number">22</span>,name:<span class="string">&quot;ruomu&quot;</span>&#125; <span class="comment">// 等价于 p := &amp;Person&#123;22,&quot;ruomu&quot;&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;age= %d, name= %s&quot;</span>,p.age,p.name) <span class="comment">// age= 22, name= ruomu</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p><strong>结构体的嵌套：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span>&#123;</span><br><span class="line">    country <span class="type">string</span></span><br><span class="line">    city <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">   	age <span class="type">int</span></span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">    add Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...省略main函数</span></span><br><span class="line">p := &amp;Person&#123;age:<span class="number">22</span>,name:<span class="string">&quot;ruomu&quot;</span>,add:Address&#123;country:<span class="string">&quot;china&quot;</span>,city:<span class="string">&quot;beijing&quot;</span>&#125;&#125; </span><br><span class="line">p.add.city <span class="comment">// beijing</span></span><br></pre></td></tr></table></figure>

<p><strong>结构体的方法：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">   	age <span class="type">int</span></span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> Hello()&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello &quot;</span>,p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...省略main函数</span></span><br><span class="line">p := Person&#123;age:<span class="number">22</span>,name:<span class="string">&quot;ruomu&quot;</span>&#125;</span><br><span class="line">p.Hello() <span class="comment">// hello ruomu</span></span><br></pre></td></tr></table></figure>

<p>我们仔细一点会发现上面的代码中，接收者<code>p *Person</code>是一个指针类型，但是我们调用者<code>p := Person&#123;age:22,name:&quot;ruomu&quot;&#125;</code> 却是一个值类型。</p>
<p>事实上：</p>
<ul>
<li>方法的接收者既可以是一个值类型，也可以是一个指针类型。</li>
<li>如果使用一个值类型变量调用指针类型接收者的方法，Go 语言编译器会自动帮我们取指针调用，以满足指针接收者的要求。</li>
<li>同样的原理，如果使用一个指针类型变量调用值类型接收者的方法，Go 语言编译器会自动帮我们解引用调用，以满足值类型接收者的要求。</li>
</ul>
<p>所以，接收者定义为值类型还是指针类型，取决你想不想修改原始对象的值，不用考虑调用方是不是指针类型。</p>
<p>**方法可以赋值给一个变量，调用时第一个参数必须是该方法的接收者: **</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">   	age <span class="type">int</span></span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Hello()&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello &quot;</span>,p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...省略main函数</span></span><br><span class="line">h := Person.Hello</span><br><span class="line">h(p)</span><br></pre></td></tr></table></figure>

<p>这里Hello方法的接收者写成指针类型就会报错，试了几种写法都不行。。。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>以上面的Person结构体为例</p>
<p><strong>接口的定义和实现：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">type</span> WalkRun <span class="keyword">interface</span> &#123;</span><br><span class="line">	Walk()</span><br><span class="line">	Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>  Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	age <span class="type">int</span></span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span>Walk()&#123;</span><br><span class="line">	fmt.Print(<span class="string">&quot;walk&quot;</span>,p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(p *Person)</span></span>Run()&#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s run&quot;</span>,p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	p := &amp;Person&#123;name:<span class="string">&quot;zm&quot;</span>,age:<span class="number">1</span>&#125;</span><br><span class="line">	WalkRun.Run(p) <span class="comment">// zm run </span></span><br><span class="line">    WalkRun.Walk(p) <span class="comment">// walk zm</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和java一样，如果一个接口有多个方法，那么需要实现接口的每个方法才算是实现了这个接口。（抽象类除外）</p>
<p>这里有一点需要注意，和结构体的方法不同，实现了接口的方法：</p>
<ul>
<li>接收者是指针类型时，调用必须传入指针类型。</li>
<li>接收者是值类型时，调用者随意。（指针类型会被转为值类型，和前文描述的行为相同）</li>
</ul>
<h2 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h2><p>go语言中，没有继承的概念，所以go语言利用的是组合来达到代码复用的目的。</p>
<p>以go语言的io标准包的接口为例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ReadWriter是Reader和Writer的组合</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然结构体也可以组合：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span>&#123;</span><br><span class="line">    country <span class="type">string</span></span><br><span class="line">    city <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">   	age <span class="type">int</span></span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">    Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...省略main函数</span></span><br><span class="line">p := &amp;Person&#123;age:<span class="number">22</span>,name:<span class="string">&quot;ruomu&quot;</span>,Address:Address&#123;country:<span class="string">&quot;china&quot;</span>,city:<span class="string">&quot;beijing&quot;</span>&#125;&#125;</span><br><span class="line">p.city <span class="comment">// beijing</span></span><br></pre></td></tr></table></figure>


<p><strong>写在最后：</strong></p>
<p>接口组合并不是继承，因为它虽然可以复用”被继承”的接口的方法，但是却无法重写该方法。</p>
<p>感觉就是个语法糖，由于我oop接触的不多，反而不受java那套影响，更容易接受一些。。</p>
<p>参考链接：</p>
<ul>
<li><p><a href="https://www.cnblogs.com/wancy86/p/7271850.html">https://www.cnblogs.com/wancy86/p/7271850.html</a></p>
</li>
<li><p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=536#/detail/pc?id=5231">https://kaiwu.lagou.com/course/courseInfo.htm?courseId=536#/detail/pc?id=5231</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>重学操作系统</title>
    <url>/2020/12/27/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>之前虽然也自己用vps搭搭机场、部署一下自己的小网站啥的，但是对linux和操作系统没有太多深入了解，所以双11在拉钩抢了一些课，随便记记。</p>
<p>这种东西还是要看多用，所以就大概过一遍知识点，有个印象。</p>
<h2 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h2><br>

<h3 id="32位和64位"><a href="#32位和64位" class="headerlink" title="32位和64位"></a>32位和64位</h3><ul>
<li>如果是软件，那么我们的数据库有 32 位和 64 位版本；</li>
<li>如果是操作系统，那么在阿里云上选择 Centos 和 Debian 版本的时候，也会有 32/64 版本；</li>
<li>如果是 CPU，那么有 32 位 CPU，也有 64 位 CPU。</li>
</ul>
<h3 id="冯诺依曼模型"><a href="#冯诺依曼模型" class="headerlink" title="冯诺依曼模型"></a>冯诺依曼模型</h3><h4 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h4><h4 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h4><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><h4 id="CPU-中央处理器"><a href="#CPU-中央处理器" class="headerlink" title="CPU(中央处理器)"></a>CPU(中央处理器)</h4><ul>
<li><p>如果 CPU 每次可以计算 4 个 byte，那么我们称作 32 位 CPU</p>
</li>
<li><p>如果 CPU 每次可以计算 8 个 byte，那么我们称作 64 位 CPU</p>
</li>
<li><p>这里的 32 和 64，称作 CPU 的位宽。</p>
</li>
</ul>
<h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><p>CPU 和内存以及其他设备之间，也需要通信，因此我们用一种特殊的设备进行控制，就是总线。总线分成 3 种：</p>
<ul>
<li>一种是地址总线，专门用来指定 CPU 将要操作的内存地址</li>
<li>还有一种是数据总线，用来读写内存中的数据</li>
<li>最后一种总线叫作控制总线，用来发送和接收关键信号，比如中断信号，还有设备复位、就绪等信号，都是通过控制总线传输。同样的，CPU 需要对这些信号进行响应，这也需要控制总线</li>
</ul>
<span id="more"></span>

<h3 id="存储器分级策略"><a href="#存储器分级策略" class="headerlink" title="存储器分级策略"></a>存储器分级策略</h3><p><img src="https://s0.lgstatic.com/i/image/M00/51/2D/Ciqc1F9kgVGAD_IMAACXR1QKcDo779.png"></p>
<blockquote>
<p>假设有一个二维数组，总共有 1M 个条目，如果我们要遍历这个二维数组，应该逐行遍历还是逐列遍历？</p>
</blockquote>
<p>逐行遍历会更快。当 CPU 遍历二维数组的时候，会先从 CPU 缓存中取数据。CPU 设计不是每次读取一个内存地址，而是读取每次读取相邻的多个内存地址，</p>
<p>可以二维数组想象成只有一行的一维数组，行坐标增加时，内存空间是跳跃的。列坐标增加时，内存空间是连续的。</p>
<blockquote>
<p>SSD、内存和 L1 Cache 相比速度差多少倍？</p>
</blockquote>
<p>因为内存比 SSD 快 10<del>1000 倍，L1 Cache 比内存快 100 倍左右。因此 L1 Cache 比 SSD 快了 1000</del>100000 倍。所以你有没有发现 SSD 的潜力很大，好的 SSD 已经接近内存了，只不过造价还略高。</p>
<h2 id="Linux指令入门"><a href="#Linux指令入门" class="headerlink" title="Linux指令入门"></a>Linux指令入门</h2><h3 id="什么是shell"><a href="#什么是shell" class="headerlink" title="什么是shell"></a>什么是shell</h3><p>Shell 把我们输入的指令，传递给操作系统去执行，所以 Shell 是一个命令行的用户界面。<br><br></p>
<h3 id="几种常见的文件类型"><a href="#几种常见的文件类型" class="headerlink" title="几种常见的文件类型"></a>几种常见的文件类型</h3><p>Linux 把所有的设备都抽象成了文件，比如说打印机、USB、显卡等。这让整体的系统设计变得高度统一。</p>
<ul>
<li>普通文件（比如一个文本文件）<font color="red">没有符号结尾的是普通文件</font></li>
<li>目录文件（目录也是一个<strong>特殊的文件</strong>，它用来存储文件清单，比如<code>/</code>也是一个文件） <font color="red">/ 结尾的是目录</font></li>
<li>可执行文件（<code>rm</code>就是一个可执行文件）。<font color="red">* 结尾的是可执行文件</font></li>
<li>管道文件。<font color ="red"> | 结尾的管道文件</font></li>
<li>Socket 文件。<font color="red">= 结尾的是 Socket 文件</font></li>
<li>软链接文件。<font color="red">@ 结尾的是软链接</font></li>
<li>硬链接文件。<font color="red">= 结尾的是 Socket 文件</font></li>
</ul>
<br>

<h3 id="文件的增删改查"><a href="#文件的增删改查" class="headerlink" title="文件的增删改查"></a>文件的增删改查</h3><h4 id="man"><a href="#man" class="headerlink" title="man"></a>man</h4><p><code>man</code>意思是 <code>manual</code>，就是说明书的意思，这里指的是系统的手册。比如使用<code>man touch</code>就会列出<code>touch</code>命令的详细用法。</p>
<h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><p>touch指令本来是用来更改文件的时间戳的，但是如果文件不存在touch也会帮助创建一个空文件。</p>
<p><code>touch test.txt</code></p>
<h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p>增加一个目录</p>
<p><code>mkdir test</code></p>
<p>如果要创建的文件夹的父目录不存在，要使用<code>-p</code>参数，这个参数控制mkdir当发现目标目录的父级目录不存在的时候会递归的创建：</p>
<p><code>mkdir -p test/child-test</code></p>
<h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p><code>ls</code>是 <code>list</code> 的缩写，查看当前目录下所有文件，如果要查看更完善的信息，还可以使用<code>ls -l</code>。<code>-l</code>是<code>ls</code>指令的可选参数。</p>
<h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p><code>rm</code>是 <code>remove</code> 的缩写，用于删除一个文件或文件夹。</p>
<p>删除文件:</p>
<p><code>rm test.txt</code></p>
<p>删除文件夹，要加<code>-r</code>参数，代表递归删除的意思：</p>
<p><code>rm -r test</code></p>
<h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p><code>cat</code>指令将文件连接到标准输出流并打印到屏幕上。但是<code>cat</code>不适合用来打印输出大文件。</p>
<h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><p><code>more</code>可以帮助我们分页读取文件。</p>
<h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><p>和<code>more</code>差不多，但是可以向上翻页。</p>
<h4 id="head-tail"><a href="#head-tail" class="headerlink" title="head/tail"></a>head/tail</h4><p><code>head</code>和<code>tail</code>是一组，它们用来读取一个文件的头部 N 行或者尾部 N 行。</p>
<p><code>tail -f</code></p>
<p><code>-f</code>是 <code>follow</code> 的意思，就是文件追加的内容会跟随输出到标准输出流。</p>
<h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><ul>
<li><p><code>g</code> 就是 <code>global</code>，全局；</p>
</li>
<li><p><code>re</code> 就是 <code>regular expression</code>，正则表达式；</p>
</li>
<li><p><code>p</code>就是 <code>pattern</code>模式。</p>
</li>
</ul>
<h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><p>可以查询一个指令文件所在的位置。</p>
<p><code>which go</code>会打印<code>/usr/bin/go</code></p>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p><code>find </code>指令帮助我们在文件系统中查找文件。</p>
<p>可以使用<code>find / -iname &quot;*.txt&quot;</code>，<code>/</code>是路径，<code>-iname</code>这个参数是用来匹配查找的，<code>i</code> 字母代表忽略大小写，这里也可以用<code>-name</code>替代<br><br></p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>应用的可执行文件是放在文件系统里，启动可执行文件，就会在操作系统里（具体来说是内存中）形成一个<strong>应用的副本</strong>，这个副本就是进程。</p>
<blockquote>
<p>什么是进程(进程的定义是什么)？</p>
<p>进程就是应用的执行副本。</p>
<p>进程的作用是什么？</p>
<p>进程是操作系统分配资源的最小单位。</p>
</blockquote>
<h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p><code>p</code>代表<code>process</code>，<code>s</code>代表<code>snapshot</code>。</p>
<p>使用此命令可以查看当前的进程。</p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/ps.png"></p>
<p>如图有两个进程：</p>
<ul>
<li><code>zsh</code>是打开了这个控制台，执行<code>shell</code>的是<code>zsh</code>。</li>
<li><code>ps</code>是使用<code>ps</code>命令启动时，被<code>ps</code>自己捕捉到。</li>
</ul>
<blockquote>
<p>什么是TTY？</p>
<p>操作系统上的 TTY 是一个输入输出终端的概念，比如用户打开<code>bash</code>，操作系统就为用户分配了一个输入输出终端。</p>
</blockquote>
<p>使用<code>-e</code>可以查看操作系统的所有进程， 使用<code>-f</code>可以显示更多的描述字段。如图：</p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/ps-ef.png"></p>
<p>描述字段：</p>
<ul>
<li>UID：指进程的所有者。</li>
<li>PID：进程的唯一标识。</li>
<li>PPID：父进程的唯一标识。</li>
<li>C：CPU占用。</li>
<li>STIME：开始时间。</li>
<li>TTY：进程所在的TTY，没有就是问号。</li>
<li>CMD：进程启动时的命令。如果是方括号括起来的，那就是系统进程或内核进程。</li>
</ul>
<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>和<code>ps</code>的区别是，<code>top</code>显示实时数据而不是快照。</p>
<h4 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h4><p>比<code>top</code>更强大的一个非自带的工具，需要自己安装。<br><br></p>
<h4 id="管道-Pipeline"><a href="#管道-Pipeline" class="headerlink" title="管道(Pipeline)"></a>管道(Pipeline)</h4><p><font color="red">管道的作用是在命令和命令之间传递数据，更准确的说是在进程和进程之间传递数据。</font></p>
<h5 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h5><p>每个进程拥有自己的标准输入流，标准输出流，标准错误流。</p>
<ul>
<li>标准输入流：用0表示，可以作为进程执行的上下文，进程执行可以从输入流中获取数据。</li>
<li>标准输出流：用1表示，标准输出流的写入结果会被打印到屏幕上。</li>
<li>标准错误流：如果进程在执行过程中发生异常，那么异常信息会被记录到标准错误流中。</li>
</ul>
<h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><ul>
<li><code>&gt;</code> ：覆盖重定向</li>
<li><code>&gt;&gt;</code>：追加重定向</li>
</ul>
<p><code>ls -l</code>，结果会写入标准输出流，进而被打印，如图：</p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/ls-l.png"></p>
<p><code>ls -l &gt; out</code> 会把上图的内容存入到<code>out</code>文件，不会在屏幕上打印。</p>
<p><code>ls -l &gt;&gt; out</code> 会把上图的内容追加存入到<code>out</code>文件，不会在屏幕上打印。<br><br></p>
<h4 id="管道的作用和分类"><a href="#管道的作用和分类" class="headerlink" title="管道的作用和分类"></a>管道的作用和分类</h4><p>管道和重定向很像，但是管道是一个连接一个进行计算，重定向是将一个文件的内容定向到另一个文件，这二者经常会结合使用。</p>
<p>有两种类型的管道：</p>
<ul>
<li>匿名管道：这种管道也在文件系统中，但是它只是一个存储节点，不属于任何一个目录。说白了，就是没有路径。</li>
<li>命令管道：这种管道就是一个文件，有自己的路径。</li>
</ul>
<p>管道具有FIFO（先进先出）的特性。<br><br></p>
<h4 id="管道的使用场景"><a href="#管道的使用场景" class="headerlink" title="管道的使用场景"></a>管道的使用场景</h4><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p><code>ls | sort -r</code>   <code>-r</code>表示倒序，按照文件名称倒序排列显示。</p>
<h5 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h5><p><code>sort a.txt | uniq</code>，先排序，再将排序结果去重。</p>
<h5 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h5><p><code>find ./ | grep Spring</code>。<code>find ./</code> 递归列出当前目录下的文件，<code>grep</code>从输出流中找出包含<code>Spring</code>关键字的行。</p>
<p><code>find ./ | grep Spring | grep -v MyBatis</code>。<code>grep -v MyBatis</code>代表不包含 <code>MyBatis</code>关键字。</p>
<h5 id="数行数"><a href="#数行数" class="headerlink" title="数行数"></a>数行数</h5><p><code>find ./ -iname &quot;*.js&quot; | wc -l</code></p>
<p>找到<code>./</code>路径下，所有<code>js</code>文件，然后统计行数。</p>
<h5 id="中间结果"><a href="#中间结果" class="headerlink" title="中间结果"></a>中间结果</h5><p><code>find ./ -iname &quot;*.js&quot; | tee jslist | grep test</code></p>
<p>找到<code>./</code>路径下，所有<code>js</code>文件，然后存入<code>jslist</code>文件，然后筛选有关键字<code>grep</code>的文件，打印到控制台。</p>
<p><code>tee</code>这个执行就像英文字母中的 T 一样，连通管道两端，下面又开了口。这个开口，在函数式编程里面叫作副作用。</p>
<h5 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h5><p><code>xargs</code>指令从标准数据流中构造并执行一行行的指令。</p>
<p><code>ls | grep jslist  | xargs -I gg mv gg prefix_gg</code></p>
<p>将包含<code>jslist</code>关键字的文件加上<code>prefix</code>前缀，如图：</p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/xargsmvggprefix.png"></p>
<h5 id="管道文件"><a href="#管道文件" class="headerlink" title="管道文件"></a>管道文件</h5><p>上文中说管道有匿名管道和命名管道，匿名管道通过<code>|</code>就可以创造和使用。</p>
<p>而命名管道是要挂到文件夹中的，因此需要创建。</p>
<p>用<code>mkfifo</code>指令可以创建一个命名管道，如图：</p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/mkfifopipe11.png"></p>
<blockquote>
<p>根据一个IP地址列表，逐个ping这些ip，并收集每个IP的延迟等。</p>
<p>cat iplist | xargs -n1  ping -c2 &gt; pinglistres</p>
</blockquote>
<br>

<h4 id="用户和权限"><a href="#用户和权限" class="headerlink" title="用户和权限"></a>用户和权限</h4><h5 id="权限抽象"><a href="#权限抽象" class="headerlink" title="权限抽象"></a>权限抽象</h5><p>用户和用户组</p>
<ul>
<li><p>linux将用户抽象为账户，账户可以登录系统。</p>
</li>
<li><p>linux支持组，每个用户可以在多个组，可以利用组给用户快速分配权限。</p>
</li>
<li><p>root账户也叫超级管理员账户，他可以使用系统提供的全部能力。</p>
</li>
</ul>
<p>文件权限：</p>
<ul>
<li>读权限 <code>r</code></li>
<li>写权限<code>w</code></li>
<li>执行权限<code>x</code></li>
</ul>
<p>然后每个文件又可以从 3 个维度去配置上述的 3 种权限：</p>
<ul>
<li>用户维度。每个文件可以所属 1 个用户，用户维度配置的 rwx 在用户维度生效；</li>
<li>组维度。每个文件可以所属 1 个分组，组维度配置的 rwx 在组维度生效；</li>
<li>全部用户维度。设置对所有用户的权限。</li>
</ul>
<p>分析下面两个文件的权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drwxr-xr-x 5 root root    4096 12月 30 14:15 codespace</span><br><span class="line">-rw-r--r-- 1 root root      77 11月  8 13:36 dump.rdb</span><br></pre></td></tr></table></figure>

<ul>
<li>第一位 <code>-</code> 代表普通文件，<code>d</code>代表目录，<code>p</code>代表管道</li>
<li><code>rwx</code> 代表用户维度，这里是表示<code>codespace</code>的所属用户可以<strong>读写</strong>和<strong>执行</strong>这个文件。</li>
<li> <code>r-x</code> 代表用户组维度，这里表示<code>codespace</code>所属用户组里的所有用户可以<strong>读</strong>和<strong>执行</strong>这个文件。</li>
<li><code>r-x</code>代表所有用户可以<strong>读</strong>和<strong>执行</strong>这个<code>codespace</code>文件</li>
</ul>
<h5 id="初始权限问题"><a href="#初始权限问题" class="headerlink" title="初始权限问题"></a>初始权限问题</h5><p>一个文件创建后，文件的所属用户会被设置成创建文件的用户</p>
<p>linux中，每个用户创建时，会有一个同名的用户组也被创建，登录后，工作分组默认使用它的同名分组。</p>
<p>使用<code>newgrp</code>指令可以切换到另一个工作分组。</p>
<p>所以文件被创建后的权限通常是：<code>rw-rw-r--</code></p>
<h5 id="公共执行文件的权限"><a href="#公共执行文件的权限" class="headerlink" title="公共执行文件的权限"></a>公共执行文件的权限</h5><p>一个文件权限如果是可执行，但是不可读？那它也无法执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l /usr/bin/ls`</span><br><span class="line">-rwxr-xr-x 1 root root 117608 8月  20 2019 /usr/bin/ls</span><br></pre></td></tr></table></figure>

<h5 id="用户分组指令"><a href="#用户分组指令" class="headerlink" title="用户分组指令"></a>用户分组指令</h5><p><strong>groups</strong></p>
<p>查看当前用户的分组</p>
<p><code>groups root</code>可以查看指定用户(root)的分组</p>
<p><strong>id</strong></p>
<p>查看当前用户信息</p>
<ul>
<li><p>uid 是用户 id</p>
</li>
<li><p>gid 是组 id</p>
</li>
<li><p>groups 后面是每个分组和分组的 id。对应<code>groups</code>查看到的分组</p>
</li>
</ul>
<p><strong>cat /etc/passwd</strong></p>
<p>查看所有用户</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/5A/53/CgqCHl91HIGAWXWVAACI9cgafaM295.png"></p>
<p><strong>创建用户</strong></p>
<p><code>sudo useradd foo </code></p>
<p><code>sudo</code>的意思是<code>superuser do</code>，这里表示使用超级管理员的身份去执行这条命令。</p>
<p><strong>创建分组</strong></p>
<p><code>sudo groupadd hello</code></p>
<p><strong>为用户增加次级分组</strong></p>
<p>组分为主要分组和次级分组。主要分组只有一个（默认创建的用户同名分组？），次级分组可以有多个。</p>
<p>使用<code>sudo usermode -a -G hello foo</code>把我们前面创建的<code>foo</code>用户加入到<code>hello</code>分组中。</p>
<p><code>-a</code>代表append，<code>-G</code>代表一个次级分组的清单， 最后一个<code>foo</code>是账户名。</p>
<p>这时使用<code>groups foo</code>查看如图所示：</p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/groupsfoo.png">            </p>
<p><strong>修改用户的主要分组</strong></p>
<p><code>sudo usermod -g hello foo</code></p>
<h5 id="文件权限管理指令"><a href="#文件权限管理指令" class="headerlink" title="文件权限管理指令"></a>文件权限管理指令</h5><p><strong>查看</strong></p>
<p><code>ls -l</code></p>
<p><strong>修改文件权限</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置foo可以执行</span></span><br><span class="line">chmod +x ./foo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不允许foo执行</span></span><br><span class="line">chmod -x ./foo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以同时设置多个权限</span></span><br><span class="line">chmod +rwx ./foo</span><br></pre></td></tr></table></figure>

<p>因为<code>rwx</code>在 Linux 中用相邻的 3 个二进制位来表示:</p>
<p>第一组是用户权限，第二组是组权限，第三组是所有用户的权限。然后用<code>-</code>代表没有权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置rwxrwxrwx (111111111 -&gt; 777)</span></span><br><span class="line">chmod 777 ./foo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置rw-rw-rw-(110110110 -&gt; 666)</span></span><br><span class="line">chmod 666 ./foo</span><br></pre></td></tr></table></figure>

<ul>
<li><p> 第一位</p>
</li>
<li><p><code>-</code> 为普通文件：Linux中最多的一种文件类型, 包括 纯文本文件、二进制文件、数据格式的文件(data)、各种压缩文件。</p>
</li>
<li><p><code>d</code> 为目录文件：就是目录， 能用 <code>cd</code> 命令进入的。</p>
<ul>
<li><code>b</code> 为块设备文件：存储数据以供系统存取的接口设备，简单而言就是硬盘。例如一号硬盘的代码是<code> /dev/hda1</code>等文件。</li>
</ul>
</li>
<li><p><code>c</code> 为字符文件：串行端口的接口设备，例如键盘、鼠标等等。</p>
<ul>
<li><code>s</code>  为套接字文件：通常用在网络数据连接。可以启动一个程序来监听客户端的要求，客户端就可以通过套接字来进行数据通信，最常在 /var/run目录中看到这种文件类型。</li>
</ul>
</li>
<li><p><code>f</code>  为管道文件：FIFO也是一种特殊的文件类型，它主要的目的是，解决多个程序同时存取一个文件所造成的错误。FIFO是first-in-first-out(先进先出)的缩写。</p>
</li>
<li><p><code>l</code> 为链接文件：类似Windows下面的快捷方式。第一个属性为 [l]，例如 [lrwxrwxrwx]。</p>
</li>
<li><p><code>rwx</code></p>
<ul>
<li> <code>r</code> 是否可读。</li>
<li> <code>w</code> 是否可写。</li>
<li> <code>x</code> 是否可执行。</li>
</ul>
</li>
</ul>
<p><strong>修改文件所属用户</strong></p>
<p><code>chown foo iplist</code> 修改文件<code>iplist</code>的所属用户为<code>foo</code></p>
<p><code>chown foo.hello iplist</code>同时修改文件<code>iplist</code>的所属用户为<code>foo</code>，用户组为<code>hello</code></p>
<p>使用<code>ls -l iplist</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-rwxr--r-- 1 foo hello 25 1月   8 11:15 iplist</span><br></pre></td></tr></table></figure>
<br>

<p>####网络命令</p>
<h5 id="远程操作指令"><a href="#远程操作指令" class="headerlink" title="远程操作指令"></a>远程操作指令</h5><p><strong>ssh（Secure Shell）</strong></p>
<p><code>ssh user@ip</code></p>
<p>然后输入密码就可以登录进远程服务器。</p>
<p><strong>ifconfig</strong></p>
<p>查看本地IP以及本地有哪些网络接口</p>
<h5 id="查看本地网络状态"><a href="#查看本地网络状态" class="headerlink" title="查看本地网络状态"></a>查看本地网络状态</h5><p><strong>netstat</strong></p>
<p>不传任何参数的<code>netstat</code>帮助查询所有的本地 <code>socket</code>。</p>
<p><code>socket</code> 是网络插槽被抽象成了文件，负责在客户端、服务器之间收发数据。</p>
<p>查看TCP连接：</p>
<p><code>netstat -t</code></p>
<p>查看端口占用：</p>
<p><code>netstat -ntlp | grep 22</code></p>
<p><code>-n</code>是将一些特殊的端口号用数字显示，<code>-t</code>是指看 TCP 协议，<code>-l</code>是只显示连接中的连接，<code>-p</code>是显示程序名称。</p>
<h5 id="网络测试"><a href="#网络测试" class="headerlink" title="网络测试"></a>网络测试</h5><p><strong>ping</strong></p>
<p>查看本机到某个网站的网络延迟。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ ping www.baidu.com</span><br><span class="line">PING www.a.shifen.com (180.101.49.11) 56(84) bytes of data.</span><br><span class="line">64 bytes from 180.101.49.11 (180.101.49.11): icmp_seq=1 ttl=49 time=9.72 ms</span><br><span class="line">64 bytes from 180.101.49.11 (180.101.49.11): icmp_seq=2 ttl=49 time=9.59 ms</span><br><span class="line">64 bytes from 180.101.49.11 (180.101.49.11): icmp_seq=3 ttl=49 time=9.58 ms</span><br><span class="line">--- www.a.shifen.com ping statistics ---</span><br><span class="line">5 packets transmitted, 5 received, 0% packet loss, time 4005ms</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ping</code>一个网站需要使用 ICMP 协议。因此你可以在上图中看到 icmp 序号</li>
<li><code>ttl</code>叫作 time to live，是封包的生存时间。</li>
<li><code>time</code>是往返一次的时间。</li>
</ul>
<p><strong>telnet</strong></p>
<p>查看本机到某个 IP + 端口的网络是否通畅</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ telnet www.baidu.com 443</span><br><span class="line">Trying 180.101.49.12...</span><br><span class="line">Connected to www.baidu.com.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br></pre></td></tr></table></figure>

<h5 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h5><p><strong>host</strong></p>
<p>查询拉勾网的 DNS：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ host www.lagou.com</span><br><span class="line">www.lagou.com is an alias for lgmain.cdn.lagou.com.</span><br><span class="line">lgmain.cdn.lagou.com has address 117.50.36.103</span><br><span class="line">lgmain.cdn.lagou.com has address 106.75.118.232</span><br><span class="line">lgmain.cdn.lagou.com has address 117.50.39.99</span><br></pre></td></tr></table></figure>

<p><strong>dig</strong></p>
<p>显示的更加详细：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ dig www.lagou.com</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.11.4-P2-RedHat-9.11.4-26.P2.el7 &lt;&lt;&gt;&gt; www.lagou.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 63898</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 4, AUTHORITY: 0, ADDITIONAL: 0</span><br><span class="line"></span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.lagou.com.			IN	A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.lagou.com.		560	IN	CNAME	lgmain.cdn.lagou.com.</span><br><span class="line">lgmain.cdn.lagou.com.	60	IN	A	117.50.39.99</span><br><span class="line">lgmain.cdn.lagou.com.	60	IN	A	106.75.118.232</span><br><span class="line">lgmain.cdn.lagou.com.	60	IN	A	117.50.36.103</span><br><span class="line"></span><br><span class="line">;; Query time: 1 msec</span><br><span class="line">;; SERVER: 183.60.83.19#53(183.60.83.19)</span><br><span class="line">;; WHEN: 五 1月 08 18:20:27 CST 2021</span><br><span class="line">;; MSG SIZE  rcvd: 104</span><br></pre></td></tr></table></figure>

<h4 id="软件的安装"><a href="#软件的安装" class="headerlink" title="软件的安装"></a>软件的安装</h4><h5 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h5><p>yum是Python 开发的，提供的是rpm包，因此只有redhat系的 Linux，比如 Fedora，Centos 支持yum。yum的主要能力就是帮你解决下载和依赖两个问题。</p>
<h5 id="apt"><a href="#apt" class="headerlink" title="apt"></a>apt</h5><p><code>sudo apt remove vim</code> 删除vim</p>
<p><code>dpkg -l vim</code> vim 的状态从ii变成了rc，r是期望删除，c是实际上还有配置文件遗留</p>
<p><code>sudo apt purge vim</code> 可以彻底删除vim</p>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程和线程-1"><a href="#进程和线程-1" class="headerlink" title="进程和线程"></a>进程和线程</h3><ol>
<li>进程是软件的副本，是计算机分配资源的最小单位。</li>
<li>线程运行在进程里，线程是CPU调度的最小单位。</li>
</ol>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p><strong>原子操作</strong></p>
<p>原子操作就是操作不可分。在多线程环境，一个原子操作的执行过程无法被中断。</p>
<p><code>i++</code> 由 读取 i 的值、计算 i +1 、把新值赋给 i 。</p>
<p><strong>竞争条件</strong></p>
<p>两个线程并发执行i++</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/68/E8/CgqCHl-lBrSAKBmrAADNiS8bkAY490.png" alt="https://s0.lgstatic.com/i/image/M00/68/E8/CgqCHl-lBrSAKBmrAADNiS8bkAY490.png"></p>
<p>访问共享资源的程序片段我们称为临界区。</p>
<p><strong>cas 指令</strong></p>
<p>很多 CPU 都提供<code> Compare And Swap</code> 指令。这个指令的作用是更新一个内存地址的值，比如把i更新为i+1，但是这个指令明确要求使用者必须确定知道内存地址中的值是多少。</p>
<p><strong>tas 指令</strong></p>
<p><code>Test-And-Set</code> 指令（tas）。tas 指令的目标是设置一个内存地址的值为 1，它的工作原理和 cas 相似。</p>
<p><strong>锁</strong></p>
<p>锁（lock），目标是实现抢占（preempt）。就是只让给定数量的线程进入临界区。</p>
<p><strong>自旋锁</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lock</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">while</span>(!<span class="title function_">getLock</span>())&#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用一个<code>while</code>循环获取锁，直到锁被其它线程释放。这种情况线程不会主动释放资源，我们称为自旋锁。</p>
<ul>
<li>优点：不会发生线程切换，因为一直循环执行”空指令”。</li>
<li>缺点：比较消耗CPU资源，如果一直拿不到锁，就会一直执行。</li>
</ul>
<p><strong>生产者消费者模型</strong></p>
<p>Monitor 实现了生产者、消费者模型。</p>
<ul>
<li><p>如果一个线程拿到锁，那么这个线程继续执行；</p>
</li>
<li><p>如果一个线程竞争锁失败，Montior 就调用 wait 方法触发生产者的逻辑，把线程加入等待集合；</p>
</li>
<li><p>如果一个线程执行完成，Monitor 就调用一次 notify 方法恢复一个等待的线程。</p>
</li>
</ul>
<p><strong>分布式环境的锁</strong></p>
<p>类似 redis 的 setnx 、setex 等指令。。</p>
<p><strong>乐观锁</strong></p>
<p>类似git提交冲突，假设冲突不会发生，等到发生时再处理。而不是一开始就拒绝（悲观锁）。</p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><ul>
<li>先到先服务</li>
<li>短作业优先</li>
<li>优先级队列</li>
<li>抢占</li>
<li>多级队列模型</li>
</ul>
<h3 id="饥饿和死锁"><a href="#饥饿和死锁" class="headerlink" title="饥饿和死锁"></a>饥饿和死锁</h3><p>哲学家就餐问题：</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/6F/4A/CgqCHl-1AGWABRYZAACklm4__ZQ120.png" alt="11111.png"></p>
<p>死锁有 4 个基本条件。</p>
<ul>
<li><p>资源存在互斥逻辑：每次只有一个线程可以抢占到资源。这里是哲学家抢占叉子。</p>
</li>
<li><p>持有等待：这里哲学家会一直等待拿到叉子。</p>
</li>
<li><p>禁止抢占：如果拿不到资源一直会处于等待状态，而不会释放已经拥有的资源。</p>
</li>
<li><p>循环等待：这里哲学家们会循环等待彼此的叉子。</p>
</li>
</ul>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><ul>
<li>管道 ：管道的核心是不侵入、灵活，不会增加程序设计负担，又能组织复杂的计算过程。</li>
<li>本地内存共享：共享内存的方式，速度很快，但是程序不是很好写，因为这是一种侵入式的开发。只要不是高性能场景，进程间通信通常不考虑共享内存的方式。</li>
<li>本地消息/队列</li>
<li>远程调用（rpc）: RPC 真正的缺陷是增加了系统间的耦合。当系统主动调用另一个系统的方法时，就意味着在增加两个系统的耦合。长期增加 RPC 调用，会让系统的边界逐渐腐化。</li>
</ul>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="垃圾回收-gc"><a href="#垃圾回收-gc" class="headerlink" title="垃圾回收 gc"></a>垃圾回收 gc</h3><ul>
<li>引用计数算法（Reference Counter）</li>
<li>Root Tracing 算法</li>
<li>标记-清除（Mark Sweep）算法</li>
<li>三色标记-清除算法</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络与操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>golang踩坑记录</title>
    <url>/2020/12/13/golang%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>很久没发博客了，这个本来是记在有道云笔记上面的，分享一下吧。</p>
<p>力扣在坚持每天打卡，然后看一些书/教程/文档和网课。偶尔打两把游戏。。感觉时间不够用呐。。</p>
<p>learning is keeping</p>
<h4 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h4><p>conf在项目根目录下，关于go的路径读取还有很多问题，比如<code>go run</code>，和<code>go build</code>之后运行二进制文件的路径是不一样的。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">data, err := ioutil.ReadFile(<span class="string">&quot;conf/app.yaml&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="读取yaml文件"><a href="#读取yaml文件" class="headerlink" title="读取yaml文件"></a>读取yaml文件</h4><p>这里map读出来的都是<code>interface&#123;&#125;</code>类型，所以我通过断言转了一下，不知道有没有问题。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">data, err := ioutil.ReadFile(<span class="string">&quot;conf/app.yaml&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatalf(<span class="string">&quot;read config file app.yaml err: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">err = yaml.Unmarshal(data, m)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatalf(<span class="string">&quot;yaml.Unmarshal read error: %v &quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用断言，将interface&#123;&#125;转为string</span></span><br><span class="line">RunMode = m[<span class="string">&quot;RUN_MODE&quot;</span>].(<span class="type">string</span>)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="goland使用filewatcher，goimports下载失败"><a href="#goland使用filewatcher，goimports下载失败" class="headerlink" title="goland使用filewatcher，goimports下载失败"></a>goland使用filewatcher，goimports下载失败</h4><ol>
<li>设置代理，打开设置-&gt;搜索proxy-&gt;找到Http Proxy-&gt;设置Manual proxy configuration</li>
<li>检查连接 <code>check connection</code> (golang.org)</li>
<li>在goland的控制台运行，<code>go get golang.org/x/tools/cmd/goimports</code></li>
<li>再次进入filewatcher界面，添加<code>goimports</code></li>
</ol>
<h4 id="go-get命令的参数"><a href="#go-get命令的参数" class="headerlink" title="go get命令的参数"></a>go get命令的参数</h4><ul>
<li>-d 只下载不安装</li>
<li>-f 只有在你包含了 -u 参数的时候才有效，不让 -u 去验证 import 中的每一个都已经获取了，这对于本地 fork 的包特别有用</li>
<li>-fix 在获取源码之后先运行 fix，然后再去做其他的事情</li>
<li>-t 同时也下载需要为运行测试所需要的包</li>
<li>-u 强制使用网络去更新包和它的依赖包</li>
<li>-v 显示执行的命令</li>
</ul>
<h4 id="goland无法和vscode一样看提交历史和变更文件"><a href="#goland无法和vscode一样看提交历史和变更文件" class="headerlink" title="goland无法和vscode一样看提交历史和变更文件"></a>goland无法和vscode一样看提交历史和变更文件</h4><h5 id="和vscode一样看每行代码的提交信息"><a href="#和vscode一样看每行代码的提交信息" class="headerlink" title="和vscode一样看每行代码的提交信息"></a>和vscode一样看每行代码的提交信息</h5><p>下载插件<code>GitToolBox</code>即可，默认配置就支持，更多配置功能自己研究。</p>
<h5 id="和vscode一样看当前修改文件之类的。"><a href="#和vscode一样看当前修改文件之类的。" class="headerlink" title="和vscode一样看当前修改文件之类的。"></a>和vscode一样看当前修改文件之类的。</h5><p>打开设置-&gt;搜索<code>commit</code>，把<code>use non-modal commit interface</code>勾上-&gt;点击应用。你会看到左侧边栏出来了一个<code>commit</code>模块，点开就行。</p>
<h4 id="golang提前声明返回值"><a href="#golang提前声明返回值" class="headerlink" title="golang提前声明返回值"></a>golang提前声明返回值</h4><p>代码中，<code>(count int)</code>在函数末端显示声明的返回值变量，可以在函数中直接使用，并且不用显示返回，直接写<code>return</code>就可以了</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetTagTotal</span><span class="params">(maps <span class="keyword">interface</span>&#123;&#125;)</span></span> (count <span class="type">int</span>) &#123;</span><br><span class="line">	db.Model(&amp;Tag&#123;&#125;).Where(maps).Count(&amp;count)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gorm连接数据库报错"><a href="#gorm连接数据库报错" class="headerlink" title="gorm连接数据库报错"></a>gorm连接数据库报错</h4><p><code>unknown driver &quot;mysql&quot; (forgotten import?)</code>,字面意思就是没有引入<code>mysq</code>l包，按理说应该会自动引入的，但如果你没有直接使用这个包的方法，<code>gorm</code>包不会帮你引入这个包。坑啊<br>如果直接这样：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你使用了filewatcher里的go imports功能的话，一保存就会消失，所以要这样：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="time-Duration"><a href="#time-Duration" class="headerlink" title="time.Duration"></a>time.Duration</h4><p>一定要记住time.Duration的默认单位是纳秒。<br>我被这个坑了一两个小时</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	router := routers.InitRouter()</span><br><span class="line">	s := http.Server&#123;</span><br><span class="line">		Addr:           fmt.Sprintf(<span class="string">&quot;:%d&quot;</span>, setting.HttpPort),</span><br><span class="line">		Handler:        router,</span><br><span class="line">		ReadTimeout:    setting.ReadTimeOut,</span><br><span class="line">		WriteTimeout:   setting.WriteTimeOut,</span><br><span class="line">		MaxHeaderBytes: <span class="number">1</span> &lt;&lt; <span class="number">20</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	err := s.ListenAndServe()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;server start err: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码就是正常启动一个服务，我启动后一个调不通。<br>然后排查了很久发现是<code>ReadTimeout</code>和<code>WriteTimeout</code>的锅，我配置文件本意是配几千毫秒，但是<code>timeDuration</code>类型默认是纳秒，所以这个服务器的超时时间就是几千纳秒。。。</p>
<h4 id="golang-int转string"><a href="#golang-int转string" class="headerlink" title="golang []int转string"></a>golang []int转string</h4><p>在<code>js</code>可以通过<code>[1,2].join(&quot;,&quot;)</code>转换为<code>&quot;1,2&quot;</code></p>
<p>但是<code>golang</code>的<code>strings.Join()</code>只能把字符串数组转为字符串。。</p>
<p>所以我去<code>stackoverflow</code>上面找了一个转换的方法：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arrayToString</span><span class="params">(a []<span class="type">int</span>, delim <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> strings.Trim(strings.Replace(fmt.Sprint(a), <span class="string">&quot; &quot;</span>, delim, <span class="number">-1</span>), <span class="string">&quot;[]&quot;</span>)</span><br><span class="line">	<span class="comment">//return strings.Trim(strings.Join(strings.Split(fmt.Sprint(a), &quot; &quot;), delim), &quot;[]&quot;)</span></span><br><span class="line">	<span class="comment">//return strings.Trim(strings.Join(strings.Fields(fmt.Sprint(a)), delim), &quot;[]&quot;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="gin框架编写全局错误处理中间件"><a href="#gin框架编写全局错误处理中间件" class="headerlink" title="gin框架编写全局错误处理中间件"></a>gin框架编写全局错误处理中间件</h4><p>教程里都是微信小程序那种接口返回方式，无论成功失败都返回<code>200</code>，然后用自己定义的一个<code>json</code>格式里的<code>code</code>区分状态。</p>
<p>但我还是喜欢<code>Restful Api</code>的方式，所以我就去研究了一下怎么全局捕捉异常，就和<code>Node.js</code>一样。</p>
<ol>
<li>先去掉<code>gin.Recover</code>这个中间件</li>
<li>加上这样一个中间件，可能和百度搜到的gin的中间件写法不太一样，没有返回一个<br><code>gin.HandleFunc</code>,我猜这和中间件的执行顺序有关吧，没有细看，抽时间研究一下。</li>
</ol>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Recover</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">//打印错误堆栈信息</span></span><br><span class="line">			<span class="keyword">if</span> data, ok := r.(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;); ok &#123;</span><br><span class="line">				code := data[<span class="string">&quot;code&quot;</span>].(<span class="type">int</span>)</span><br><span class="line">				msg := data[<span class="string">&quot;msg&quot;</span>].(<span class="type">string</span>)</span><br><span class="line">				log.Printf(<span class="string">&quot;panic: %v\n&quot;</span>, r)</span><br><span class="line">				<span class="comment">//封装通用json返回</span></span><br><span class="line">				c.JSON(code, gin.H&#123;</span><br><span class="line">					<span class="string">&quot;msg&quot;</span>: msg,</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">&quot;panic: %v\n&quot;</span>, r)</span><br><span class="line">				<span class="comment">// 走到这里说明是未知错误，打印一下堆栈信息</span></span><br><span class="line">				debug.PrintStack()</span><br><span class="line">				c.JSON(http.StatusInternalServerError, gin.H&#123;</span><br><span class="line">					<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;服务器发生未知错误，请通知管理员!&quot;</span>,</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">//加载完 defer recover，继续后续接口调用</span></span><br><span class="line">	c.Next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用<code>panic(map[interface&#123;&#125;]interface&#123;&#125;)</code>这样抛出错误，就可以被捕获到，当然数据结构你可以自己定义。</li>
<li>然后里面有几个知识点，<code>r</code>是一个<code>map[interface&#123;&#125;]interface&#123;&#125;</code>,必须要使用断言才能从中读取值，参见<a href="https://stackoverflow.com/questions/25214036/getting-invalid-operation-mymaptitle-type-interface-does-not-support-in">https://stackoverflow.com/questions/25214036/getting-invalid-operation-mymaptitle-type-interface-does-not-support-in</a></li>
<li>然后<code>code := data[&quot;code&quot;].(int) msg := data[&quot;msg&quot;].(string)</code> 这种写法和前面读取yaml文件时说的一样，<code>interface&#123;&#125;</code>的类型要用断言转一下。参见<a href="https://stackoverflow.com/questions/18041334/convert-interface-to-int">https://stackoverflow.com/questions/18041334/convert-interface-to-int</a></li>
<li>ps: 反正你用空接口的时候，取值就尝试用断言去转一下类型，不然肯定取不到的。</li>
</ol>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>golang中的排序</title>
    <url>/2020/11/06/golang%E4%B8%AD%E7%9A%84%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>今天力扣每日一题是<a href="https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits/">根据数字二进制下 1 的数目排序</a>，题目本身是简单，但是我用<code>golang</code>实现的时候遇到了排序的问题。</p>
<h2 id="javascript的实现"><a href="#javascript的实现" class="headerlink" title="javascript的实现"></a>javascript的实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sortByBits = <span class="keyword">function</span> (<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> countBit = <span class="keyword">function</span> (<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (num % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        count++</span><br><span class="line">      &#125;</span><br><span class="line">      num = <span class="title class_">Math</span>.<span class="title function_">floor</span>(num / <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">countBit</span>(a) - <span class="title function_">countBit</span>(b) || a - b</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，js的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">sort</a>方法的参数是一个可以自定义的函数。</p>
<h2 id="golang的sort"><a href="#golang的sort" class="headerlink" title="golang的sort"></a>golang的sort</h2><p>golang有一个<a href="https://studygolang.com/pkgdoc">sort包</a>，提供了多种类型的排序方式，今天我这里只看<code>func Sort(data Interface)</code></p>
<p>它必须实现<code>sort.Interface</code>的三个方法:</p>
<span id="more"></span>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Len方法返回集合中的元素个数</span></span><br><span class="line">    Len() <span class="type">int</span></span><br><span class="line">    <span class="comment">// 如果 i 索引的数据小于 j 索引的数据，返回 true，且不会调用下面的 Swap()，即数据升序排序。</span></span><br><span class="line">    Less(i, j <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line">    <span class="comment">// Swap方法交换索引i和j的两个元素</span></span><br><span class="line">    Swap(i, j <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据官方文档的案例，一般情况下我们不需要修改<code>Len</code>和<code>Swap</code>方法，想要自定义排序规则达到<code>JavaScript</code>的<code>sort</code>方法哪种效果，需要修改<code>Less</code>方法。</p>
<p>官网有的东西我就不搬了，直接上代码看我怎么解决<code>bitcount</code>那道题的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Bits is</span></span><br><span class="line"><span class="keyword">type</span> Bits []<span class="type">int</span></span><br><span class="line"><span class="comment">// Len is</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Bits)</span></span> Len() <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(b) &#125; <span class="comment">// 基本不会变化</span></span><br><span class="line"><span class="comment">// Swap is</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Bits)</span></span> Swap(i, j <span class="type">int</span>) &#123; b[i], b[j] = b[j], b[i] &#125; <span class="comment">// 基本不会变化</span></span><br><span class="line"><span class="comment">// Less is</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Bits)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> bitCount(b[i]) &lt; bitCount(b[j]) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 如果b[i]的二进制1的数量小于b[j]的二进制1的数量，i应该在j前面，返回true</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> bitCount(b[i]) == bitCount(b[j]) &#123;</span><br><span class="line">		<span class="keyword">return</span> b[i] &lt; b[j] <span class="comment">// 如果二进制1的数量相等，i还是应该在j前面，返回true</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 否则返回false，调用Swap交换位置</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bitCount</span><span class="params">(num <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> num != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> num%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">			count++</span><br><span class="line">		&#125;</span><br><span class="line">		num = <span class="type">int</span>(math.Floor(<span class="type">float64</span>(num / <span class="number">2</span>)))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortByBits</span><span class="params">(arr []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	sort.Sort(Bits(arr))</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你需要数据需要降序而不是升序，你应该使用<code>func Reverse(data Interface) Interface</code>，而不是修改<code>Less</code>方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortByBits</span><span class="params">(arr []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	sort.Sort(sort.Reverse(Bits(arr)))</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>由浅入深吃透 Docker</title>
    <url>/2020/10/12/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%90%83%E9%80%8F-Docker/</url>
    <content><![CDATA[<p>上次在拉钩买的《重学数据结构与算法》感觉讲的还不错，又碰到Docker的课打折，就顺便买了。。</p>
<p>然后主要就是记记笔记整理一下别人的经验用法啥的，这些命令啥的搜都能搜得到。</p>
<p>课程的二维码在最后</p>
<h2 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h2><h3 id="Docekr安装"><a href="#Docekr安装" class="headerlink" title="Docekr安装"></a>Docekr安装</h3><p><a href="https://www.runoob.com/docker/macos-docker-install.html">菜鸟教程有各种环境安装docker的方法</a></p>
<h3 id="容器技术原理"><a href="#容器技术原理" class="headerlink" title="容器技术原理"></a>容器技术原理</h3><h4 id="chroot"><a href="#chroot" class="headerlink" title="chroot"></a>chroot</h4><blockquote>
<p>chroot 是在 Unix 和 Linux 系统的一个操作，针对正在运作的软件行程和它的子进程，改变它外显的根目录。一个运行在这个环境下，经由 chroot 设置根目录的程序，它不能够对这个指定根目录之外的文件进行访问动作，不能读取，也不能更改它的内容。</p>
</blockquote>
<h4 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h4><p>Docker 主要用到以下五种命名空间。</p>
<ul>
<li><p><code>pid namespace</code>：用于隔离进程 ID。</p>
<span id="more"></span></li>
<li><p><code>net namespace</code>：隔离网络接口，在虚拟的 net namespace 内用户可以拥有自己独立的 IP、路由、端口等。</p>
</li>
<li><p><code>mnt namespace</code>：文件系统挂载点隔离。</p>
</li>
<li><p><code>ipc namespace</code>：信号量,消息队列和共享内存的隔离。</p>
</li>
<li><p><code>uts namespace</code>：主机名和域名的隔离。</p>
</li>
</ul>
<h4 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h4><blockquote>
<p><code>Cgroups</code> 是一种 Linux 内核功能，可以限制和隔离进程的资源使用情况（CPU、内存、磁盘 I/O、网络等）。在容器的实现中，<code>Cgroups</code> 通常用来限制容器的 CPU 和内存等资源的使用。</p>
</blockquote>
<h4 id="联合文件系统"><a href="#联合文件系统" class="headerlink" title="联合文件系统"></a>联合文件系统</h4><blockquote>
<p>联合文件系统，又叫 <code>UnionFS</code>，是一种通过创建文件层进程操作的文件系统，因此，联合文件系统非常轻快。Docker 使用联合文件系统为容器提供构建层，使得容器可以实现写时复制以及镜像的分层构建和存储。常用的联合文件系统有 <code>AUFS</code>、<code>Overlay</code> 和 <code>Devicemapper</code> 等。</p>
</blockquote>
<h2 id="镜像、容器、仓库"><a href="#镜像、容器、仓库" class="headerlink" title="镜像、容器、仓库"></a>镜像、容器、仓库</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>镜像是一个只读的文件和文件夹的组合，是Docker容器启动的先决条件</p>
<ul>
<li>自己创建镜像（<code>Dockerfile</code>文件）</li>
<li>从镜像仓库拉去别人的镜像</li>
</ul>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>容器是镜像的运行实体</p>
<p>容器有初建、运行、停止、暂停和删除五种状态</p>
<h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>Docker的镜像仓库类似于代码仓库，用来存储和分发Docker镜像。</p>
<h3 id="Docker-重要组件"><a href="#Docker-重要组件" class="headerlink" title="Docker 重要组件"></a>Docker 重要组件</h3><p><img src="https://s0.lgstatic.com/i/image/M00/49/93/Ciqc1F9PYuuAQINxAAA236heaL0459.png"></p>
<ul>
<li><p><code>runC</code>是 Docker 官方按照 OCI 容器运行时标准的一个实现。通俗地讲，<code>runC</code> 是一个用来运行容器的轻量级工具，是真正用来运行容器的。</p>
</li>
<li><p><code>containerd</code>是 Docker 服务端的一个核心组件，它是从<code>dockerd</code>中剥离出来的 ，它的诞生完全遵循 OCI 标准，是容器标准化后的产物。<code>containerd</code>通过 <code>containerd-shim</code> 启动并管理 <code>runC</code>，可以说<code>containerd</code>真正管理了容器的生命周期。</p>
</li>
</ul>
<h2 id="配置镜像"><a href="#配置镜像" class="headerlink" title="配置镜像"></a>配置镜像</h2><h5 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h5><p><code>docker pull [Registry]/[Repository]/[Image]:[Tag]</code></p>
<h5 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h5><p><code>docker images ls</code> 查看所有镜像</p>
<p><code>docker images | grep busybox</code> 使用<code>grep</code>过滤</p>
<h5 id="重命名镜像"><a href="#重命名镜像" class="headerlink" title="重命名镜像"></a>重命名镜像</h5><p><code>docker tag [SOURCE_IMAGE][:TAG][TARGET_IMAGE][:TAG]</code></p>
<p><code>docker tag busybox:latest mybusybox:latest</code> 重命名镜像</p>
<p><code>busybox</code> 和 <code>mybusybox</code>的<code>IMAGE ID</code>相同，它们指向同一个镜像文件，只是别名不同</p>
<h5 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h5><p><code>docker rmi</code> / <code>docker image rm</code> </p>
<p><code>docker rmi mybusybox:latest</code> 删除<code>busybox</code>镜像</p>
<h5 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h5><h6 id="从运行中的容器提交镜像"><a href="#从运行中的容器提交镜像" class="headerlink" title="从运行中的容器提交镜像"></a>从运行中的容器提交镜像</h6><ol>
<li><code>docker run --rm --name=busybox -it busybox sh</code>创建一个容器</li>
<li>在容器中执行 ：<code>touch hello.txt &amp;&amp; echo &quot;I love Docker. &quot; &gt; hello.txt</code></li>
<li>新建窗口执行：<code>docker commit busybox busybox:hello</code></li>
<li>使用<code>docker image ls</code>查看会有两个版本不同的<code>busybox</code>镜像</li>
</ol>
<h6 id="使用Dockerfile生成镜像"><a href="#使用Dockerfile生成镜像" class="headerlink" title="使用Dockerfile生成镜像"></a>使用<code>Dockerfile</code>生成镜像</h6><table>
<thead>
<tr>
<th><code>Dockerfile</code> 指令</th>
<th>指令简介</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td><code>Dockerfile</code> 除了注释第一行必须是 FROM ，FROM 后面跟镜像名称，代表我们要基于哪个基础镜像构建我们的容器。</td>
</tr>
<tr>
<td>RUN</td>
<td><code>RUN</code> 后面跟一个具体的命令，类似于<code>Linux</code> 命令行执行命令。</td>
</tr>
<tr>
<td>ADD</td>
<td>拷贝本机文件或者远程文件到镜像内</td>
</tr>
<tr>
<td>COPY</td>
<td>拷贝本机文件到镜像内</td>
</tr>
<tr>
<td>USER</td>
<td>指定容器启动的用户</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>容器的启动命令</td>
</tr>
<tr>
<td>CMD</td>
<td><code>CMD</code> 为 <code>ENTRYPOINT</code> 指令提供默认参数，也可以单独使用 <code>CMD</code> 指定容器启动参数</td>
</tr>
<tr>
<td>ENV</td>
<td>指定容器运行时的环境变量，格式为<code> key=value</code></td>
</tr>
<tr>
<td>ARG</td>
<td>定义外部变量，构建镜像时可以使用 <code>build-arg =</code> 的格式传递参数用于构建</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>指定容器监听的端口，格式为<code> [port]/tcp</code> 或者 <code>[port]/udp</code></td>
</tr>
<tr>
<td>WORKDIR</td>
<td>为 <code>Dockerfile </code>中跟在其后的所有 <code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>、<code>COPY</code> 和 <code>ADD</code> 命令设置工作目录。</td>
</tr>
</tbody></table>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7</span> // 基于 centos:<span class="number">7</span> 这个镜像来构建自定义镜像。这里需要注意，每个 Dockerfile 的第一行除了注释都必须以 <span class="keyword">FROM</span> 开头。</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> nginx.repo /etc/yum.repos.d/nginx.repo  // 拷贝本地文件 nginx.repo 文件到容器内的 /etc/yum.repos.d 目录下。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install -y nginx // 在容器内运行yum install -y nginx命令，安装 nginx 服务到容器内，执行完第三行命令，容器内的 nginx 已经安装完成。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span> // 声明容器内业务（nginx）使用 <span class="number">80</span> 端口对外提供服务。</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> HOST=mynginx // 定义容器启动时的环境变量 HOST=mynginx，容器启动后可以获取到环境变量 HOST 的值为 mynginx。</span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>,<span class="string">&quot;-g&quot;</span>,<span class="string">&quot;daemon off;&quot;</span>] // 定义容器的启动命令，命令格式为 json 数组。这里设置了容器的启动命令为 nginx ，并且添加了 nginx 的启动参数 -g <span class="string">&#x27;daemon off;&#x27;</span> ，使得 nginx 以前台的方式启动。</span></span><br></pre></td></tr></table></figure>


<h2 id="容器-1"><a href="#容器-1" class="headerlink" title="容器"></a>容器</h2><h3 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h3><p>容器是基于镜像创建的可运行实例，并且单独存在，一个镜像可以创建多个容器。</p>
<h3 id="容器的生命周期"><a href="#容器的生命周期" class="headerlink" title="容器的生命周期"></a>容器的生命周期</h3><p><img src="https://s0.lgstatic.com/i/image/M00/55/BF/CgqCHl9qxcuANmQGAADHS_nfwJE810.png"></p>
<p>对容器来说，杀死容器中的主进程（1号进程），容器也会被杀死。</p>
<h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><h5 id="docker-attach"><a href="#docker-attach" class="headerlink" title="docker attach"></a><code>docker attach</code></h5><blockquote>
<p>使用docker attach 命令同时在多个终端运行时，所有的终端窗口将同步显示相同内容，当某个命令行窗口的命令阻塞时，其它命令行窗口同样也无法操作。    </p>
</blockquote>
<p>所以不推荐使用。</p>
<p><strong><code>docker exec</code></strong></p>
<p>使用<code>dokcer exec -it [name]/[id]</code></p>
<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><p>使用<code>docker rm</code>命令删除一个停止状态的容器。</p>
<p><code>docker rm busybox</code></p>
<p>删除正在运行中的容器，必须添加<code>-f / -force</code> 参数</p>
<p><code>docker rm -f busybox</code></p>
<h4 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h4><p>进入容器创建文件</p>
<p><code>docker exec -it busybox sh</code></p>
<p><code>cd /tmp &amp;&amp; touch test</code></p>
<p>执行导出命令</p>
<p><code>docker export busybox &gt; busybox.tar</code></p>
<h4 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h4><p>使用<code>docker import</code>命令导入上一步导出的容器</p>
<p><code>docker import busybox.tar busybox:test</code></p>
<p>使用<code>docker run</code> 启动并进入容器，查看上一步创建的临时文件</p>
<p><code>docker run -it busybox:test sh</code></p>
<p><code>cd /temp/ &amp;&amp; ls</code></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>镜像：</strong>镜像包含了容器运行所需要的文件系统结构和内容，是静态的只读文件。</p>
<p><strong>容器：</strong>容器是在镜像的只读层上创建了可写层，并且容器中的进程属于运行状态，容器是真正的应用载体。</p>
<p><strong>思考：</strong></p>
<p>容器文件系统为什么要设计成写时复制，而不是每一个容器都单独拷贝一份镜像文件？</p>
<blockquote>
<p>我觉得主要是为了节省磁盘空间吧。。</p>
</blockquote>
<h2 id="如何编写-Dockerfile"><a href="#如何编写-Dockerfile" class="headerlink" title="如何编写 Dockerfile"></a>如何编写 Dockerfile</h2><h3 id="Dockerfile书写原则"><a href="#Dockerfile书写原则" class="headerlink" title="Dockerfile书写原则"></a>Dockerfile书写原则</h3><ul>
<li><strong>单一职责</strong>：： 不同功能的应用应该尽量拆分成为不同的容器，每个容器只负责单一业务进程。</li>
<li><strong>提供注释信息</strong>： 晦涩难懂的代码尽量添加注释。</li>
<li><strong>保持容器最小化</strong>： 应该避免安装无用的软件包。</li>
<li><strong>合理选择基础镜像</strong>： 容器的核心是应用，只要基础镜像能够满足应用的运行环境即可。</li>
<li><strong>使用<code>.dockerignore</code>文件</strong>： 类似<code>.gitignore</code>，忽略掉一些不需要构建的文件。</li>
<li><strong>尽量使用构建缓存</strong></li>
<li><strong>正确设置时区</strong></li>
<li><strong>使用国内软件源加快镜像构建速度</strong></li>
<li><strong>最小化镜像层数</strong>： 尽可能减少<code>Dockerfile</code>指令行数，能合并的就合并。</li>
</ul>
<h3 id="指令书写建议"><a href="#指令书写建议" class="headerlink" title="指令书写建议"></a>指令书写建议</h3><h4 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h4><ul>
<li>当<code>RUN</code>指令后面跟的内容比较复杂时，建议使用反斜杠<code>（\）</code> 结尾并且换行</li>
<li><code>RUN</code>指令后面的内容尽量按照字母顺序排序，提高可读性</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install -y automake \</span></span><br><span class="line"><span class="language-bash">                   curl \</span></span><br><span class="line"><span class="language-bash">                   python \</span></span><br><span class="line"><span class="language-bash">                   vim</span></span><br></pre></td></tr></table></figure>


<h4 id="CMD-和-ENTRYPOINT"><a href="#CMD-和-ENTRYPOINT" class="headerlink" title="CMD 和 ENTRYPOINT"></a>CMD 和 ENTRYPOINT</h4><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ul>
<li><code>ENTRYPOINT</code>指令可以结合<code>CMD</code>指令使用，也可以单独使用，而<code>CMD</code>指令只能单独使用。</li>
<li><code>Dockerfile</code> 中如果使用了<code>ENTRYPOINT</code>指令，启动 <code>Docker</code> 容器时需要使用<code> --entrypoint</code> 参数才能覆盖 <code>Dockerfile</code> 中的<code>ENTRYPOINT</code>指令 ，而使用<code>CMD</code>设置的命令则可以被<code>docker run</code>后面的参数直接覆盖。</li>
</ul>
<p>如果你希望你的镜像足够灵活，推荐使用<code>CMD</code>指令。</p>
<p>如果你的镜像只执行单一的具体程序，并且不希望用户在执行<code>docker run</code>时覆盖默认程序，建议使用<code>ENTRYPOINT</code>。</p>
<p>无论使用CMD还是ENTRYPOINT，都尽量使用exec模式。</p>
<h4 id="ADD-和-COPY"><a href="#ADD-和-COPY" class="headerlink" title="ADD 和 COPY"></a>ADD 和 COPY</h4><ul>
<li><p><code>ADD</code>支持更多文件来源类型，比如自动提取<code> tar</code> 包，并且可以支持源文件为<code> URL</code> 格式。</p>
</li>
<li><p><code>COPY</code>指令只支持基本的文件和文件夹拷贝功能</p>
</li>
</ul>
<p>但是不推荐使用<code>ADD</code> 向容器中添加<code>URL</code>文件:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> http://pyropus.ca/software/memtester/old-versions/memtester-4.3.0.tar.gz /tmp/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> tar -xvf /tmp/memtester-4.3.0.tar.gz -C /tmp</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make -C /tmp/memtester-4.3.0 &amp;&amp; make -C /tmp/memtester-4.3.0 install</span></span><br></pre></td></tr></table></figure>

<p>应该这样写:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O /tmp/memtester-4.3.0.tar.gz http://pyropus.ca/software/memtester/old-versions/memtester-4.3.0.tar.gz \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; tar -xvf /tmp/memtester-4.3.0.tar.gz -C /tmp \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; make -C /tmp/memtester-4.3.0 &amp;&amp; make -C /tmp/memtester-4.3.0 install</span></span><br></pre></td></tr></table></figure>


<h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>为了使构建过程更加清晰明了，推荐使用 WORKDIR 来指定容器的工作路径</p>
<p>应该尽量避免使用 <code>RUN cd /work/path &amp;&amp; do some work</code>这样的指令。</p>
<h2 id="基于内核的弱隔离系统如何保障安全性"><a href="#基于内核的弱隔离系统如何保障安全性" class="headerlink" title="基于内核的弱隔离系统如何保障安全性"></a>基于内核的弱隔离系统如何保障安全性</h2><h3 id="Docker-与虚拟机区别"><a href="#Docker-与虚拟机区别" class="headerlink" title="Docker 与虚拟机区别"></a>Docker 与虚拟机区别</h3><p><img src="https://s0.lgstatic.com/i/image/M00/56/B7/Ciqc1F9sDDSAQhNcAAD8rL1NLXc02.jpeg"></p>
<p>###常用解决方案</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/51/28/Ciqc1F9keVSAHuDTAADaB11MKbU710.png"></p>
<h2 id="资源隔离"><a href="#资源隔离" class="headerlink" title="资源隔离"></a>资源隔离</h2><h3 id="什么是Namespace"><a href="#什么是Namespace" class="headerlink" title="什么是Namespace"></a>什么是Namespace</h3><p>Namespace 是 Linux 内核的一个特性，该特性可以实现在同一主机系统中，对进程 ID、主机名、用户 ID、文件名、网络和进程间通信等资源的隔离。Docker 利用 Linux 内核的 Namespace 特性，实现了每个容器的资源相互隔离，从而保证容器内部只能访问到自己 Namespace 的资源。</p>
<h3 id="Docker使用的各Namespace的作用"><a href="#Docker使用的各Namespace的作用" class="headerlink" title="Docker使用的各Namespace的作用"></a>Docker使用的各Namespace的作用</h3><h4 id="Mount-Namespace"><a href="#Mount-Namespace" class="headerlink" title="Mount  Namespace"></a>Mount  Namespace</h4><p>隔离不同进程或进程组看到的挂载点，实现容器内只能看到自己的挂载信息，在容器内的挂载操作不会影响到主机目录。</p>
<p>使用<code>unshare --mount --fork /bin/bash</code>命令可以新建<code>Mount Namespace</code>。</p>
<h3 id="Pid-Namespace"><a href="#Pid-Namespace" class="headerlink" title="Pid Namespace"></a>Pid Namespace</h3><p>用于隔离进程</p>
<p>使用<code>unshare --pid --fork --mount-proc /bin/bash</code></p>
<h3 id="UTS-Namespace"><a href="#UTS-Namespace" class="headerlink" title="UTS Namespace"></a>UTS Namespace</h3><p>用于隔离主机名</p>
<p>使用<code>unshare --mount --fork /bin/bash</code></p>
<p>使用<code>hostname</code>命令查看主机名</p>
<h3 id="IPC-Namespace"><a href="#IPC-Namespace" class="headerlink" title="IPC Namespace"></a>IPC Namespace</h3><p>IPC Namespace 主要是用来隔离进程间通信的。</p>
<p>PID Namespace 和 IPC Namespace 一起使用可以实现同一 IPC Namespace 内的进程彼此可以通信，不同 IPC Namespace 的进程却不能通信。</p>
<p>使用<code>unshare --ipc --fork /bin/bash</code> </p>
<h3 id="User-Namespace"><a href="#User-Namespace" class="headerlink" title="User Namespace"></a>User Namespace</h3><p>用来隔离用户和用户组。</p>
<p>以非 root 用户运行的进程可以在一个单独的 User Namespace 中映射成 root 用户。使用 User Namespace 可以实现进程在容器内拥有 root 权限，而在主机上却只是普通用户。</p>
<p>使用<code>unshare --user -r /bin/bash</code></p>
<h3 id="Net-Namespace"><a href="#Net-Namespace" class="headerlink" title="Net Namespace"></a>Net Namespace</h3><p>用来隔离网络设备、IP 地址和端口等信息。</p>
<p><code>Net Namespace</code> 可以让每个进程拥有自己独立的 IP 地址，端口和网卡信息。例如主机 IP 地址为 172.16.4.1 ，容器内可以设置独立的 IP 地址为 192.168.1.1。</p>
<p>ps: Namespace中没有进程时会自动删除，无需手动删除。如果 namespace 对应的文件某个应用程序打开，那么该 namespace 是不会被删除的，这个特性可以让我们保持住某个 namespace，以便后面往里面添加进程。</p>
<p>##资源限制</p>
<p>使用<code>Namespace</code>技术可以实现容器中的进程看不到别的容器的资源。<strong>但是容器内的进程仍然可以自由使用主机的<code>CPU</code>、内存等资源</strong>。</p>
<p>所以我们要使用<code>cgroups</code>来限制容器的资源使用。</p>
<h3 id="什么是cgroups"><a href="#什么是cgroups" class="headerlink" title="什么是cgroups"></a>什么是cgroups</h3><p><code>cgroups</code>（全称：<code>control groups</code>）是 <code>Linux</code>内核的一个功能，它可以实现限制进程或者进程组的资源（如 <code>CPU</code>、内存、<code>磁盘 IO</code> 等）。</p>
<h4 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h4><ul>
<li>资源限制： 限制资源的使用量</li>
<li>优先级控制：不同组可以有不同的资源使用优先级</li>
<li>审计：计算控制组的资源使用情况</li>
<li>控制：控制进程的恢复和挂起</li>
</ul>
<h4 id="核心概念："><a href="#核心概念：" class="headerlink" title="核心概念："></a>核心概念：</h4><ul>
<li>子系统（subsystem）：一个子系统代表一类资源调度控制器，例如，内存子系统可以限制内存使用量，cpu子系统可以限制cpu的使用时间等。</li>
<li>控制组（cgroup）：表示一组进程和一组带有参数的子系统的关联关系。</li>
<li>层技术（hierarchy）：是由一系列的控制组按照树状结构排列组成的，子控制组默认拥有父控制组的属性。</li>
</ul>
<h3 id="Docker是如何使用cgroups的"><a href="#Docker是如何使用cgroups的" class="headerlink" title="Docker是如何使用cgroups的"></a>Docker是如何使用cgroups的</h3><p>首先，使用如下命令，创建一个限制内存为<code>1G</code>的容器</p>
<p><code>docker run -it -m=1g nginx</code></p>
<p>查看文件目录</p>
<p><code>ls -l /sys/fs/cgroup/memory</code></p>
<p>进入docker目录</p>
<p><code>cd /sys/fs/cgroup/memory/docker</code></p>
<p>有一个名为容器id的文件夹</p>
<p><code>cat e3b99e0851f3a732e9a4a894a3137282c0ee421c24bf1275042d9437a122c9c4/memory.limit_in_bytes</code></p>
<p>显示<code>1073741824</code></p>
<p>请注意 cgroups 虽然可以实现资源的限制，但是不能保证资源的使用。例如，cgroups 限制某个容器最多使用 1 核 CPU，但不保证总是能使用到 1 核 CPU，当 CPU 资源发生竞争时，可能会导致实际使用的 CPU 资源产生竞争。</p>
<h2 id="组件组成"><a href="#组件组成" class="headerlink" title="组件组成"></a>组件组成</h2><p>Docker 整体架构采用 C/S（客户端 / 服务器）模式，主要由客户端和服务端两大部分组成。客户端负责发送操作指令，服务端负责接收和处理指令。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/56/40/CgqCHl9rFtSAPGOeAADIK4E6wrc522.png"></p>
<h3 id="Docker组件剖析"><a href="#Docker组件剖析" class="headerlink" title="Docker组件剖析"></a>Docker组件剖析</h3><h4 id="Docker相关组件"><a href="#Docker相关组件" class="headerlink" title="Docker相关组件"></a>Docker相关组件</h4><h5 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h5><p><code>docker</code> 是 <code>Docker</code> 客户端的一个完整实现。用户可以通过<code>docker</code>命令完成所有的与服务端的通信。</p>
<h5 id="dockerd"><a href="#dockerd" class="headerlink" title="dockerd"></a>dockerd</h5><p><code>dockerd</code> 是 <code>Docker</code> 服务端的后台常驻进程，用来接收客户端发送的请求，执行具体的处理任务，处理完成后将结果返回给客户端。</p>
<h5 id="docker-init"><a href="#docker-init" class="headerlink" title="docker-init"></a>docker-init</h5><p>在执行 <code>docker run</code> 启动容器时可以添加 <code>--init</code> 参数，此时 <code>Docker</code> 会使用 <code>docker-init</code> 作为<code>1</code>号进程，帮你管理容器内子进程，例如回收僵尸进程等。</p>
<h5 id="docker-proxy"><a href="#docker-proxy" class="headerlink" title="docker-proxy"></a>docker-proxy</h5><p><code>docker-proxy</code> 主要是用来做端口映射的。当我们使用 <code>docker run</code> 命令启动容器时，如果使用了<code> -p</code> 参数，<code>docker-proxy</code> 组件就会把容器内相应的端口映射到主机上来，底层是依赖于 <code>iptables</code> 实现的。</p>
<h4 id="containerd相关组件"><a href="#containerd相关组件" class="headerlink" title="containerd相关组件"></a>containerd相关组件</h4><h5 id="containerd"><a href="#containerd" class="headerlink" title="containerd"></a>containerd</h5><p><code>containerd</code> 组件是从 <code>Docker 1.11</code> 版本正式从 <code>dockerd</code>中剥离出来的，它的诞生完全遵循 <code>OCI</code> 标准，是容器标准化后的产物。<code>containerd</code> 完全遵循了 <code>OCI</code> 标准，并且是完全社区化运营的，因此被容器界广泛采用。</p>
<p><code>containerd</code> 不仅负责容器生命周期的管理，同时还负责一些其他的功能：</p>
<ul>
<li><p>镜像的管理，例如容器运行前从镜像仓库拉取镜像到本地；</p>
</li>
<li><p>接收 <code>dockerd</code> 的请求，通过适当的参数调用 <code>runc</code> 启动容器；</p>
</li>
<li><p>管理存储相关资源；</p>
</li>
<li><p>管理网络相关资源。</p>
</li>
</ul>
<p><code>containerd</code> 包含一个后台常驻进程，默认的 <code>socket</code> 路径为 <code>/run/containerd/containerd.sock</code>，<code>dockerd</code> 通过<code> UNIX</code> 套接字向 <code>containerd</code> 发送请求，<code>containerd</code> 接收到请求后负责执行相关的动作并把执行结果返回给 <code>dockerd</code>。</p>
<p>如果你不想使用 <code>dockerd</code>，也可以直接使用 <code>containerd</code> 来管理容器，由于 <code>containerd</code> 更加简单和轻量，生产环境中越来越多的人开始直接使用 <code>containerd</code> 来管理容器。</p>
<h5 id="Containerd-shim"><a href="#Containerd-shim" class="headerlink" title="Containerd-shim"></a>Containerd-shim</h5><p><code>containerd-shim</code> 的意思是垫片，类似于拧螺丝时夹在螺丝和螺母之间的垫片。<code>containerd-shim</code> 的主要作用是将 <code>containerd</code> 和真正的容器进程解耦，使用 <code>containerd-shim</code> 作为容器进程的父进程，从而实现重启 <code>containerd</code> 不影响已经启动的容器进程。</p>
<h5 id="ctr"><a href="#ctr" class="headerlink" title="ctr"></a>ctr</h5><p><code>ctr</code> 实际上是 <code>containerd-ctr</code>，它是 <code>containerd</code> 的客户端，主要用来开发和调试，在没有<code>dockerd</code> 的环境中，<code>ctr</code> 可以充当 <code>docker</code> 客户端的部分角色，直接向 <code>containerd</code> 守护进程发送操作容器的请求。</p>
<h4 id="容器运行时组件runc"><a href="#容器运行时组件runc" class="headerlink" title="容器运行时组件runc"></a>容器运行时组件runc</h4><p><code>runc</code> 是一个标准的 <code>OCI</code> 容器运行时的实现，它是一个命令行工具，可以直接用来创建和运行容器。</p>
<p><code>containerd</code>也是通过runc来实际运行容器。</p>
<h6 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h6><p>准备容器运行时文件:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /home/centos</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 创建 runc 运行根目录</span></span></span><br><span class="line">mkdir runc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 导入 rootfs 镜像文件</span></span></span><br><span class="line">mkdir rootfs &amp;&amp; docker export $(docker create busybox) | tar -C rootfs -xvf -</span><br></pre></td></tr></table></figure>

<p>生成 runc config 文件:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runc spec</span><br></pre></td></tr></table></figure>

<p>启动<code>busybox</code>容器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runc run busybox</span><br></pre></td></tr></table></figure>

<p><strong>打开一个命令行窗口</strong>，可以使用 run list 命令看到刚才启动的容器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">run list</span><br><span class="line"></span><br><span class="line">ID          PID         STATUS      BUNDLE         CREATED                          OWNER</span><br><span class="line">busybox     4423        running     /home/centos   2020-11-08T09:44:02.694100454Z   root</span><br></pre></td></tr></table></figure>



<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="https://s0.lgstatic.com/i/image/M00/59/E6/Ciqc1F9y4vGAVzmAAADk1nlHpUA424.png"></p>
<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><h3 id="CNM"><a href="#CNM" class="headerlink" title="CNM"></a>CNM</h3><p>CNM (Container Network Model) 是 Docker 发布的容器网络标准，意在规范和指定容器网络发展标准，CNM 抽象了容器的网络接口 ，使得只要满足 CNM 接口的网络方案都可以接入到 Docker 容器网络，更好地满足了用户网络模型多样化的需求。</p>
<h4 id="CNM-定义的网络标准包含三个重要元素。"><a href="#CNM-定义的网络标准包含三个重要元素。" class="headerlink" title="CNM 定义的网络标准包含三个重要元素。"></a>CNM 定义的网络标准包含三个重要元素。</h4><ul>
<li><strong>沙箱（Sandbox）</strong>：沙箱代表了一系列网络堆栈的配置，其中包含路由信息、网络接口等网络资源的管理，沙箱的实现通常是 Linux 的 Net Namespace，但也可以通过其他技术来实现，比如 <a href="https://zh.wikipedia.org/wiki/FreeBSD_jail">FreeBSD jail</a> 等。</li>
<li><strong>接入点（Endpoint）</strong>：接入点将沙箱连接到网络中，代表容器的网络接口，接入点的实现通常是 Linux 的 veth 设备对。</li>
<li><strong>网络（Network</strong>）：网络是一组可以互相通信的接入点，它将多接入点组成一个子网，并且多个接入点之间可以相互通信。</li>
</ul>
<h3 id="Libnetwork"><a href="#Libnetwork" class="headerlink" title="Libnetwork"></a>Libnetwork</h3><p><code>Libnetwork</code> 是 <code>Docker</code> 启动容器时，用来为<code> Docker</code> 容器提供网络接入功能的插件，它可以让<code>Docker</code> 容器顺利接入网络，实现主机和容器网络的互通。下面，</p>
<h4 id="Libnetwork-常见网络模式"><a href="#Libnetwork-常见网络模式" class="headerlink" title="Libnetwork 常见网络模式"></a>Libnetwork 常见网络模式</h4><ul>
<li><p>null 空网络模式：可以帮助我们构建一个没有网络接入的容器环境，以保障数据安全。</p>
</li>
<li><p>bridge 桥接模式：可以打通容器与容器间网络通信的需求。</p>
</li>
<li><p>host 主机网络模式：可以让容器内的进程共享主机网络，从而监听或修改主机网络。</p>
</li>
<li><p>container 网络模式：可以将两个容器放在同一个网络命名空间内，让两个业务通过 localhost 即可实现访问。</p>
</li>
</ul>
<p><img src="https://s0.lgstatic.com/i/image/M00/59/ED/Ciqc1F9y8HGAaH1iAAClKDUq5FY736.png"></p>
<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><h3 id="Docker-卷的操作"><a href="#Docker-卷的操作" class="headerlink" title="Docker 卷的操作"></a>Docker 卷的操作</h3><p><img src="https://s0.lgstatic.com/i/image/M00/5C/50/Ciqc1F-BW1SAQEkaAACOwJuMTHI950.png"></p>
<h3 id="Docker-卷的实现原理"><a href="#Docker-卷的实现原理" class="headerlink" title="Docker 卷的实现原理"></a>Docker 卷的实现原理</h3><p><strong>镜像和容器的文件系统原理</strong>：</p>
<p>镜像是由多层文件系统组成的，当我们想要启动一个容器时，<code>Docker</code>会在镜像上层创建一个可读写层，容器中的文件都工作在这个读写层中，当容器删除时，与容器相关的工作文件将全部丢失。</p>
<p><strong>实例：</strong></p>
<p>创建一个名称为 <code>volume-data</code> 的卷：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume create volume-data</span><br></pre></td></tr></table></figure>

<p>使用 ls 命令查看一下<code>/var/lib/docker/volumes</code> 目录下的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l /var/lib/docker/volumes</span><br><span class="line"></span><br><span class="line">total 32</span><br><span class="line">drwxr-xr-x 3 root root  4096 Nov  1 20:47 356ebf74cf7f5b564995a889d98af7f9cfd7e40092ddb34758f9aaffd1e26730</span><br><span class="line">-rw------- 1 root root 32768 Nov  9 23:17 metadata.db</span><br><span class="line">drwxr-xr-x 3 root root  4096 Nov  9 23:17 volume-data</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后再看下 <code>volume-data</code>目录下有什么内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l /var/lib/docker/volumes/volume-data</span><br><span class="line"></span><br><span class="line">total 4</span><br><span class="line">drwxr-xr-x 2 root root 4096 Nov  9 23:17 _data</span><br></pre></td></tr></table></figure>

<p>启动一个容器，并且绑定<code>volume-data</code> 卷到容器内的 /data 目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --mount source=volume-data,target=/data busybox</span><br></pre></td></tr></table></figure>

<p>进入到容器的 <code>/data</code> 目录，创建一个 data.log 文件:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd data/</span><br><span class="line">touch data.log</span><br></pre></td></tr></table></figure>

<p>新打开一个命令行窗口，查看一下主机上的文件内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l /var/lib/docker/volumes/volume-data/_data</span><br><span class="line"></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov  9 23:52 data.log</span><br></pre></td></tr></table></figure>



<h2 id="文件存储驱动AUFS"><a href="#文件存储驱动AUFS" class="headerlink" title="文件存储驱动AUFS"></a>文件存储驱动AUFS</h2><h3 id="什么是联合文件系统"><a href="#什么是联合文件系统" class="headerlink" title="什么是联合文件系统"></a>什么是联合文件系统</h3><p>联合文件系统（Union File System）是一种分层的轻量级文件系统，它可以把多个目录内容联合挂载到同一目录下，从而形成一个单一的文件系统</p>
<p>联合文件系统是<code>Docker</code> 镜像和容器的基础，因为它可以使 <code>Docker</code> 可以把镜像做成分层的结构，从而使得镜像的每一层可以被共享。</p>
<h3 id="如何配置AUFS"><a href="#如何配置AUFS" class="headerlink" title="如何配置AUFS"></a>如何配置AUFS</h3><p>查看系统是否支持AUFS</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep aufs /proc/filessystems</span><br></pre></td></tr></table></figure>

<p>如果出现:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nodev aufs</span><br></pre></td></tr></table></figure>

<p>说明系统支持<code>AUFS</code>，一般<code>Ubuntu</code>和<code>Debian</code>操作系统下使用<code>AUFS</code>，<code>centos</code>系统需要单独安装<code>AUFS</code>模块。</p>
<p>当系统支持<code>AUFS</code>时，配置启动参数，在<code>/etc/docker</code>新建<code>daemon.json</code>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;storage-driver&quot;</span><span class="punctuation">:</span><span class="string">&quot;aufs&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>重启<code>docker</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>使用<code>docker info</code> 查看<code>Storage Driver</code>是否变为<code>aufs</code></p>
<h3 id="AUFS是如何存储文件的"><a href="#AUFS是如何存储文件的" class="headerlink" title="AUFS是如何存储文件的"></a>AUFS是如何存储文件的</h3><p>AUFS 是联合文件系统，意味着它在主机上使用多层目录存储，每一个目录在<code> AUFS</code> 中都叫作分支，而在<code>Docker</code> 中则称之为层<code>(layer)</code>，但最终呈现给用户的则是一个普通单层的文件系统，我们把多层以单一层的方式呈现出来的过程叫作联合挂载。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/5E/82/CgqCHl-GwcCAOu4aAABzKSlpRlI180.png"></p>
<h2 id="文件存储驱动Devicemapper"><a href="#文件存储驱动Devicemapper" class="headerlink" title="文件存储驱动Devicemapper"></a>文件存储驱动Devicemapper</h2><h3 id="什么是-Devicemapper"><a href="#什么是-Devicemapper" class="headerlink" title="什么是 Devicemapper"></a>什么是 Devicemapper</h3><p>Devicemapper 是 Linux 内核提供的框架，从 Linux 内核 2.6.9 版本开始引入，Devicemapper 与 AUFS 不同，AUFS 是一种文件系统，而Devicemapper 是一种映射块设备的技术框架。</p>
<h3 id="Devicemapper-的关键技术"><a href="#Devicemapper-的关键技术" class="headerlink" title="Devicemapper 的关键技术"></a>Devicemapper 的关键技术</h3><ul>
<li><p>用户空间负责配置具体的设备映射策略与相关的内核空间控制逻辑，例如逻辑设备 dm-a 如何与物理设备 sda 相关联，怎么建立逻辑设备和物理设备的映射关系等。</p>
</li>
<li><p>内核空间则负责用户空间配置的关联关系实现，例如当 IO 请求到达虚拟设备 dm-a 时，内核空间负责接管 IO 请求，然后处理和过滤这些 IO 请求并转发到具体的物理设备 sda 上。</p>
</li>
</ul>
<h3 id="Devicemapper-的工作机制主要围绕三个核心概念"><a href="#Devicemapper-的工作机制主要围绕三个核心概念" class="headerlink" title="Devicemapper 的工作机制主要围绕三个核心概念"></a>Devicemapper 的工作机制主要围绕三个核心概念</h3><ul>
<li>映射设备（mapped device）：即对外提供的逻辑设备，它是由 Devicemapper 模拟的一个虚拟设备，并不是真正存在于宿主机上的物理设备。</li>
<li>目标设备（target device）：目标设备是映射设备对应的物理设备或者物理设备的某一个逻辑分段，是真正存在于物理机上的设备。</li>
<li>映射表（map table）：映射表记录了映射设备到目标设备的映射关系，它记录了映射设备在目标设备的起始地址、范围和目标设备的类型等变量。</li>
</ul>
<p><img src="https://s0.lgstatic.com/i/image/M00/5E/87/CgqCHl-GyFOAG6TPAACE_8cMjoQ585.png"></p>
<h2 id="文件存储驱动OverlayFS"><a href="#文件存储驱动OverlayFS" class="headerlink" title="文件存储驱动OverlayFS"></a>文件存储驱动OverlayFS</h2><h3 id="使用-overlay2-的先决条件"><a href="#使用-overlay2-的先决条件" class="headerlink" title="使用 overlay2 的先决条件"></a>使用 overlay2 的先决条件</h3><ul>
<li><p>要想使用overlay2，Docker 版本必须高于 17.06.02。</p>
</li>
<li><p>如果你的操作系统是 RHEL 或 CentOS，Linux 内核版本必须使用 3.10.0-514 或者更高版本，其他 Linux 发行版的内核版本必须高于 4.0（例如 Ubuntu 或 Debian），你可以使用uname -a查看当前系统的内核版本。</p>
</li>
<li><p>overlay2最好搭配 xfs 文件系统使用，并且使用 xfs 作为底层文件系统时，d_type必须开启，可以使用以下命令验证 d_type 是否开启：</p>
</li>
</ul>
<h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><h3 id="编写-Docker-Compose-模板文件"><a href="#编写-Docker-Compose-模板文件" class="headerlink" title="编写 Docker Compose 模板文件"></a>编写 Docker Compose 模板文件</h3><p>在使用 <code>Docker Compose</code> 启动容器时， <code>Docker Compose</code> 会默认使用 <code>docker-compose.yml</code> 文件， <code>docker-compose.yml</code> 文件的格式为 <code>yaml</code>（类似于 <code>json</code>，一种标记语言）。</p>
<p><code>Docker Compose</code> 模板文件一共有三个版本：<code> v1</code>、<code>v2</code> 和 <code>v3</code>。目前最新的版本为 <code>v3</code>，也是功能最全面的一个版本，下面我主要围绕 <code>v3</code> 版本介绍一下如何编写 <code>Docker Compose</code> 文件。</p>
<p><code>Docker Compose</code> 文件主要分为三部分： services（服务）、networks（网络） 和 volumes（数据卷）:</p>
<ul>
<li><p><code>services</code>（服务）：服务定义了容器启动的各项配置，就像我们执行<code>docker run</code>命令时传递的容器启动的参数一样，指定了容器应该如何启动，例如容器的启动参数，容器的镜像和环境变量等。</p>
</li>
<li><p><code>networks</code>（网络）：网络定义了容器的网络配置，就像我们执行<code>docker network create</code>命令创建网络配置一样。</p>
</li>
<li><p><code>volumes</code>（数据卷）：数据卷定义了容器的卷配置，就像我们执行<code>docker volume create</code>命令创建数据卷一样。</p>
</li>
</ul>
<p>文件结构：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="comment">## ... 省略部分配置</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">frontend:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">db-data:</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-Docker-Compose-管理-WordPress"><a href="#使用-Docker-Compose-管理-WordPress" class="headerlink" title="使用 Docker Compose 管理 WordPress"></a>使用 Docker Compose 管理 WordPress</h3><p>创建项目目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /tmp/wordpress &amp;&amp; cd /tmp/wordpress</span><br></pre></td></tr></table></figure>

<p>创建 <code>docker-compose.yml</code> 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch docker-compose.yml</span><br></pre></td></tr></table></figure>

<p>编写：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">   <span class="attr">mysql:</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">     <span class="attr">volumes:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">mysql_data:/var/lib/mysql</span> <span class="comment">## 和主机中创建的卷对应起来</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">     <span class="attr">environment:</span></span><br><span class="line">       <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span></span><br><span class="line">       <span class="attr">MYSQL_DATABASE:</span> <span class="string">mywordpress</span></span><br><span class="line">       <span class="attr">MYSQL_USER:</span> <span class="string">mywordpress</span></span><br><span class="line">       <span class="attr">MYSQL_PASSWORD:</span> <span class="string">mywordpress</span></span><br><span class="line">   <span class="attr">wordpress:</span></span><br><span class="line">     <span class="attr">depends_on:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">wordpress:php7.4</span></span><br><span class="line">     <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">&quot;8080:80&quot;</span></span><br><span class="line">     <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">     <span class="attr">environment:</span></span><br><span class="line">       <span class="attr">WORDPRESS_DB_HOST:</span> <span class="string">mysql:3306</span></span><br><span class="line">       <span class="attr">WORDPRESS_DB_USER:</span> <span class="string">mywordpress</span></span><br><span class="line">       <span class="attr">WORDPRESS_DB_PASSWORD:</span> <span class="string">mywordpress</span></span><br><span class="line">       <span class="attr">WORDPRESS_DB_NAME:</span> <span class="string">mywordpress</span> </span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">    <span class="attr">mysql_data:</span> &#123;&#125; <span class="comment">## 在/var/lib/docker/volumes目录创建了一个wordpress_mysql_data</span></span><br></pre></td></tr></table></figure>

<p>启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<p>等待启动完成访问<code>localhost:8080</code>即可进入wordpress安装界面：</p>
<h2 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h2><p><strong>优点：</strong></p>
<ul>
<li><p>分布式： <code>Swarm</code> 使用<code>Raft</code>（一种分布式一致性协议）协议来做集群间数据一致性保障，使用多个容器节点组成管理集群，从而避免单点故障。</p>
</li>
<li><p>安全： <code>Swarm</code> 使用 <code>TLS</code> 双向认证来确保节点之间通信的安全，它可以利用双向 <code>TLS</code> 进行节点之间的身份认证，角色授权和加密传输，并且可以自动执行证书的颁发和更换。</p>
</li>
<li><p>简单： <code>Swarm</code> 的操作非常简单，并且除 <code>Docker</code> 外基本无其他外部依赖，而且从 <code>Docker 1.12</code> 版本后， <code>Swarm</code> 直接被内置到了 <code>Docker</code> 中，可以说真正做到了开箱即用。</p>
</li>
</ul>
<p><strong>架构</strong></p>
<p><img src="https://s0.lgstatic.com/i/image/M00/67/E1/CgqCHl-iZxSAbYhzAABiA3_fQM8971.png"></p>
<h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><h3 id="Kubernetes-架构"><a href="#Kubernetes-架构" class="headerlink" title="Kubernetes 架构"></a>Kubernetes 架构</h3><p><code>Kubernetes</code> 采用典型的主从架构，分为 <code>Master</code> 和 <code>Node</code> 两个角色。</p>
<ul>
<li><p><code>Mater</code> 是 <code>Kubernetes</code> 集群的控制节点，负责整个集群的管理和控制功能。</p>
<ul>
<li><strong>kube-apiserver</strong>:<code>kube-apiserver</code> 的所有数据都存储在 <code>etcd</code> 中，<code>etcd</code> 是一种采用 Go 语言编写的高可用 Key-Value 数据库，由 CoreOS 开发</li>
<li><strong>kube-scheduler</strong></li>
<li><strong>kube-controller-manager</strong></li>
</ul>
</li>
<li><p><code>Node</code> 为工作节点，负责业务容器的生命周期管理。</p>
<ul>
<li><strong>kubelet</strong></li>
<li><strong>kube-proxy</strong></li>
</ul>
</li>
</ul>
<p><img src="https://s0.lgstatic.com/i/image/M00/68/D6/Ciqc1F-k_FqAdHbtAAFVTi8cyOE246.png" alt="image (1).png"></p>
<h3 id="Kubernetes-核心概念"><a href="#Kubernetes-核心概念" class="headerlink" title="Kubernetes 核心概念"></a>Kubernetes 核心概念</h3><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><p>集群是一组被 Kubernetes 统一管理和调度的节点，被 Kubernetes 纳管的节点可以是物理机或者虚拟机。集群其中一部分节点作为 Master 节点，负责集群状态的管理和协调，另一部分作为 Node 节点，负责执行具体的任务，实现用户服务的启停等功能。</p>
<h4 id="标签（Label）"><a href="#标签（Label）" class="headerlink" title="标签（Label）"></a>标签（Label）</h4><p>Label 是一组键值对，每一个资源对象都会拥有此字段。Kubernetes 中使用 Label 对资源进行标记，然后根据 Label 对资源进行分类和筛选。</p>
<h4 id="命名空间（Namespace）"><a href="#命名空间（Namespace）" class="headerlink" title="命名空间（Namespace）"></a>命名空间（Namespace）</h4><p>Kubernetes 中通过命名空间来实现资源的虚拟化隔离，将一组相关联的资源放到同一个命名空间内，避免不同租户的资源发生命名冲突，从逻辑上实现了多租户的资源隔离。</p>
<h4 id="容器组（Pod）"><a href="#容器组（Pod）" class="headerlink" title="容器组（Pod）"></a>容器组（Pod）</h4><p>Pod 是 Kubernetes 中的最小调度单位，它由一个或多个容器组成，一个 Pod 内的容器共享相同的网络命名空间和存储卷。Pod 是真正的业务进程的载体，在 Pod 运行前，Kubernetes 会先启动一个 Pause 容器开辟一个网络命名空间，完成网络和存储相关资源的初始化，然后再运行业务容器。</p>
<h4 id="部署（Deployment）"><a href="#部署（Deployment）" class="headerlink" title="部署（Deployment）"></a>部署（Deployment）</h4><p>Deployment 是一组 Pod 的抽象，通过 Deployment 控制器保障用户指定数量的容器副本正常运行，并且实现了滚动更新等高级功能，当我们需要更新业务版本时，Deployment 会按照我们指定策略自动的杀死旧版本的 Pod 并且启动新版本的 Pod。</p>
<h4 id="状态副本集（StatefulSet）"><a href="#状态副本集（StatefulSet）" class="headerlink" title="状态副本集（StatefulSet）"></a>状态副本集（StatefulSet）</h4><p>StatefulSet 和 Deployment 类似，也是一组 Pod 的抽象，但是 StatefulSet 主要用于有状态应用的管理，StatefulSet 生成的 Pod 名称是固定且有序的，确保每个 Pod 独一无二的身份标识。</p>
<h4 id="守护进程集（DaemonSet）"><a href="#守护进程集（DaemonSet）" class="headerlink" title="守护进程集（DaemonSet）"></a>守护进程集（DaemonSet）</h4><p>DaemonSet 确保每个 Node 节点上运行一个 Pod，当我们集群有新加入的 Node 节点时，Kubernetes 会自动帮助我们在新的节点上运行一个 Pod。一般用于日志采集，节点监控等场景。</p>
<h4 id="任务（Job）"><a href="#任务（Job）" class="headerlink" title="任务（Job）"></a>任务（Job）</h4><p>Job 可以帮助我们创建一个 Pod 并且保证 Pod 的正常退出，如果 Pod 运行过程中出现了错误，Job 控制器可以帮助我们创建新的 Pod，直到 Pod 执行成功或者达到指定重试次数。</p>
<h4 id="服务（Service）"><a href="#服务（Service）" class="headerlink" title="服务（Service）"></a>服务（Service）</h4><p>Service 是一组 Pod 访问配置的抽象。由于 Pod 的地址是动态变化的，我们不能直接通过 Pod 的 IP 去访问某个服务，Service 通过在主机上配置一定的网络规则，帮助我们实现通过一个固定的地址访问一组 Pod。</p>
<h4 id="配置集（ConfigMap）"><a href="#配置集（ConfigMap）" class="headerlink" title="配置集（ConfigMap）"></a>配置集（ConfigMap）</h4><p>ConfigMap 用于存放我们业务的配置信息，使用 Key-Value 的方式存放于 Kubernetes 中，使用 ConfigMap 可以帮助我们将配置数据和应用程序代码分开。</p>
<h4 id="加密字典（Secret）"><a href="#加密字典（Secret）" class="headerlink" title="加密字典（Secret）"></a>加密字典（Secret）</h4><p>Secret 用于存放我们业务的敏感配置信息，类似于 ConfigMap，使用 Key-Value 的方式存在于 Kubernetes 中，主要用于存放密码和证书等敏感信</p>
<p>ps: 看到后面就完全是读ppt了。。感觉讲的一般。</p>
<h2 id="课程二维码"><a href="#课程二维码" class="headerlink" title="课程二维码"></a>课程二维码</h2><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJQAAACUCAYAAAB1PADUAAAIqUlEQVR4Xu2dy24jMQwEk///6CywN48BFwrd8iPpXClRVLNEyuNJ8v3z8/PztZ8pUFLge0CVlJyb/woMqIFQVWBAVeWcswE1BqoKDKiqnHM2oMZAVYEBVZVzzgbUGKgqMKCqcs7ZgBoDVQUGVFXOORtQY6CqwICqyjlnA2oMVBUYUFU55ywG6vv7+6kqXl/fuq6fvt5l95PGQ/HbeNJkxPql70O9esOUECuw3c+AulV4FepC3IDKXuAdUAPqRoG3a3lpQNcW9eyWRvHbeOz40/s/7b9eoSgh6Z0m9U8tjfxbQOz40wk/7X9AXRQeUG92h6KErEK5hKUVjvRu+z9eoajFXDdsP4ZbQdJ4bIJO7y/dj9UP999+DkVAUEA039rpzmDjofGUYBs/JZzWS4Gm/d7pO6AeS2ZbOCV4QAGirz5BtP4q1K0CFug/V6H0huG7R6pIVIGoxRDgNuFpPPZAkt4ffymnDVICUwBofQvogLqceBLEJqB+glahblJQ1/fTL+UE6CrU7lDRCbInLh1PQFPFbrfE0/GQ/193h0oBsQkmgQcUKXSxUwKf/SmE4qEWOKDcV0O/7sFmG5AB9eZAyYJ3N5wqDtlp/XYFpfVsC0z3R/G0/R+/Q9GGyE4bJrv1T+MJiHQ++acKSuunFZ38Dyj5WzuUcBKc5ls7rUf29EA+/Q5FGyI7bZjs1j+Np4Sn88n/n6tQJGhqt4ITcJ9mT/Wj+Smw9ZZHAaf2AZUq+Hj+gJLfJX46kGdx+voaUAOqytjLgaru5gnO0udOaYh0Z0v9v3p+fId69Qbs+gPKKubGDyjQK20Bpx8kunSfHz2gBlSVshgouhOQnXZDLYoqiJ1P8ZK/635sfM8eT/ul/NxV4Ge/sUmCUYtIE0bzSeAB9RixVajLPzQdUG/++goliEoqVQSqeHY+xUv+qAJSBbb7ScfTfik/9ZZHAlFA6ZNrSmAbANpvuh+aT/slvUkPAhT9p3coEpgCIAHJTgKTgDSf4qcT3ra34039rUKVHxO0gUkPkD0AA0r+ouYq1C0ypMfHtzw6UXSCSCDyn1YEW6FoP3SFsPHSehQ/6fd2Lc8GnApqBbbjbXxUESjh9kBRfBQP5St+DkUnigKwdhLktD9an+wEKOlp/dN6BKzVc0DBg800IVRBqCJQwsl/Gv/HAUUnjgS3G7bj04RRxbHxkB4EoF3Pjn95hRpQLmUDCvQaUAPqoQJpi3h1yU5blK0gDif+JYJX61dveZQQW5EIUJtAWp8STPMpnlQfumRT/HZ97a/9XZ4NmE7UgHr8Dy4twDY/A+qiQAosVQTyTwmh+emBSten+XeArkK5f3G7lvcYsfgORSfMlljrz/qn8XQiqcVQ/GS38VE8p/3VK1Qq0LNPvBWYWh75S/fXbnltfwMK7lirUG/+TvnpE2z90/gB9WKgKAHUEqkEk3+6Q9j1rT8bH8VD/kgvip8OlJ1fb3lWALpTkL93v9NQfAPKZhjuKAPq9jGFrQirUPLvN1l+KSFUEchOLYLipQNE8dv1U392fr3l0Yk5LTgBQfG1E04A0HqkF9lTIMg/2esPNmnB9h1jQN0qOqDk3xZoVwCqGGmCUuDTA2rnp+NXoUKgKQEDihSSdrrDtFugDO+L4qMKlsafAne6gmo9n/22AQVICUwFpJZpAbHj7f4s8KQv7T/VN255tAESJE0IrU92io8ASONfhaIMXeyUsDQhMpy74RTfgHIK1ysUnTgX3v3o0/4pPgsgtRhaj+zUoiheOtC0/t3+2neo0wk/7Z8EpAS1E0zxtNcjfxTPKhQpJFs4JYSAlOHg/2ax61H8FN+AIoUGlFIoBopOABFPLYzsdEex6yv1CoPT+OhDg/VP42nLA0r+i1gS1NopgfbAnj6AtL8BNaBuGCHAB9TluzpqkSRY204J/HMVigSmEvxqwWx87TsL6UfrtZ8jUTxkj1seLhC+sUmC2hNu/aXApRWR4h1Qh/8EISWQEtS2Uzx0ICmeATWgiKGHl2R7RVCLFQbHLc9u8NXj6UTb+CgHtmWSP2unCkdXBrvegAorJgk+oEihi92e6FePX4XKfi+Q8FiFWoUiRpQ9BkqtdmAwVby0IlHIdEex69s7TXv/dv27T7Ht96EoAW17W1Ab34C6VWwVKvwub0ANqBsFbIWzLcyOty3Hxk8HwK5fb3l2Q7altBNC8caCwldNdwmQX021gaDHGjZfccujBNmAaHwqKMU7oF78F+woQQSItQ+o24SnFSadv5Yn/2exBd4miMandoqf/NP840ClLcPeMWjDJBhVWNqPnW/Hp/s7PX9AlZ+MW0Ds+NNA0IGj9QfUgHr42IQqMgFW/5SXBrSW5z5lpRUmnf/0CkUlvv2cKQWSBG7vh058ak8/Fdv1j1eodgJsBSRALIDt/diE2fEDqvwnCgdU97kVAb0KdVGIAFyFeozUrwMqTTiewPJ3b3SHtPHQ+HQ98j+g4DeL0zsW3WHSBNsDlK43oECB9iU/bZlpPJTwARW+DkICpwmkCkT2NMGrULJi2BOfAmITbOMjwGl9Aoj2n86n+D/+DkUJRQHCtw9ofUogxdeucBQPAUnxDqgBdcPIgJJ3LPrURi2H5tuKQife+iMgPr5CkWBkp5Zi5xMwqeA2XlqP4rWAk16p/XjLiwN8cgWiBNsKYMeTXtYfjaf1rH1AHX4/ihJKAK9CySfPdAJsC6EWQAmiBFtA7HjSw/qj8bSetdcrlA3Ajm9fUgnAdD06EM8G2O7X5mdAXRRrA9D21waC4htQFwVsySeBbUVp+xtQFnEYn7YgCqcNQNvfrweKEjT731IgvkP9Lbm2W1JgQJFCsysFBpSSa4NJgQFFCs2uFBhQSq4NJgUGFCk0u1JgQCm5NpgUGFCk0OxKgQGl5NpgUmBAkUKzKwUGlJJrg0mBAUUKza4UGFBKrg0mBQYUKTS7UmBAKbk2mBT4ByNU5vnY5EDJAAAAAElFTkSuQmCC"></p>
]]></content>
      <categories>
        <category>计算机网络与操作系统</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>0-1背包问题</title>
    <url>/2020/10/11/0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>今天<strong>LeetCode</strong>的每日一题是<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">分割等和子集</a>，这道题可以看成是一个<code>0-1背包问题</code>。</p>
<p>只是分享一下自己理解的过程，可能表述并不是很清楚，公式的推导就不说了，网上有很多很专业的文章。</p>
<br>

<h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><p>关于背包问题的定义，网上有很多。</p>
<p>举个列子：</p>
<blockquote>
<p>一个小偷拿了一个承重为10kg的背包去商店偷东西，有3种物品供他选择；第一种重1kg，价值6元；第二种重2kg价值10元；第三种重3kg，价值12元。不能重复拿同一种物品，请问小偷如何拿能获取最多的钱？</p>
</blockquote>
<p>我们可以使用一个 表格分析一下:</p>
<p>dp[i][j]表示在前<code>0~i</code>种物品中挑选，组成重量为<code>j</code>的组合，最大价值是多少</p>
<p>行代表可选择的物品(1、2、3)，列代表背包容量(kg)，行列相交的值代表可以获取的最大价值(元)</p>
<table>
<thead>
<tr>
<th>i\j</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>{1}  0</td>
<td>0</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
</tr>
<tr>
<td>{1,2}  1</td>
<td>0</td>
<td>6</td>
<td>10</td>
<td>16</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>{1,2,3}  2</td>
<td>0</td>
<td>6</td>
<td>10</td>
<td>12</td>
<td>18</td>
<td>22</td>
</tr>
</tbody></table>
<p>假设物品种类为<code>n</code>，背包重量为<code>target</code>，将表格转换为一个二维数组<code>dp</code>，</p>
<p>那么最大价值为 <code>dp[n-1][target] = 22</code></p>
<p><a href="https://github.com/ruomuc/practice/blob/master/algorithm/01backpack.js">代码实现</a></p>
<p><strong>分析：</strong></p>
<ul>
<li><p>i=0时：</p>
<ul>
<li>j = 0 ，<code>dp[0][0] = 0</code></li>
<li>j &gt; 0 ; <code>dp[0][j] = v[i]</code></li>
</ul>
</li>
<li><p>i &gt;0时，<code>j&gt;=w[i]</code>即背包容量大于<code>i</code>的重量：</p>
<ul>
<li><p>选取<code>i</code>，<code>dp[i][j] = v[i] + dp[i-1][j-w[i]]</code></p>
</li>
<li><p>不选<code>i</code>, <code>dp[i][j] = dp[i-1][j]</code></p>
</li>
</ul>
</li>
<li><p>取两种情况的较大值</p>
</li>
</ul>
<span id="more"></span>
<br>

<h2 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h2><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">题目描述</a></p>
<p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/fen-ge-deng-he-zi-ji-by-leetcode-solution/">官方题解</a></p>
<h4 id="理解分析："><a href="#理解分析：" class="headerlink" title="理解分析："></a>理解分析：</h4><p><a href="https://github.com/ruomuc/practice/blob/master/leet-code/canPartition.go">代码实现</a></p>
<table>
<thead>
<tr>
<th>i\j</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody><tr>
<td>(1)  0</td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>(5)  1</td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>(11)2</td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>(5)  3</td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>true</td>
<td>true</td>
</tr>
</tbody></table>
<ul>
<li>1、5、11、5的和是22，所以只要从中取出n个数之和等于11，说明可以被分割。</li>
<li><code>dp[i][j]</code>代表，0-i 的数，可以组和成等于 j ，就位true，不可以就为false。</li>
<li>最终结果就是 <code>dp[len-1][target]</code>。</li>
</ul>
<p>这里的代码实现，实际上只使用了一个一维数组，使空间复杂度降低，因为分析表格可以知道，<code>d[i][j]</code>的值之和<code>dp[i-1][j]</code>或者<code>dp[i-1][j-w[i]]</code>（即前一行）的值有关。</p>
<p>ps: 其实我有很多地方表述不了很清楚，建议在纸上画表格分析推导一下，然后看下代码手动实现一遍。。</p>
<p>参考链接：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/0-1-bei-bao-wen-ti-xiang-jie-zhen-dui-ben-ti-de-yo/">https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/0-1-bei-bao-wen-ti-xiang-jie-zhen-dui-ben-ti-de-yo/</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>koa-compose原理</title>
    <url>/2020/10/01/koa-compose%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><code>koa</code>是一个很优秀的轻量级web框架，一般我自己写个小东西都会用它。</p>
<p>它的中间件执行顺序就和一个洋葱一样，所以被称为洋葱模型，但是一直不知道它的原理是什么，有时间就看了一下。</p>
<br>

<h2 id="中间件的注册"><a href="#中间件的注册" class="headerlink" title="中间件的注册"></a>中间件的注册</h2><p><code>koa</code>中注册很简单，使用<code>app.use(xxx)</code>就可以注册一个中间件。</p>
<p>源码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">use</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;middleware must be a function!&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isGeneratorFunction</span>(fn)) &#123;</span><br><span class="line">    <span class="title function_">deprecate</span>(<span class="string">&#x27;Support for generators will be removed in v3. &#x27;</span> +</span><br><span class="line">              <span class="string">&#x27;See the documentation for examples of how to convert old middleware &#x27;</span> +</span><br><span class="line">              <span class="string">&#x27;https://github.com/koajs/koa/blob/master/docs/migration.md&#x27;</span>);</span><br><span class="line">    fn = <span class="title function_">convert</span>(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">debug</span>(<span class="string">&#x27;use %s&#x27;</span>, fn.<span class="property">_name</span> || fn.<span class="property">name</span> || <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">middleware</span>.<span class="title function_">push</span>(fn);</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>判断是不是一个<code>&#39;function&#39;</code>，如果不是报错<code>middleware must be a function!</code>。</li>
<li>判断这个函数是不是一个生成器函数即<code>Generator</code>函数，如果不是，将其转为<code>Generator</code>函数。</li>
<li>将中间件函数放入一个全局的<code>middleware</code>数组中。</li>
</ol>
<p>还没完，还需要把这个<code>middleware</code>数组，使用<code>koa-compose</code>这个方法来加工一下，才可以实现洋葱模型。</p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="built_in">require</span>(<span class="string">&#x27;koa-compose&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">listen</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="title function_">debug</span>(<span class="string">&#x27;listen&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="variable language_">this</span>.<span class="title function_">callback</span>());</span><br><span class="line">  <span class="keyword">return</span> server.<span class="title function_">listen</span>(...args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">callback</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="title function_">compose</span>(<span class="variable language_">this</span>.<span class="property">middleware</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">listenerCount</span>(<span class="string">&#x27;error&#x27;</span>)) <span class="variable language_">this</span>.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="variable language_">this</span>.<span class="property">onerror</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleRequest</span> = (<span class="params">req, res</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = <span class="variable language_">this</span>.<span class="title function_">createContext</span>(req, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">handleRequest</span>(ctx, fn);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> handleRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>在调用<code>app.listen</code>来监听端口时，有一个<code>callback</code>函数会被执行。</li>
<li>在<code>callback</code>函数中的第一行，使用了<code>compose(this.middleware)</code>来处理我们注册的中间件函数。</li>
</ol>
<br>

<h2 id="koa-compose源码分析"><a href="#koa-compose源码分析" class="headerlink" title="koa-compose源码分析"></a>koa-compose源码分析</h2><p>源码很简洁：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span> (middleware) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(middleware)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Middleware stack must be an array!&#x27;</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> middleware) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Middleware must be composed of functions!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; <span class="variable">context</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@api</span> <span class="variable">public</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">context, next</span>) &#123;</span><br><span class="line">    <span class="comment">// last called middleware #</span></span><br><span class="line">    <span class="keyword">let</span> index = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">dispatch</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dispatch</span> (i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt;= index) <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;next() called multiple times&#x27;</span>))</span><br><span class="line">      index = i</span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i]</span><br><span class="line">      <span class="keyword">if</span> (i === middleware.<span class="property">length</span>) fn = next</span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title function_">fn</span>(context, dispatch.<span class="title function_">bind</span>(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先判断<code>middleware</code>是不是一个数组，不是数组抛出错误<code>Middleware stack must be an array!</code>。</li>
<li>逐个判断<code>middleware</code>里的元素是不是一个函数，不是的话，抛出错误<code>Middleware must be composed of functions!</code>。</li>
<li>返回一个函数<ol>
<li>使用<code>index</code>巧妙的避免了<code>next</code>执行两次的问题。</li>
<li><code>if (i === middleware.length) fn = next</code>,<code>if (!fn) return Promise.resolve()</code>这两行应该是递归终止条件。</li>
</ol>
</li>
</ol>
<br>

<h5 id="洋葱模型原理"><a href="#洋葱模型原理" class="headerlink" title="洋葱模型原理"></a>洋葱模型原理</h5><p><code>koa</code>的中间件执行顺序大家都很清楚，但是一直没搞懂这段代码为什么会像那样数组，直到看到这样一个例子。。</p>
<p>原谅我，递归的代码脑子稍微没转过来就搞不清楚最终的执行结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="title function_">test2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">  <span class="title function_">test3</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test3</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test1</span>();</span><br></pre></td></tr></table></figure>

<p>上面的代码依次输出，<code>1 2 3 4 5</code></p>
<p>再结合<code>compose</code>的源码，看一下，瞬间就明白了一大半。</p>
<p>其实就是把下一个中间件函数，当做<code>next</code>参数传入当前中间件函数，并且递归执行。</p>
<p>参考链接：</p>
<p><a href="https://www.cnblogs.com/tugenhua0707/p/10204009.html">https://www.cnblogs.com/tugenhua0707/p/10204009.html</a></p>
]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>koa</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>吐槽一下javascript</title>
    <url>/2020/08/23/%E5%90%90%E6%A7%BD%E4%B8%80%E4%B8%8Bjavascript/</url>
    <content><![CDATA[<p>最近在熟悉新公司的一些基础服务和核心库的代码，说真的想吐槽一下<code>JavaScript</code>了，风格太灵活多变了，一样的操作可以用<code>n</code>多种方式或者语法实现，读代码太痛苦了。。</p>
<p>这不是上次面腾讯被问到<code>defineProperty</code>这种定义属性的方式和普通的<code>.</code> 操作有什么不同，刚好想起来我就搜了一下，给我惊到了。。</p>
<br>

<h2 id="JavaScript对象属性定义"><a href="#JavaScript对象属性定义" class="headerlink" title="JavaScript对象属性定义"></a>JavaScript对象属性定义</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">JavaScript文档</a></p>
<p><a href="https://juejin.im/post/6844904145191698446">如何理解Object.defineProperty()?</a></p>
<p>基本的语法和操作没什么好说的。</p>
<p>除了<code>defineProperty</code>之外，还有<code>defineProperties</code>、<code>getOwnPropertyDescriptor</code>、<code>getOwnPropertyDescriptors</code>等配套的方法。</p>
<br>

<h3 id="defineProperty和-操作的区别"><a href="#defineProperty和-操作的区别" class="headerlink" title="defineProperty和.操作的区别"></a><code>defineProperty</code>和<code>.</code>操作的区别</h3><p>原来区别还真的挺大的。。</p>
<ul>
<li><p>通过点操作符定义的属性，<code>writable</code>,<code>configurable</code>,<code>enumerable</code>值都为<code>true</code>，<code>value</code>为赋入的值</p>
</li>
<li><p>通过<code>Object.defineProperty</code>只指定<code>value</code>的属性，<code>writable</code>,<code>configurable</code>,<code>enumerable</code>值都为<code>false</code></p>
</li>
</ul>
<br>

<h3 id="console-log-a-a-a-“abc”问题"><a href="#console-log-a-a-a-“abc”问题" class="headerlink" title="console.log(a+a+a) //“abc”问题"></a>console.log(a+a+a) //“abc”问题</h3><p>说实话这个题我是第一次遇到。。只能说一句<code>JavaScript</code>博大精深，太秀了，一般这么写业务代码会被打死吧。。</p>
<p>下面的代码，在浏览器控制台中可以直接使用，但在<code>node.js</code>环境中，要使用<code>console.log(this.a + this.a + this.a)</code>，或者吧<code>this</code>全部换为<code>global</code>。</p>
<p><a href="https://juejin.im/post/6844904145191698446#heading-48">代码出处</a></p>
<br>
<span id="more"></span>
## JavaScript的遍历方式

<br>

<h3 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h3><p><code>for...in</code>    其实是对象的遍历方式，<strong>不建议用来遍历数组，因为无法保证顺序</strong></p>
<p><strong>遍历对象</strong></p>
<ul>
<li>环遍历对象本身的所有<strong>可枚举属性</strong></li>
<li>遍历对象<strong>从其构造函数原型中继承</strong>的属性</li>
<li>遍历顺序与Object.keys()函数取到的列表一致</li>
</ul>
<p><strong>遍历数组</strong></p>
<ul>
<li>不保证顺序</li>
<li>会忽略空元素</li>
<li>会遍历出来自定义属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for...in遍历数组的缺陷</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line">arr.<span class="property">name</span> = <span class="number">12313</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key) <span class="comment">// 0 1 name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> iterator <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(arr)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(iterator) <span class="comment">// 0 1 name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h3><p><code>for...of</code>是<code>es6</code>提供的一种通用的遍历方式，它可以遍历所有<strong>可迭代对象</strong></p>
<p><strong>遍历数组</strong></p>
<ul>
<li>有序的</li>
<li>不会忽略空值</li>
</ul>
<p><strong>和for…in的区别</strong></p>
<ul>
<li><p>推荐在遍历对象时使用<code>for...in</code>，遍历数组使用<code>for...of</code>。</p>
</li>
<li><p><code>for...in</code>遍历出来的是<code>key</code>，<code>for...of</code>遍历出来的是<code>value</code></p>
</li>
<li><p><code>for...of</code>不能遍历普通对象</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for...of修复了这个缺陷</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line">arr.<span class="property">name</span> = <span class="number">12313</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> iterator <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(iterator) <span class="comment">// 11 22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p><code>forEach</code>是数组的一个高阶函数</p>
<p><strong>forEach和for…of遍历数组的区别</strong></p>
<ul>
<li>forEach中不能使用<code>break</code>、<code>return</code>、<code>continue</code>等语句。</li>
</ul>
<br>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>map()</code> 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。</p>
<p>和<code>lodash</code>的<code>map</code>功能一样呐好像。</p>
<p><strong>map() 方法参数与forEach完全相同，二者区别仅仅在于map会将回调函数的返回值收集起来产生一个新数组。</strong></p>
<br>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><code>filter() </code>参数与<code>forEach</code>完全一致，不过它的<code>callback</code>函数应该返回一个真值或假值。</p>
<br>

<h3 id="find-findIndex"><a href="#find-findIndex" class="headerlink" title="find/findIndex"></a>find/findIndex</h3><p><code>find() </code>方法返回数组中使<code>callback</code>返回值为<code>Truthy</code>的第一个元素的值，没有则返回<code>undefined</code>。</p>
<p><code>findIndex()</code>方法与<code>find</code>方法很类似,只不过<code>findIndex</code>返回使<code>callback</code>返回值为<code>Truthy</code>的第一个元素的索引，没有符合元素则返回<code>-1</code>。</p>
<br>

<h3 id="every-some"><a href="#every-some" class="headerlink" title="every/some/"></a>every/some/</h3><p>两个函数接收参数都与以上函数相同，返回都是布尔值。</p>
<p><code>every</code>用于判断是否数组中每一项都使得<code>callback</code>返回值为<code>Truthy</code>。</p>
<p><code>some</code>用于判断是否至少存在一项使得<code>callback</code>元素返回值为<code>Truthy</code>。</p>
<br>

<h3 id="reduce-reduceRight-累加器"><a href="#reduce-reduceRight-累加器" class="headerlink" title="reduce/reduceRight 累加器"></a>reduce/reduceRight 累加器</h3><p><code>reduce</code>和<code>reduceRight</code>的区别只是执行顺序相反。</p>
<p><code>reduce</code>功能很强大，用法也可以很灵活多变。</p>
<br>

<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">MDN web doc</a></p>
<br>


<h4 id="扁平化数组"><a href="#扁平化数组" class="headerlink" title="扁平化数组"></a>扁平化数组</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> prev.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item) ? <span class="title function_">flatten</span>(item) : item)</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">2</span>, [<span class="number">1</span>, <span class="number">98</span>, <span class="number">21</span>]]]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr)) <span class="comment">// [ 1, 2, 3, 4, 5, 2, 1, 98, 21 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reduceRight</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">reduceRight</span>(<span class="function">(<span class="params">prev, item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> prev.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item) ? <span class="title function_">flatten</span>(item) : item)</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">2</span>, [<span class="number">1</span>, <span class="number">98</span>, <span class="number">21</span>]]]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr)) <span class="comment">// [ 21, 98, 1, 2, 5, 4, 3, 2, 1 ]</span></span><br></pre></td></tr></table></figure>

<h4 id="list-to-tree"><a href="#list-to-tree" class="headerlink" title="list to tree"></a>list to tree</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">parentId</span>: <span class="string">&#x27;&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">parentId</span>: <span class="string">&#x27;&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">parentId</span>: <span class="string">&#x27;1&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">parentId</span>: <span class="string">&#x27;2&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">5</span>, <span class="attr">parentId</span>: <span class="string">&#x27;3&#x27;</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">listToTree</span> (list) &#123;</span><br><span class="line">  <span class="keyword">let</span> nodeInfo = list.<span class="title function_">reduce</span>(<span class="function">(<span class="params">data, node</span>) =&gt;</span> &#123;</span><br><span class="line">    node.<span class="property">children</span> = []</span><br><span class="line">    data[node.<span class="property">id</span>] = node</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">  &#125;, &#123;&#125;)</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!v.<span class="property">parentId</span>) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(nodeInfo[v.<span class="property">id</span>])</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    nodeInfo[v.<span class="property">parentId</span>].<span class="property">children</span>.<span class="title function_">push</span>(nodeInfo[v.<span class="property">id</span>])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title function_">listToTree</span>(list)))</span><br><span class="line"></span><br><span class="line"><span class="comment">//[&#123;&quot;id&quot;:1,&quot;parentId&quot;:&quot;&quot;,&quot;children&quot;:[&#123;&quot;id&quot;:3,&quot;parentId&quot;:&quot;1&quot;,&quot;children&quot;:[&#123;&quot;id&quot;:5,&quot;parentId&quot;:&quot;3&quot;,&quot;children&quot;:[]&#125;]&#125;]&#125;,&#123;&quot;id&quot;:2,&quot;parentId&quot;:&quot;&quot;,&quot;children&quot;:[&#123;&quot;id&quot;:4,&quot;parentId&quot;:&quot;2&quot;,&quot;children&quot;:[]&#125;]&#125;]</span></span><br></pre></td></tr></table></figure>



<br>

<h2 id="Proxy和Reflect"><a href="#Proxy和Reflect" class="headerlink" title="Proxy和Reflect"></a><a href="https://es6.ruanyifeng.com/#docs/proxy">Proxy</a>和<a href="https://es6.ruanyifeng.com/#docs/reflect">Reflect</a></h2><p>它们都是<code>es6</code>的新语法。</p>
<p><a href="https://juejin.im/post/6844903790739456013">JS 中的 Reflect 和 Proxy</a></p>
<br>

<h2 id="空值合并运算符和可选链式操作符"><a href="#空值合并运算符和可选链式操作符" class="headerlink" title="空值合并运算符和可选链式操作符"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator">空值合并运算符</a>和<a href="%5Bhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/%E5%8F%AF%E9%80%89%E9%93%BE%5D(https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/%E5%8F%AF%E9%80%89%E9%93%BE)">可选链式操作符</a></h2><p>因为我在看代码的时候遇到了，查了一下，居然是<code>node14.0.0</code>才支持的语法。。</p>
<h4 id="可选链式操作符（-）"><a href="#可选链式操作符（-）" class="headerlink" title="可选链式操作符（?.）"></a>可选链式操作符（?.）</h4><p>其实看起来就是个快捷操作的语法，帮你判断了一下空值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>.<span class="property">a</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>?.<span class="property">a</span>) <span class="comment">// undefined</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span> &amp;&amp; obj.<span class="property">a</span>.<span class="property">a</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span> ? obj.<span class="property">a</span>.<span class="property">a</span> : <span class="number">0</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>



<h4 id="空值合并运算符"><a href="#空值合并运算符" class="headerlink" title="空值合并运算符"></a>空值合并运算符</h4><p><strong>空值合并操作符</strong>（**<code>??</code>**）是一个逻辑操作符，当左侧的操作数为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a> 或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a> 时，返回其右侧操作数，否则返回左侧操作数。    </p>
<p>与<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Logical_OR_2">逻辑或操作符（<code>||</code>）</a>不同，逻辑或操作符会在左侧操作数为<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy">假值</a>时返回右侧操作数。也就是说，如果使用 <code>||</code> 来为某些变量设置默认值，可能会遇到意料之外的行为。比如为假值（例如，<code>&#39;&#39;</code> 或 <code>0</code>）时。</p>
<p>说白了：</p>
<ul>
<li><code>??</code> 只会当左侧的值为<code>null</code>或是<code>undefined</code>时，才会返回其右侧结果</li>
<li><code>||</code> 当左侧为<strong>假值</strong><code>(&#39;&#39;,0)等</code>时，返回右侧结果</li>
</ul>
<p>彩蛋：在浏览器输出<code>(![]+&#123;&#125;)[-~!+[]^-~[]]+([]+&#123;&#125;)[-~!![]]</code> (~手动狗头)</p>
<p>end~</p>
<p>ps:  真的是不得不吐槽一下<code>JavaScript</code>。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>koa源码之delegates</title>
    <url>/2020/08/04/koa%E6%BA%90%E7%A0%81%E4%B9%8Bdelegates/</url>
    <content><![CDATA[<p>最近看koa的源码，看到了了一个<code>TJ</code>大神写的包<a href="https://www.npmjs.com/package/delegates">delegates</a>，实现了<a href="https://www.runoob.com/design-pattern/proxy-pattern.html">委托模式/代理模式</a>。</p>
<p>当前包的版本为<code>1.0.0</code>，代码就100多行，周下载量一千两百多万。。果然是巨佬。</p>
<br>

<h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>目录结构很简单，主要文件只有一个<code>index.js</code>和<code>test</code>文件夹下的单元测试。</p>
<p><code>index.js</code>文件的内容：</p>
<ul>
<li><strong>Delegator</strong>：构造方法</li>
<li><strong>Delegator.auto</strong>：自动委托所有可以委托的属性</li>
<li><strong>Delegator.prototype.method</strong>：委托一个方法</li>
<li><strong>Delegator.prototype.getter</strong>：委托属性的<strong>getter</strong>方法</li>
<li><strong>Delegator.prototype.setter</strong>：委托属性的<strong>setter</strong>方法</li>
<li><strong>Delegator.prototype.access</strong>: 同时委托属性的<strong>getter</strong>和<strong>setter</strong>方法</li>
<li><strong>Delegator.prototype.fluent</strong>：委托属性，实现jQuery风格，不传参数获取属性值，传参修改属性值。</li>
</ul>
<p>ps: 在koa源码中，使用的也是<code>delegates</code>的<code>1.0.0</code>的包，但是<code>index.js</code>中没有找到<code>auto</code>这个方法。</p>
<br>
<span id="more"></span>

<h2 id="举例和实现"><a href="#举例和实现" class="headerlink" title="举例和实现"></a>举例和实现</h2><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Delegator</span>(<span class="params">proto, target</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Delegator</span>)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Delegator</span>(proto, target);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">proto</span> = proto;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">target</span> = target;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">methods</span> = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getters</span> = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">setters</span> = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">fluents</span> = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个构造函数，<code>if (!(this instanceof Delegator)) return new Delegator(proto, target);</code></p>
<p>这一行的目的是，可以使用<code>Delegator(proto,target)</code>来实例化一个对象。</p>
<h4 id="method"><a href="#method" class="headerlink" title="method"></a><strong>method</strong></h4><p>源码没什么难度，核心代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">proto[name] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>[target][name].<span class="title function_">apply</span>(<span class="variable language_">this</span>[target], <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>举个列子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> delegates = <span class="built_in">require</span>(<span class="string">&#x27;delegates&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">obj.<span class="property">request</span> = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="function">(<span class="params">foo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">delegates</span>(obj, <span class="string">&#x27;request&#x27;</span>).<span class="title function_">method</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">foo</span>(<span class="string">&#x27;aaa&#x27;</span>)); <span class="comment">// aaa</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">request</span>.<span class="title function_">foo</span>(<span class="string">&#x27;bbb&#x27;</span>)); <span class="comment">// bbb</span></span><br></pre></td></tr></table></figure>

<h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a><strong>getter</strong></h4><p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> delegates = <span class="built_in">require</span>(<span class="string">&#x27;delegates&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">obj.<span class="property">request</span> = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="function">(<span class="params">foo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> foo;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">phone</span>: <span class="string">&#x27;iphone11&#x27;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">getter1</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj.<span class="property">request</span>, <span class="string">&#x27;getter&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">phone</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">delegates</span>(obj, <span class="string">&#x27;request&#x27;</span>).<span class="title function_">getter</span>(<span class="string">&#x27;getter&#x27;</span>);</span><br><span class="line"><span class="title function_">delegates</span>(obj, <span class="string">&#x27;request&#x27;</span>).<span class="title function_">getter</span>(<span class="string">&#x27;getter1&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">getter</span>); <span class="comment">// &#x27;iphone11&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">getter1</span>); <span class="comment">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>

<p>从上面的代码例子中可以知道，<code>get getter()&#123;&#125;</code>还是<code>Object.defineProperty</code>效果是一样的。</p>
<p>核心代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">proto.<span class="title function_">__defineGetter__</span>(name, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>[target][name];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__"><strong><strong>defineGetter</strong></strong></a>方法可以将一个函数绑定在当前对象的指定属性上，当那个属性的值被读取时，你所绑定的函数就会被调用。</p>
<p>但是在<code>MDN web docs</code>文档中说它是一个非标准的方法，未来可能会停止支持。。。</p>
<p>所以这样改一下也没什么问题吧：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(proto, name, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>[target][name]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="setter"><a href="#setter" class="headerlink" title="setter"></a>setter</h4><p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> delegates = <span class="built_in">require</span>(<span class="string">&#x27;delegates&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">obj.<span class="property">request</span> = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="function">(<span class="params">foo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> foo;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">phone</span>: <span class="string">&#x27;iphone11&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj.<span class="property">request</span>, <span class="string">&#x27;setter&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">phone</span> = value;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">delegates</span>(obj, <span class="string">&#x27;request&#x27;</span>).<span class="title function_">setter</span>(<span class="string">&#x27;setter&#x27;</span>);</span><br><span class="line">obj.<span class="property">setter</span> = <span class="string">&#x27;iphone12&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">request</span>.<span class="property">phone</span>); <span class="comment">// iphone12</span></span><br></pre></td></tr></table></figure>

<p>核心代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">proto.<span class="title function_">__defineSetter__</span>(name, <span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>[target][name] = val;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>同理也可以改为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(proto, name, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>[target][name] = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="access"><a href="#access" class="headerlink" title="access"></a>access</h4><p>核心代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getter</span>(name).<span class="title function_">setter</span>(name);</span><br></pre></td></tr></table></figure>

<p>没什么好说的，就是同时代理了<code>getter</code>和<code>setter</code></p>
<h4 id="fluent"><a href="#fluent" class="headerlink" title="fluent"></a>fluent</h4><p>核心代码也比较简单：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">proto[name] = <span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;undefined&#x27;</span> != <span class="keyword">typeof</span> val) &#123;</span><br><span class="line">    <span class="variable language_">this</span>[target][name] = val;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>[target][name];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据代码可以看出来，fluent代理的属性，传参时为获取值，不传参时为设置值。</p>
<h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p>不过神奇的是，我直接下载的源码有这个方法并且有对应的测试用例，但是npm下载的包中确没有<code>auto</code>这个方法。</p>
<ol>
<li>新建一个<code>Delegator</code>对象，获取被委托对象的所有属性。</li>
<li>循环遍历这些属性。<ol>
<li>获取这个属性的详细描述(<code>Object.getOwnPropertyDescriptor</code>)。</li>
<li>如果有<code>get</code>方法，委托<code>getter</code>。</li>
<li>如果有<code>set</code>方法，委托<code>setter</code>。</li>
<li>如果有<code>value</code>属性：<ol>
<li>如果<code>value</code>是<code>Function</code>类型，委托<code>method</code>。</li>
<li>如果不是委托<code>getter</code>。</li>
<li>如果这个属性是可写的<code>writable = true</code>，委托<code>setter</code>。</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Delegator</span>.<span class="property">auto</span> = <span class="keyword">function</span> (<span class="params">proto, targetProto, targetProp</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> delegator = <span class="title class_">Delegator</span>(proto, targetProp);</span><br><span class="line">  <span class="keyword">var</span> properties = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(targetProto);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; properties.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> property = properties[i];</span><br><span class="line">    <span class="keyword">var</span> descriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(targetProto, property);</span><br><span class="line">    <span class="keyword">if</span> (descriptor.<span class="property">get</span>) &#123;</span><br><span class="line">      delegator.<span class="title function_">getter</span>(property);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (descriptor.<span class="property">set</span>) &#123;</span><br><span class="line">      delegator.<span class="title function_">setter</span>(property);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (descriptor.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;value&#x27;</span>)) &#123; <span class="comment">// could be undefined but writable</span></span><br><span class="line">      <span class="keyword">var</span> value = descriptor.<span class="property">value</span>;</span><br><span class="line">      <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123;</span><br><span class="line">        delegator.<span class="title function_">method</span>(property);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        delegator.<span class="title function_">getter</span>(property);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (descriptor.<span class="property">writable</span>) &#123;</span><br><span class="line">        delegator.<span class="title function_">setter</span>(property);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>koa</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次腾讯的面试</title>
    <url>/2020/07/18/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E8%85%BE%E8%AE%AF%E7%9A%84%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>说起来挺魔幻的，事情起因这样滴。。</p>
<p>五六月份的时候，西安腾讯云子公司在boss上找我要了一份简历，给我安排了面试。</p>
<p>一面主要问了下项目，es6的语法，设计模式等等。。其实不是很难，只是那时候没有准备，现在去应该能过一面。。</p>
<p>然后前几天，成都腾讯企业微信组的hr找我（捂脸），说在简历库看到我的简历，让我去面试，我也没多想，反正就当积累经验了。</p>
<p>然后开始了痛苦的三个多小时。。。(下面除了算法题我琢磨出了答案，其他的只是个大纲，作为以后学习的方向)</p>
<br>

<h4 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h4><p>上来面试官小哥哥先自己我介绍了一下，然后我大概说了一下自己的姓名，什么时候毕业，几份工作的起止时间和主要做的事。<br><br></p>
<h4 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h4><p>在腾讯会议的聊天窗口发给我了一个链接，点开后是一个实时同步的代码编辑器。</p>
<p>第一次遇到这种面试，人有点懵，原来子公司和总公司难度差距这么大奥。。</p>
<p>虽然我算法很渣，但题还是要做的嘛。</p>
<p><a href="https://github.com/ruomuc/practice/blob/master/algorithm/tecentInterview.js">原题放在github上了</a></p>
<span id="more"></span>
<p>四十五分钟两道题，结果时间超了，第一条我做出来了80%吧，后面大佬诱导我找到了正确答案。</p>
<p>第二题就简单说了一下思路，但是都不对。首先，用随机数随机，放进数据被pass了，如果随机数范围不变，会有两个元素随机到一个位置的情况，如果随机数范围变化，后面的元素就必定不会被放进已经占用的位置了，这样每个元素在每个位置的概率就不相同了。</p>
<p><strong>第一题的解题思路和代码：</strong></p>
<ol>
<li>先将目标数组去重。</li>
<li>使用map将任意类型的数据当做key的特性，存储Object=&gt;count，来记录每个对象出现的次数。</li>
<li>然后就是map的遍历取值。</li>
</ol>
<p>反思：我一时间没有想起来使用Map，走了很多弯路，如果将原题数组中的对象换成值类型数据，是不是就非常简单了。。</p>
<p>ps: Map这个数据结构，我这辈子都忘不掉了（捂脸）</p>
<p><a href="https://github.com/ruomuc/practice/blob/master/algorithm/tecentInterview-01.js">附上代码</a></p>
<p><strong>第二题的解题思路和代码：</strong><br>第二题我google了一下，好像是一个类似lodash的库的一个源码的思想，看完发现非常简单。。唉，算法就是这么折磨人（小妖精）。</p>
<p><a href="https://github.com/lessfish/underscore-analysis/issues/15">原文地址</a></p>
<ol>
<li>好像就只是遍历数组，随机一个当前范围随机数<code>(~~(Math.random() * (i+1)))</code>，交换两个位置的元素。</li>
</ol>
<p>难点在于<strong>每个元素落到任意位置的概率是否相同</strong>呢？</p>
<p>原文中有大佬用数学归纳法做了证明。。</p>
<p>我也简单的分析了一下，这里取长度分别为1、2、3、4的数组分析一下，后面依次类推就行了</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1/2</td>
<td>1/2</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>1/3</td>
<td>1/3</td>
<td>1/3</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>1/4</td>
<td>1/4</td>
<td>1/4</td>
<td>1/4</td>
</tr>
</tbody></table>
<ol>
<li>   第一次循环，0元素在0位置的概率是1，在其他位置的概率是0。</li>
<li>   第二次循环，1元素在0、1位置的概率都是1/2，在其他位置的概率是0。</li>
<li>   第三次循环，2元素在0、1、2位置的概率都是1/3，在其他位置的概率是0。</li>
<li>   第四次循环，3元素在0、1、2、3位置的概率都是1/4。</li>
</ol>
<p>好了那么，总结一下：</p>
<ol>
<li>数组长度为1时：0元素在0位置的概率为1。</li>
<li>数组长度为2时：0元素在0位置的概率为 1 * 1/2 = 1/2，在1位置的概率为 1/2 ；1元素在0、1位置的概率都为 1/2</li>
<li>数组长度为3时：0元素在0位置的概率为 1* 1/2 * 2/3 = 1/3 ,  在1位置的概率 1/2 * 2/3 = 1/3 ，在2位置的概率为 1/3 ;  1 元素在0的概率为 1/2 * 2/3 = 1/3 , 在 1的概率为 1/2 * 2/3 = 1/3 , 在2位置的概率为 1/3 ;  2元素在所有位置的概率都为1/3。</li>
<li>依次类推。。我承认是有点绕。这是我的笨办法。。</li>
</ol>
<p><a href="https://github.com/ruomuc/practice/blob/master/algorithm/tecentInterview-02.js">最后附上代码</a></p>
<br>

<h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p><strong>说一下自己用过哪些node框架，说一下优缺点。。</strong></p>
<p>我就说了一下express，koa，nest这些，就说了express比较重，koa轻一点啊，nest写法好维护啊巴拉巴拉一些(优缺点的话网上有一堆，但是让我切身经历和感受到的真没有。。)，然后说了一下express和koa中间键的区别(一个类似队列，一个类似栈)。</p>
<p><strong>koa中间键有什么好处？express可以试下koa中间键的写法吗？什么情况下需要第一个中间件最后执行？</strong></p>
<p>有点懵逼…</p>
<h4 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h4><p><strong>分享一下性能调优的经历，前端，服务器，数据库都可以。</strong></p>
<p>巴拉巴拉说了一点。。</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p><strong>平时有看过node或者一些优秀框架的源码吗。</strong></p>
<p>这个在论坛上看过别人分析源码，印象比较深刻。。说了一下v8的事件循环机制，每个阶段干了什么。弄懂这个基本所有的异步代码执行顺序题都是小儿科了。。所以说有条件还是要多看看原理类的东西。</p>
<p>其他的就没得了。。面试到这就结束了。。</p>
<p>ps:  挺感谢这次面试机会的，一次经验吧，面试官也很谦虚耐心，没因为我算法题菜打断我。也算是有了学习的方向吧。。另外很多东西在小公司真的是八辈子用不到也接触不到啊，只能自己琢磨。。降维打击啊。</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>面经2020</title>
    <url>/2020/07/18/%E9%9D%A2%E7%BB%8F2020/</url>
    <content><![CDATA[<p>面经放一起吧，做一个汇总吧</p>
<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>今天面了一家做车联网的公司。<br>技术的问题没什么难度，他们也没用mysql，redis这种常用的数据库，用的是其它的nosql。</p>
<p>我不太了解的问题主要有三个吧。随便记录一下。<br><br></p>
<h4 id="有用过什么云服务？"><a href="#有用过什么云服务？" class="headerlink" title="有用过什么云服务？"></a>有用过什么云服务？</h4><p>云服务这块我过得就是云存储(oss)，然后vps（自己搭小飞机用的），不过这种东西只要能看懂api文档。上手没什么难度吧。<br><br></p>
<h4 id="serverless架构有什么了解？"><a href="#serverless架构有什么了解？" class="headerlink" title="serverless架构有什么了解？"></a>serverless架构有什么了解？</h4><p>我之前在cnode论坛上看到过别人讨论这个来着，还专门去看了下，但是这种烧钱的架构暂时没用上就没往深去看。。</p>
<p>下面是知乎找的一些基本概念，<a href="https://zhuanlan.zhihu.com/p/79112228">参考链接</a></p>
<span id="more"></span>
<br>
**核心思想**
用户无需关注支撑应用服务运行的底层主机。
无服务并不是说基于 Serverless 架构的软件应用不需要服务器就可以运行，其指的是用户无须关心软件应用运行涉及的底层服务器的状态、资源（比如 CPU、内存、磁盘及网络）及数量。
<br>
**优势**
提高应用交付的效率，降低应用运营的工作量和成本。
<br>
**劣势**
emm...应该是贵吧。。毕竟服务器资源都是钱嘛。。

<ul>
<li>控制力：用户对底层的计算资源没有控制力。</li>
<li>可移植性：不同IT厂商的 Serverless 平台和解决方案的具体实现并不相同。</li>
<li>安全性：用户不能直接控制应用实际所运行的主机。</li>
<li>性能：按需加载服务资源，首次加载及重新加载的过程将产生一定的延时。</li>
<li>Serverless按需加载执行，对Fass函数执行时长存在限制。</li>
<li>起步时间不长的新兴技术，Serverless 相关平台、工具和框架还处在一个不断变化和演进的阶段，文档资料相对较少。</li>
</ul>
<br>
**目前市场上比较流行的 Serverless 工具、框架和平台**

<ul>
<li>AWS Lambda，最早被大众所认可的 Serverless 实现。</li>
<li>Azure Functions，来自微软公有云的 Serverless 实现。</li>
<li>OpenWhisk，Apache 社区的开源 Serverless 框架。</li>
<li>Kubeless，基于 Kubernetes 架构实现的开源 Serverless 框架。</li>
<li>Fission，Platform9 推出的开源 Serverless 框架。</li>
<li>OpenFaaS，以容器技术为核心的开源 Serverless 框架。</li>
<li>Fn，来自 Oracle 的开源 Serverless 框架，由原 Iron Functions 团队开发。</li>
</ul>
<br>

<h4 id="物联网协议s"><a href="#物联网协议s" class="headerlink" title="物联网协议s"></a>物联网协议s</h4><p><a href="https://zhuanlan.zhihu.com/p/39156562">物联网架构及五大常用通信协议</a></p>
<p>ps:  正常技术问题没什么难度，主要是方向不太一致。看缘分吧。</p>
<br>

<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h4 id="哈希表实现"><a href="#哈希表实现" class="headerlink" title="哈希表实现"></a>哈希表实现</h4><p>我说了数组的实现，hash函数生成index，插入数据。</p>
<p>哈希冲突：1. 开放寻址法 。2. 链表法</p>
<br>

<h4 id="两数求和"><a href="#两数求和" class="headerlink" title="两数求和"></a>两数求和</h4><p>给一个整数数组，给一个整数，找出这个数组中之和等于这个整数的组和。</p>
<p>假设：输入[1,2,3,4] 和 6 输出 [1,3]</p>
<p>我记得我在LeetCode刷到过。</p>
<p>方法1：暴力解，双重for循环。 时间： O(n<sup>2</sup>)  空间：O(1)</p>
<p>方法2：先遍历一遍，先生成一个下标和值的字典，然后再遍历一遍，在字典中寻找合适的值。 时间：O(n)  空间：O(n)</p>
<p>面试官说可以用快速排序+二分查找来实现。。时间：O(nlon<sup>n</sup>)  空间：O(logn)<br><a href="https://github.com/ruomuc/practice/blob/master/algorithm/towNumberSum.js">&gt;&gt;&gt;代码地址</a><br><br></p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>说了一下快排的原理，问了一下什么情况下快排的时间复杂度是O(n<sup>2</sup>)  。</p>
<p>然后为了下为什么会是O(n<sup>2</sup>)  。。。这个我真没注意过，不过结束后我自己画了个图分析了一下，原来刚好<strong>逆序</strong>(从小往大排序刚好遇到从大到小的一组数)的情况的下，<strong>快排每一轮都只做了一次元素交换（循环最后一个元素和基准元素），其他的都在和自己交换。。</strong></p>
<br>

<h4 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h4><p>select * from Student where age &gt; 18 order by score desc limit 10</p>
<p>根据题目描述，我口述了这么一个sql，然后问我如何优化。。</p>
<p>只不过我索引加错了，应该加 （age,score）的联合索引。。惊了。第一次听说单独无法命中，联合可以的。。</p>
<p><a href="https://www.mdaima.com/jingyan/14.html">MySQL如何利用索引优化WHERE和ORDER BY的查询语句效率</a><br><br></p>
<h4 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h4><p>我觉得这个是最难说的，平常大都是业务代码，很少写什么很有成就感的容易让我印象深刻的东西。。。</p>
<p>—– 2020-8-15 13:54:46 ——<br>工作已经确定了，后面面得公司问的问题都差不多，就不写了。<br>此贴终结（狗头）</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>流式查询mysql</title>
    <url>/2020/07/13/%E6%B5%81%E5%BC%8F%E6%9F%A5%E8%AF%A2mysql/</url>
    <content><![CDATA[<p>简单记录一下，使用node的流读取mysql数据，解决分页扫表慢的问题。</p>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>有一个计算任务，需要逐条扫描一张大表里的符合条件的数据，并且做一些简单的计算插入一张小表中去，类似<code>select * from tableA where condition &gt; 1</code>。假设符合条件的数据有1000w条，使用分页，每页1000条，逐页查询并计算完插入小表。</p>
<h4 id="瓶颈"><a href="#瓶颈" class="headerlink" title="瓶颈"></a>瓶颈</h4><p>mysql分页的特性。。就是越往后越慢，晚上计算任务又多，很容易跑不完或者挂掉。<br>哪怕优化了分页，效果还是不如意。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>我们用的 knex.js，不能算是orm，只能算是一个sql builder吧。</p>
<p>使用knex的stream创建一个流，然后使用node的流事件<code>.on(&#39;data&#39;)</code>监听这个流，每查询一条数据都会触发流事件。</p>
<p>这里只是提供了一个思路，上代码：</p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> logger = <span class="built_in">require</span>(<span class="string">&#x27;./filterLogger&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> knex = <span class="built_in">require</span>(<span class="string">&quot;./db&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 流式处理数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">String</span>&#125; sql 数据源sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; dealFunction 处理数据的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; pageSize 一次处理数据大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">streamReadToWriteDB</span>(<span class="params">sql, dealFunction, pageSize</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> tempData = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    knex.<span class="title function_">raw</span>(sql)</span><br><span class="line">      .<span class="title function_">stream</span>(<span class="keyword">function</span> (<span class="params">stream</span>) &#123;</span><br><span class="line">        stream.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">          tempData.<span class="title function_">push</span>(data)</span><br><span class="line">          n++;</span><br><span class="line">          <span class="keyword">if</span> (tempData.<span class="property">length</span> &gt;= pageSize) &#123;</span><br><span class="line">            stream.<span class="title function_">pause</span>()</span><br><span class="line">            <span class="title function_">dealFunction</span>(tempData)</span><br><span class="line">              .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                tempData = []</span><br><span class="line">                stream.<span class="title function_">resume</span>()</span><br><span class="line">              &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        stream.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!_.<span class="title function_">isEmpty</span>(tempData)) &#123;</span><br><span class="line">            logger.<span class="title function_">trace</span>(<span class="string">`任务剩余<span class="subst">$&#123;tempData.length&#125;</span>条未处理，即将处理！`</span>)</span><br><span class="line">            <span class="title function_">dealFunction</span>(tempData)</span><br><span class="line">              .<span class="title function_">then</span>(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">                tempData = []</span><br><span class="line">                logger.<span class="title function_">trace</span>(<span class="string">`任务执行完毕!一共<span class="subst">$&#123;n&#125;</span>片数据,每片<span class="subst">$&#123;pageSize&#125;</span>条`</span>)</span><br><span class="line">                <span class="title function_">resolve</span>(results)</span><br><span class="line">              &#125;)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.<span class="title function_">trace</span>(<span class="string">`任务执行完毕!一共<span class="subst">$&#123;n&#125;</span>片数据,每片<span class="subst">$&#123;pageSize&#125;</span>条`</span>)</span><br><span class="line"></span><br><span class="line">            <span class="title function_">resolve</span>()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="literal">true</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        logger.<span class="title function_">warn</span>(<span class="string">&#x27;流处理出错&#x27;</span>, err)</span><br><span class="line">        <span class="title function_">reject</span>()</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  streamReadToWriteDB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中的pagesize是嫌弃一次处理一条数据太浪费了，多缓存几个一起处理。</p>
<p>这中写法效果非常好，千万数据量速度快了几十倍。。</p>
<p>当然和es的scroll写法一样，流不支持跳页。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>stream</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6之函数的扩展</title>
    <url>/2020/07/11/ES6%E4%B9%8B%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h2 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>es6之前函数的参数不能使用默认值，只能采取这种写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params">x</span>)&#123;</span><br><span class="line">  x=x||<span class="number">1</span>; <span class="comment">// x的默认值为1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>但是es6可以为函数的参数设置默认值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params">x = <span class="number">1</span></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p><strong>不能有重复参数</strong>：</p>
<p>非严格模式下，重复参数不会报错：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params">x, x, y</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, x, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 2 2 3</span></span><br></pre></td></tr></table></figure>

<p>但是严格模式或者使用参数默认值时，不能使用这种写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params">x, x, y</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, x, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// Duplicate parameter name not allowed in this context</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params">x, x, y = <span class="number">1</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, x, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// Duplicate parameter name not allowed in this context</span></span><br></pre></td></tr></table></figure>

<p><strong>参数变量是默认声明的</strong></p>
<span id="more"></span>
<p>不能再次使用<code>let</code>或者<code>const</code>声明和参数相同的变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x = <span class="number">5</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>; <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">2</span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<p><strong>函数参数默认值时惰性求值</strong></p>
<p>下面代码中的<code>p</code>的默认值是<code>x+1</code>，每次调用都会重新计算<code>x+1</code>的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">p = x + <span class="number">1</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 100</span></span><br><span class="line">x++;</span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 101</span></span><br></pre></td></tr></table></figure>

<h3 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h3><p><strong>基本用法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>); <span class="comment">// 1 5</span></span><br></pre></td></tr></table></figure>

<p>下面两种写法的结果是相同的，但是执行过程确不同：</p>
<ul>
<li>写法一：默认值为<code>&#123;&#125;</code>，结构赋值的默认值为<code>x=0 y=0</code></li>
<li>写法二：默认值为<code>&#123;x:0,y:0&#125;</code>，结构赋值之后<code>x=0 y=0</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">m1</span>(<span class="params">&#123; x = <span class="number">0</span>, y = <span class="number">0</span> &#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">m2</span>(<span class="params">&#123; x, y &#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">m1</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">m2</span>())</span><br></pre></td></tr></table></figure>

<h3 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h3><p>通常情况下，定义了默认值的参数应该是函数的尾参数，因为前面的参数无法省略，触发你你显示的传入<code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params">a=<span class="number">1</span>,b</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a,b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>(<span class="number">10</span>) <span class="comment">// 10 undefined</span></span><br><span class="line"><span class="title function_">a</span>(<span class="literal">undefined</span>,<span class="number">2</span>) <span class="comment">// 1 2 </span></span><br></pre></td></tr></table></figure>

<h3 id="函数参数的length属性"><a href="#函数参数的length属性" class="headerlink" title="函数参数的length属性"></a>函数参数的length属性</h3><p>指定了默认值以后，函数的<code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真。</p>
<p>并且函数的<code>length</code>属性会忽略第一个有默认值的参数后面所有的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">a</span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 1</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 0</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 2</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params">a=<span class="number">0</span>, b, c = <span class="number">5</span></span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y = x</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(<span class="number">2</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>调用函数<code>f</code>时，参数形成一个单独的作用域。在这个作用域里面，默认值变量<code>x</code>指向第一个参数<code>x</code>，而不是全局变量<code>x</code>，所以输出是<code>2</code>。<br><br></p>
<h2 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">...values</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h3 id="rest和arguments的区别"><a href="#rest和arguments的区别" class="headerlink" title="rest和arguments的区别"></a>rest和arguments的区别</h3><p><strong>arguments是一个类数组对象，而rest参数是一个真正的数组。</strong></p>
<ul>
<li>arguments想要调用数组的方法要这样<code>Array.prototype.slice.call(arguments).sort()</code></li>
<li>它们都有length属性，返回参数数量</li>
<li>函数的length属性不包括rest参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params">...values</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(values)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">a</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">length</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>从 ES5 开始，函数内部可以设定为严格模式。</p>
<p>但是在<code>ES6</code>中<font color = "red">只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。</font></p>
<p><a href="%5Bhttps://es6.ruanyifeng.com/#docs/function#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%5D(https://es6.ruanyifeng.com/#docs/function#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F)">具体原因详见</a><br><br></p>
<h2 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h2><p>函数的<code>name</code>属性，返回该函数的函数名。这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">foo.<span class="property">name</span> <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>

<p>ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的<code>name</code>属性，会返回空字符串，而 ES6 的<code>name</code>属性会返回实际的函数名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line">f.<span class="property">name</span> <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">f.<span class="property">name</span> <span class="comment">// &quot;f&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>Function</code>构造函数返回的函数实例，<code>name</code>属性的值为<code>anonymous</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="title class_">Function</span>).<span class="property">name</span> <span class="comment">// &quot;anonymous&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>bind</code>返回的函数，<code>name</code>属性值会加上<code>bound</code>前缀。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">foo.<span class="title function_">bind</span>(&#123;&#125;).<span class="property">name</span> <span class="comment">// &quot;bound foo&quot;</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;).<span class="title function_">bind</span>(&#123;&#125;).<span class="property">name</span> <span class="comment">// &quot;bound &quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">new</span> <span class="title class_">Function</span>().<span class="title function_">bind</span>()).<span class="property">name</span>) <span class="comment">// bound anonymous</span></span><br></pre></td></tr></table></figure>

<br>

<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数的使用方法就不说了。。。</p>
<h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><p>关于箭头函数的this的绑定问题，可以看我这篇博文<a href="https://ruomuc.gitee.io/blog/2020/05/24/JavaScript%E4%B8%AD%E7%9A%84this/">JavaScript中的this</a></p>
<ol>
<li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</li>
<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>
<li>不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</li>
</ol>
<h3 id="不适用场合"><a href="#不适用场合" class="headerlink" title="不适用场合"></a>不适用场合</h3><p><strong>第一个场合是定义对象的方法，且该方法内部包括<code>this</code>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cat = &#123;</span><br><span class="line">  <span class="attr">lives</span>: <span class="number">9</span>,</span><br><span class="line">  <span class="attr">jumps</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lives</span>--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的箭头函数指向全局，而不是指向cat。</p>
<p><strong>第二个场合是需要动态<code>this</code>的时候，也不应使用箭头函数。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;press&#x27;</span>);</span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&#x27;on&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里的this指向的也是全局而不是button对象。<br><br></p>
<h2 id="其它改动"><a href="#其它改动" class="headerlink" title="其它改动"></a>其它改动</h2><p><strong>函数参数的尾逗号</strong></p>
<p>ES2017 <a href="https://github.com/jeffmo/es-trailing-function-commas">允许</a>函数的最后一个参数有尾逗号（trailing comma）。这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。</p>
<p><strong>Function.prototype.toString()</strong></p>
<p><a href="https://github.com/tc39/Function-prototype-toString-revision">ES2019</a> 对函数实例的<code>toString()</code>方法做出了修改，以前会省略注释和空格，修改后的<code>toString()</code>方法，明确要求返回一模一样的原始代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="comment">/* foo comment */</span> foo () &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以前</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toString</span>()); <span class="comment">// // function foo() &#123;&#125;</span></span><br><span class="line"><span class="comment">// ES2019</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toString</span>()); <span class="comment">// function /* foo comment */ foo () &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>catch 命令的参数省略</strong></p>
<p>JavaScript 语言的<code>try...catch</code>结构，以前明确要求<code>catch</code>命令后面必须跟参数，接受<code>try</code>代码块抛出的错误对象。</p>
<p>很多时候，<code>catch</code>代码块可能用不到这个参数。但是，为了保证语法正确，还是必须写。<a href="https://github.com/tc39/proposal-optional-catch-binding">ES2019</a> 做出了改变，允许<code>catch</code>语句省略参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2019</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
ps:  如何在typescript中使用rest参数？定一个any[] 吗？这样岂不是违反了使用ts的初衷，可读性和可维护性变差了？]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch初踩坑</title>
    <url>/2020/07/04/elasticsearch%E5%88%9D%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<p>大概说一下前段时间用<code>elasticsearch</code>遇到的几个坑</p>
<p><code>es</code>版本为<code>7.7.1</code></p>
<h4 id="原始需求"><a href="#原始需求" class="headerlink" title="原始需求"></a>原始需求</h4><p>千万级会员，三个条件模糊搜索（左匹配），使用<code>mysql</code>大概要30多秒，因为体验太差所以考虑用<code>es</code>做优化。</p>
<p>实际上，这种需求并不是<code>es</code>主要针对的场景，但是用也可以用，效果也不错，同样的搜索条件<code>0-3s</code>。因为最终结果会比<code>mysql</code>少一些数据，所以在准确率<code>95-99%</code>之间，在我们可以接受的范围之内。</p>
<h4 id="遇到坑和问题"><a href="#遇到坑和问题" class="headerlink" title="遇到坑和问题"></a>遇到坑和问题</h4><h5 id="文档不准确"><a href="#文档不准确" class="headerlink" title="文档不准确"></a>文档不准确</h5><p><code>es</code>版本更新快，官网的入门教程还是基于<code>es2.0</code>写的，用的时候遇到许多语法不支持，所以只能去看对应版本英文文档。包括网上的一些教程、博文的版本都各不相同。</p>
<p>解决方案：</p>
<p>没有办法。。。更新太快导致官放教程都没维护，入门的话就只能对比着对应版本的英文文档看了，只能多踩一些坑。</p>
<h5 id="索引的映射类型type失效"><a href="#索引的映射类型type失效" class="headerlink" title="索引的映射类型type失效"></a>索引的映射类型<code>type</code>失效</h5><p>官方解释：</p>
<p><code>在Elasticsearch6.0.0或者或者更新版本中创建的索引只会包含一个映射类型(mappingtype). 在5.x中创建的具有多个映射类型的索引在Elasticsearch6.x中依然会正常工作。在Elasticsearch7.0.0中，映射类型将会被完全移除。</code></p>
<p>解决方案：</p>
<p>创建索引不指定<code>type</code>，使用默认的就行，这个字段现在已经没有任何作用。</p>
<h5 id="索引的字段的string类型"><a href="#索引的字段的string类型" class="headerlink" title="索引的字段的string类型"></a>索引的字段的<code>string</code>类型</h5><p>在ElasticSearch 5.x 之后，字符串类型有了重大改动，移除了String类型，而拆分成了两个新类型<code>keyword</code>和<code>text</code>。</p>
<p>text类型：</p>
<ul>
<li><p>会进行分词，分词后建立索引。【比如：对于‘佟永硕’，ik分词器的smart分词会自动将其分成佟、永、硕三个字符进行建立索引，所以单字符搜索可以搜索到，而比如‘永硕’则搜索不到】</p>
</li>
<li><p>支持模糊查询，支持准确查询。</p>
</li>
<li><p>不支持聚合查询</p>
</li>
</ul>
<p>keyword类型：</p>
<ul>
<li>不分词，直接建立索引。【依据此特点，可以使用keyword类型+wildcardQuery（通配查询）实现类似sql的like查询（模糊搜索）】</li>
<li>支持模糊查询，支持准确查询。</li>
<li>支持聚合查询。</li>
</ul>
<p>如果你是跟着教程使用<code>string</code>的字段类型创建的索引，他会自动变为<code>text</code>，而根据我的需求，我需要的其实是<code>keyword</code>类型的字段，所以前几次数据总是很奇怪，因为被分词了。</p>
<span id="more"></span>
<h5 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h5><p><code>elasticsearch</code>在分页上面可以说是极其不擅长了。。。</p>
<p><code>es</code>的分页有两种方案：</p>
<ul>
<li>搜索时指定<code>from</code>和<code>size</code>属性。假设每页十条数据我需要第十页的数据，即91-100。我会先查出前100条数据，把91-100条切出来，返回。</li>
<li><code>scroll</code>滚动的方式，有点像游标，第一次查询后，返回一个<code>scroll_id</code>，你用id去进行下一次查询，每次返回固定长度的数据。<strong>适合用于下来刷新这种连续翻页的场景。</strong></li>
</ul>
<p>这两个方案我都无法接受，事实上我使用<code>scroll</code>的方式，手动写了一个分页函数，比如要取100页的数据，就递归滚动100次，试了一下巨慢无比，没有意义。。。</p>
<p>解决方案：</p>
<p>改需求。。。没有错，事实上模糊搜索没有人在乎最后一页的数据，比如说百度谷歌，一般人前十页都不会翻完。于是乎，我们使用<code>from size</code>的方式，永远只返回前1000数据用于分页。</p>
<h5 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h5><p>数据初始化： 我直接分片查的<code>mysql</code>格式化后使用<code>bulk</code>这个<code>api</code>直接导入<code>es</code>。一片1w数据，1200多万2个小时左右。事实上有更好的方案。</p>
<p>数据更新：我们有定时器服务，每一段时间拿到有更新的会员数据，覆盖插入进redis，因为我们<code>es</code>数据的<code>id</code>用的是会员卡号，保证唯一。</p>
<p><code>es</code>和<code>kibana</code>的部署： 开发环境的用<code>dokcer</code>就好了，这个琢磨一下应该不复杂。。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6之正则的扩展</title>
    <url>/2020/06/30/ES6%E4%B9%8B%E6%AD%A3%E5%88%99%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h2 id="RegExp构造函数"><a href="#RegExp构造函数" class="headerlink" title="RegExp构造函数"></a>RegExp构造函数</h2><p>在ES5中我们可以这样声明一个正则表达式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;xyz&#x27;</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="regexp">/xyz/i</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;</span><br></pre></td></tr></table></figure>

<p>但是这样会报错，因为第一个参数不是字符串，而是一个正则表达式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="regexp">/xyz/</span>, <span class="string">&#x27;i&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>但是在ES6中支持这种行为，并且如果存在第二个参数，会忽略原有的修饰符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="regexp">/abc/ig</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg); <span class="comment">// /abc/i</span></span><br></pre></td></tr></table></figure>
<br>

<h2 id="字符串的正则方法"><a href="#字符串的正则方法" class="headerlink" title="字符串的正则方法"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@split#">字符串的正则方法</a></h2><h4 id="match"><a href="#match" class="headerlink" title="match"></a>match</h4><p>match 方法会返回一个数组，它包括整个匹配结果，和通过捕获组匹配到的结果，如果没有匹配到则返回null</p>
<p>这个方法在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match"><code>String.prototype.match()</code></a> 的内部调用。例如，下面的两个方法返回相同结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/a/</span>);</span><br><span class="line"><span class="regexp">/a/</span>[<span class="title class_">Symbol</span>.<span class="property">match</span>](<span class="string">&#x27;abc&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p>返回用替换器替换相应匹配项后的新字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/a/</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"><span class="regexp">/a/</span>[<span class="title class_">Symbol</span>.<span class="property">replace</span>](<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;A&#x27;</span>);</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><p>如果成功的话，<code>[@@search]()</code> 返回该正则模式的第一个匹配项的在字符串中的位置索引。否则将返回-1。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">search</span>(<span class="regexp">/a/</span>);</span><br><span class="line"><span class="regexp">/a/</span>[<span class="title class_">Symbol</span>.<span class="property">search</span>](<span class="string">&#x27;abc&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="split"><a href="#split" class="headerlink" title="split"></a>split</h4><p>切割字符串</p>
<p>返回包含其子字符串的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a-b-c&#x27;</span>.<span class="title function_">split</span>(<span class="regexp">/-/</span>); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="regexp">/-/</span>[<span class="title class_">Symbol</span>.<span class="property">split</span>](<span class="string">&#x27;a-b-c&#x27;</span>);</span><br></pre></td></tr></table></figure>
<br>

<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h3 id="u修饰符"><a href="#u修饰符" class="headerlink" title="u修饰符"></a>u修饰符</h3><p>ES6 对正则表达式添加了<code>u</code>修饰符，含义为“Unicode 模式”，用来正确处理大于<code>\uFFFF</code>的 Unicode 字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/^\uD83D/u.<span class="title function_">test</span>(<span class="string">&#x27;\uD83D\uDC2A&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/^\uD83D/.<span class="title function_">test</span>(<span class="string">&#x27;\uD83D\uDC2A&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为<code>true</code>。</p>
<h5 id="RegExp-prototype-unicode"><a href="#RegExp-prototype-unicode" class="headerlink" title="RegExp.prototype.unicode"></a>RegExp.prototype.unicode</h5><p>查看正则对象是否设置了<code>u</code>修饰符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> r1 = <span class="regexp">/hello/</span>;</span><br><span class="line"><span class="keyword">const</span> r2 = <span class="regexp">/hello/u</span>;</span><br><span class="line"></span><br><span class="line">r1.<span class="property">unicode</span> <span class="comment">// false</span></span><br><span class="line">r2.<span class="property">unicode</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="i修饰符"><a href="#i修饰符" class="headerlink" title="i修饰符"></a>i修饰符</h3><p>表示不区分大小写</p>
<p>并且和<code>u</code>修饰符一起用，可以识别非规范的字符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/[a-z]/i.<span class="title function_">test</span>(<span class="string">&#x27;\u212A&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/[a-z]/iu.<span class="title function_">test</span>(<span class="string">&#x27;\u212A&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="y修饰符"><a href="#y修饰符" class="headerlink" title="y修饰符"></a>y修饰符</h3><p><code>y</code>修饰符也叫做粘连修饰符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;aaa_aa_a&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/a+/g</span>;</span><br><span class="line"><span class="keyword">var</span> r2 = <span class="regexp">/a+/y</span>;</span><br><span class="line"></span><br><span class="line">r1.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;aaa&quot;]</span></span><br><span class="line">r2.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;aaa&quot;]</span></span><br><span class="line"></span><br><span class="line">r1.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;aa&quot;]</span></span><br><span class="line">r2.<span class="title function_">exec</span>(s) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>使用<code>y</code>修饰符每次匹配，都是从剩余字符串的头部开始。所以上面代码的第二次匹配的头部是<code>_</code>，故匹配不到。</p>
<p><code>y</code>修饰符的设计本意，就是让头部匹配的标志<code>^</code>在全局匹配中都有效。</p>
<h5 id="RegExp-prototype-sticky"><a href="#RegExp-prototype-sticky" class="headerlink" title="RegExp.prototype.sticky"></a>RegExp.prototype.sticky</h5><p>与<code>y</code>修饰符相匹配，ES6 的正则实例对象多了<code>sticky</code>属性，表示是否设置了<code>y</code>修饰符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/hello\d/y</span>;</span><br><span class="line">r.<span class="property">sticky</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="RegExp-prototype-flags"><a href="#RegExp-prototype-flags" class="headerlink" title="RegExp.prototype.flags"></a>RegExp.prototype.flags</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 的 source 属性</span></span><br><span class="line"><span class="comment">// 返回正则表达式的正文</span></span><br><span class="line">/abc/ig.<span class="property">source</span></span><br><span class="line"><span class="comment">// &quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的 flags 属性</span></span><br><span class="line"><span class="comment">// 返回正则表达式的修饰符</span></span><br><span class="line">/abc/ig.<span class="property">flags</span></span><br><span class="line"><span class="comment">// &#x27;gi&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="s修饰符"><a href="#s修饰符" class="headerlink" title="s修饰符"></a>s修饰符</h3><p>ES2018 <a href="https://github.com/tc39/proposal-regexp-dotall-flag">引入</a><code>s</code>修饰符，使得<code>.</code>可以匹配任意单个字符。</p>
<p>正则表达式中，点（<code>.</code>）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用<code>u</code>修饰符解决；另一个是行终止符（line terminator character）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/foo.<span class="property">bar</span>/s.<span class="title function_">test</span>(<span class="string">&#x27;foo\nbar&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<br>

<h2 id="后行断言"><a href="#后行断言" class="headerlink" title="后行断言"></a>后行断言</h2><p>ES2018引入后行断言</p>
<h5 id="什么是先行断言"><a href="#什么是先行断言" class="headerlink" title="什么是先行断言"></a>什么是先行断言</h5><p>“先行断言”指的是，<code>x</code>只有在<code>y</code>前面才匹配，必须写成<code>/x(?=y)/</code>。比如，只匹配百分号之前的数字，要写成<code>/\d+(?=%)/</code>。“先行否定断言”指的是，<code>x</code>只有不在<code>y</code>前面才匹配，必须写成<code>/x(?!y)/</code>。比如，只匹配不在百分号之前的数字，要写成<code>/\d+(?!%)/</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/\d+(?=%)/.<span class="title function_">exec</span>(<span class="string">&#x27;100% of US presidents have been male&#x27;</span>)  <span class="comment">// [&quot;100&quot;]</span></span><br><span class="line">/\d+(?!%)/.<span class="title function_">exec</span>(<span class="string">&#x27;that’s all 44 of them&#x27;</span>)                 <span class="comment">// [&quot;44&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，“先行断言”括号之中的部分（(?=%)），是不计入返回结果的。</p>
<h5 id="什么是后行断言"><a href="#什么是后行断言" class="headerlink" title="什么是后行断言"></a>什么是后行断言</h5><p>“后行断言”正好与“先行断言”相反，<code>x</code>只有在<code>y</code>后面才匹配，必须写成<code>/(?&lt;=y)x/</code>。比如，只匹配美元符号之后的数字，要写成<code>/(?&lt;=\$)\d+/</code>。“后行否定断言”则与“先行否定断言”相反，<code>x</code>只有不在<code>y</code>后面才匹配，必须写成<code>/(?&lt;!y)x/</code>。比如，只匹配不在美元符号后面的数字，要写成<code>/(?&lt;!\$)\d+/</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/(?&lt;=\$)\d+<span class="regexp">/.exec(&#x27;Benjamin Franklin is on the $100 bill&#x27;)  /</span><span class="regexp">/ [&quot;100&quot;]</span></span><br><span class="line"><span class="regexp">/</span>(?&lt;!\$)\d+<span class="regexp">/.exec(&#x27;it’s is worth about €90&#x27;)                /</span><span class="regexp">/ [&quot;90&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中，“后行断言”的括号之中的部分（<code>(?&lt;=\$)</code>），也是不计入返回结果。<br><br></p>
<h2 id="具体名匹配"><a href="#具体名匹配" class="headerlink" title="具体名匹配"></a>具体名匹配</h2><p>ES2018 引入了<a href="https://github.com/tc39/proposal-regexp-named-groups">具名组匹配</a>（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。</p>
<p>不使用具体组匹配的写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">RE_DATE</span> = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = <span class="variable constant_">RE_DATE</span>.<span class="title function_">exec</span>(<span class="string">&#x27;1999-12-31&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj[<span class="number">1</span>]; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj[<span class="number">2</span>]; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj[<span class="number">3</span>]; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>

<p>matchObj的值是一个类数组对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="string">&#x27;1999-12-31&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;1999&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;12&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;31&#x27;</span>,</span><br><span class="line">  <span class="attr">index</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">input</span>: <span class="string">&#x27;1999-12-31&#x27;</span>,</span><br><span class="line">  <span class="attr">groups</span>: <span class="literal">undefined</span> ]</span><br></pre></td></tr></table></figure>

<p>使用具体组匹配的写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">RE_DATE</span> = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = <span class="variable constant_">RE_DATE</span>.<span class="title function_">exec</span>(<span class="string">&#x27;1999-12-31&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj.<span class="property">groups</span>.<span class="property">year</span>; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj.<span class="property">groups</span>.<span class="property">month</span>; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj.<span class="property">groups</span>.<span class="property">day</span>; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>

<p>matchObj的值是一个类数组对象，但是groups属性有值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[ <span class="string">&#x27;1999-12-31&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;1999&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;12&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;31&#x27;</span>,</span><br><span class="line">  <span class="attr">index</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">input</span>: <span class="string">&#x27;1999-12-31&#x27;</span>,</span><br><span class="line">  <span class="attr">groups</span>: [<span class="title class_">Object</span>: <span class="literal">null</span> prototype] &#123; <span class="attr">year</span>: <span class="string">&#x27;1999&#x27;</span>, <span class="attr">month</span>: <span class="string">&#x27;12&#x27;</span>, <span class="attr">day</span>: <span class="string">&#x27;31&#x27;</span> &#125; ]</span><br></pre></td></tr></table></figure>

<h5 id="解构赋值和替换"><a href="#解构赋值和替换" class="headerlink" title="解构赋值和替换"></a>解构赋值和替换</h5><p>有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">groups</span>: &#123;one, two&#125;&#125; = <span class="regexp">/^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u</span>.<span class="title function_">exec</span>(<span class="string">&#x27;foo:bar&#x27;</span>);</span><br><span class="line">one  <span class="comment">// foo</span></span><br><span class="line">two  <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>

<h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><p>如果要在正则表达式内部引用某个“具名组匹配”，可以使用<code>\k&lt;组名&gt;</code>的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">RE_TWICE</span> = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;$/</span>;</span><br><span class="line"><span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!abc&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!ab&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以这样写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">RE_TWICE</span> = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!(\1)!\2$/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!abc!abc&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!abc!ab&#x27;</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>数字引用（<code>\1</code>）依然有效。</p>
<p><code>\1</code>是反向引用的意思，表示获取第一个<code>()</code>匹配的引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">RE_TWICE</span> = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\1$/</span>;</span><br><span class="line"><span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!abc&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!ab&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>当然这两种引用语法还可以同时使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">RE_TWICE</span> = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;!\1$/</span>;</span><br><span class="line"><span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!abc!abc&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!abc!ab&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>ps: 正则的用法妙不可言，平时用的比较少，就记一下这些常用的吧。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>重学数据结构算法</title>
    <url>/2020/06/21/%E9%87%8D%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>在拉钩1块钱抢了一个算法课程，讲的还不错，记下笔记。</p>
<p>一共有21节课，抽时间看，持续更新。</p>
<p>课程二维码在最后</p>
<h2 id="第一讲"><a href="#第一讲" class="headerlink" title="第一讲"></a>第一讲</h2><h3 id="时间复杂度和代码结构的关系"><a href="#时间复杂度和代码结构的关系" class="headerlink" title="时间复杂度和代码结构的关系"></a>时间复杂度和代码结构的关系</h3><h4 id="一些经验性的结论"><a href="#一些经验性的结论" class="headerlink" title="一些经验性的结论"></a>一些经验性的结论</h4><ul>
<li>一个顺序结构的代码，时间复杂度是<strong>O(1)</strong></li>
<li>二分查找，或者更通用的说是采用分而治之的二分策略，时间复杂度都是<strong>O(logn)</strong></li>
<li>一个<strong>for</strong>循环，时间复杂度是<strong>O(n)</strong></li>
<li>两个顺序执行的<strong>for</strong>循环，时间复杂度<strong>O(n)+O(n)=O(2n)<strong>，最终也是</strong>O(n)</strong></li>
<li>两个嵌套的<strong>for</strong>循环，时间复杂度是<strong>O(n^2)</strong></li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>复杂度通常包括<strong>时间复杂度</strong>和<strong>空间复杂度</strong><br>在具体计算复杂度时需要注意：</p>
<ul>
<li>它与具体的常系数无关，**O(2n)<strong>和</strong>O(n)**表示的是同样的复杂度</li>
<li>复杂度相加的时候，选择高者作为结果，也就是**O(n^2)+O(n)<strong>和</strong>O(n^2)**表示同样的复杂度</li>
<li><strong>O(1)<strong>是一个特殊的复杂度，即任务与算例个数</strong>n</strong>无关</li>
</ul>
<p><strong>时间复杂度</strong>与代码结构设计高度相关<br><strong>空间复杂度</strong>与代码中数据结构的选择高度相关</p>
<h2 id="第二讲"><a href="#第二讲" class="headerlink" title="第二讲"></a>第二讲</h2><span id="more"></span>

<h3 id="程序优化"><a href="#程序优化" class="headerlink" title="程序优化"></a>程序优化</h3><p>降低复杂度，直观的思路：梳理流程，看其流程中是否有无效的计算或者无效的存储<br>常用的降低时间复杂度的方法：</p>
<ul>
<li>递归、二分法、排序算法、动态规划</li>
</ul>
<p>降低空间负责度的核心思路：</p>
<ul>
<li>能用低复杂度的数据结构解决的问题，就千万不要用高复杂度的数据结构</li>
</ul>
<h3 id="数据结构连接时空"><a href="#数据结构连接时空" class="headerlink" title="数据结构连接时空"></a>数据结构连接时空</h3><p>在程序开发中，连接<strong>时间</strong>和<strong>空间</strong>的桥梁就是<strong>数据结构</strong><br><strong>空间换时间</strong>：对于一个开发任务，如果能找到一种高效的数据组织方式，<strong>采用合理的数据结构</strong>就可以实现时间复杂度的再次降低，这通常会<strong>增加数据的存储量</strong>，也就是<strong>增加了空间的复杂度</strong>。</p>
<h3 id="程序优化步骤"><a href="#程序优化步骤" class="headerlink" title="程序优化步骤"></a>程序优化步骤</h3><h4 id="第一步，暴力解法"><a href="#第一步，暴力解法" class="headerlink" title="第一步，暴力解法"></a>第一步，暴力解法</h4><p>在没有任何时间、空间的约束下，完成代码任务的开发</p>
<h4 id="第二步，无效操作处理"><a href="#第二步，无效操作处理" class="headerlink" title="第二步，无效操作处理"></a>第二步，无效操作处理</h4><p>将代码中的无效计算，无效存储剔除，降低时间或空间复杂度</p>
<h4 id="第三步，时空转换"><a href="#第三步，时空转换" class="headerlink" title="第三步，时空转换"></a>第三步，时空转换</h4><p>设计合理的数据结构，完成时间复杂度向空间复杂度的转移</p>
<h2 id="第三讲"><a href="#第三讲" class="headerlink" title="第三讲"></a>第三讲</h2><h3 id="数据处理的基本操作"><a href="#数据处理的基本操作" class="headerlink" title="数据处理的基本操作"></a>数据处理的基本操作</h3><p>即便是很复杂的代码，它对数据的处理也只有这3个基本操作：<strong>增删查</strong></p>
<p>常用的分析方法可以参考下面三个步骤：</p>
<ol>
<li>这段代码对数据进行了哪些操作？</li>
<li>这些操作中，哪个操作最影响效率，对时间复杂度的损耗最大？</li>
<li>哪种数据结构最能帮助你提高数据操作的使用效率？</li>
</ol>
<h3 id="数据操作与数据结构案例"><a href="#数据操作与数据结构案例" class="headerlink" title="数据操作与数据结构案例"></a>数据操作与数据结构案例</h3><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><ul>
<li>根据<strong>元素的位置或索引</strong>来查找</li>
<li>根据<strong>元素的数值特</strong>征来查找</li>
</ul>
<h4 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h4><p>有两个可能：</p>
<ul>
<li>在这个复杂<strong>数据结构的最后</strong>，新增一条数据</li>
<li>在这个复杂<strong>数据结构的中间某个位置</strong>，新增一条数据</li>
</ul>
<p><strong>区别</strong>：新增数据之后，是否会导致原有数据结构中数据位置顺序改变</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>有两个可能</p>
<ul>
<li>在这个复杂<strong>数据结构的最后</strong>，删除一条数据</li>
<li>在这个复杂<strong>数据结构的中间某个位置</strong>，删除一条数据</li>
</ul>
<p><strong>区别</strong>：删除数据之后，是否会导致原有数据结构中数据位置顺序改变</p>
<h2 id="第四讲"><a href="#第四讲" class="headerlink" title="第四讲"></a>第四讲</h2><h3 id="什么是数据结构？"><a href="#什么是数据结构？" class="headerlink" title="什么是数据结构？"></a>什么是数据结构？</h3><p>数据的组织方式</p>
<h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><ul>
<li>单向链表</li>
<li>双向链表</li>
<li>循环链表</li>
<li>双向循环链表</li>
</ul>
<p>链表的优缺点：</p>
<ul>
<li>链表在新增和删除数据都可以在**O(1)**的时间复杂度内完成</li>
<li>对于查找，无论是按照索引查找还是按照特征值查找，都需要对全部数据进行遍历，都是**O(n)**的时间复杂度</li>
</ul>
<p>总结：</p>
<ul>
<li>链表虽然在<strong>新增</strong>和<strong>删除</strong>数据有优势，但是这种优势并不实用，因为<strong>在新增和删除数据时，都会伴随着一个查找操作。</strong></li>
<li>链表真正的价值在于，它对数据的<strong>存储方式是按照顺序的存储</strong>。</li>
<li>如果数据<strong>元素不确定</strong>，且<strong>经常需要进行数据的新增和删除</strong>时，那么链表比较合适</li>
<li>如果数据<strong>元素大小确定</strong>，<strong>删除插入操作并不多</strong>，那么数组可能更合适。</li>
</ul>
<h3 id="线性表案例"><a href="#线性表案例" class="headerlink" title="线性表案例"></a>线性表案例</h3><h4 id="单向链表的翻转"><a href="#单向链表的翻转" class="headerlink" title="单向链表的翻转"></a>单向链表的翻转</h4><p><a href="https://github.com/ruomuc/practice/blob/master/other/algorithm/lianbiao.js">代码实现</a></p>
<h4 id="找出奇数链表中间位置节点的值"><a href="#找出奇数链表中间位置节点的值" class="headerlink" title="找出奇数链表中间位置节点的值"></a>找出奇数链表中间位置节点的值</h4><p>思路： 一个快指针一个慢指针，慢指针每次向后移动一个元素，快指针每次向后移动两个元素，当快指针的next是null时，慢指针所在就是中间节点。<br><a href="https://github.com/ruomuc/practice/blob/master/other/algorithm/lianbiao2.js">代码实现</a></p>
<h4 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h4><p>思路： 一个快指针一个慢指针，当快慢指针相遇，说明链表有环。</p>
<p><a href="https://github.com/ruomuc/practice/blob/master/other/algorithm/lianbiao3.js">代码实现</a></p>
<h2 id="第五讲"><a href="#第五讲" class="headerlink" title="第五讲"></a>第五讲</h2><h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><p>栈的顺序存储可以借助数组来实现。</p>
<ol>
<li>把数组首元素存在栈底，最后一个元素放在栈顶。</li>
<li>然后定义一个top指针来指示栈顶元素在数组中的位置。</li>
</ol>
<h3 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h3><p>用链表的方式对栈表示，通常，可以把栈顶放在单链表头部。</p>
<p><a href="https://github.com/ruomuc/practice/blob/master/other/algorithm/stack.js">顺序栈和链式栈的代码实现</a></p>
<h3 id="栈与线性表"><a href="#栈与线性表" class="headerlink" title="栈与线性表"></a>栈与线性表</h3><ul>
<li>相同点：操作原理完全相似，时间复杂度完全一样，都依赖当前位置的指针来进行数据对象的操作。</li>
<li>区别：新增和删除的对象，只能是栈顶的数据结点。</li>
</ul>
<h3 id="栈的案例"><a href="#栈的案例" class="headerlink" title="栈的案例"></a>栈的案例</h3><p><strong>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：左括号必须与相同类型的右括号匹配，左括号必须以正确的顺序匹配。例如，{ [ ( ) ( ) ] } 是合法的，而 { ( [ ) ] } 是非法的。</strong></p>
<p>思路： 使用栈的先进后出规则，遇到左括号进栈，遇到右括号出栈并且判断是否匹配。</p>
<p><a href="https://github.com/ruomuc/practice/blob/master/other/algorithm/stack2.js">代码实现</a></p>
<p><strong>仿照浏览器的前进后退功能，利用栈来记录用户的浏览信息</strong></p>
<p>思路：用一个前进栈和一个后退栈分别保存，前进时，前进栈出栈后退站栈进栈，后退时，后退栈出栈，前进栈进栈。</p>
<p><a href="https://github.com/ruomuc/practice/blob/master/other/algorithm/stack3.js">代码实现</a></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>栈具有<strong>先进后出</strong>的特性，当面对的问题需要高频使用新增、删除操作且新增和删除操作的数据执行顺序具备<strong>后来居上</strong>的相反关系时，栈就是个不错的选择。。</p>
<h2 id="第六讲"><a href="#第六讲" class="headerlink" title="第六讲"></a>第六讲</h2><h3 id="队列是什么"><a href="#队列是什么" class="headerlink" title="队列是什么"></a>队列是什么</h3><p>队列也是一种特殊的线性表，与线性表的不同之处体现在对数据的增和删的操作上。</p>
<p>队列的特点：</p>
<ul>
<li>先进：队列的数据新增操作只能在末端进行，不允许在队列的中间某个节点新增数据。</li>
<li>先出：队列的数据删除操作只能在始端进行，不允许在队列的中间某个节点后删除数据。</li>
</ul>
<p>顺序队列：</p>
<ul>
<li>使用数据实现。新增O(1)，删除O(n)。</li>
<li>使用<a href="https://github.com/ruomuc/practice/blob/master/other/algorithm/loopQueueByArray.js">循环队列</a>。新增O(1)，删除O(1)。</li>
</ul>
<p>链式队列：</p>
<ul>
<li>使用链表实现。</li>
<li><a href="https://github.com/ruomuc/practice/blob/master/other/algorithm/linkQueue.js">代码如下</a></li>
</ul>
<h3 id="队列的案例"><a href="#队列的案例" class="headerlink" title="队列的案例"></a>队列的案例</h3><p><strong>约瑟夫环的问题</strong></p>
<p>思路：构造一个循环队列（大于人数），定义计数变量<code>i</code>，开始出队，当<code>i= m</code>时，将这个人放入一个数组，如果<code>i!=m</code>，出队后再入队，继续上述步骤。</p>
<p><a href="https://github.com/ruomuc/practice/blob/master/other/algorithm/josephRing.js">约瑟夫环代码实现</a></p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><strong>在时间复杂度上</strong></p>
<ul>
<li>循环队列和链式队列的新增删除操作都为O(1)</li>
<li>在查找操作中，队列只能通过全局遍历的方式进行，需要O(n)的时间复杂度</li>
</ul>
<p><strong>在空间性能上</strong></p>
<ul>
<li>循环队列必须有一个固定的长度，因此存在存储元素数量和空间浪费的问题。</li>
<li>链式队列更为灵活一些。</li>
</ul>
<h2 id="第七讲"><a href="#第七讲" class="headerlink" title="第七讲"></a>第七讲</h2><h3 id="数组增删查的时间复杂度"><a href="#数组增删查的时间复杂度" class="headerlink" title="数组增删查的时间复杂度"></a>数组增删查的时间复杂度</h3><ul>
<li>增加：尾部插入，时间复杂度O(1)，中间某处插入数据，时间复杂度为O(n)。</li>
<li>删除：指定元素的删除，扫描全数组，时间复杂度为O(n)。</li>
<li>查找：根据索引查找，时间复杂度O(1)，根据元素值查找，时间复杂度O(n)。</li>
</ul>
<h3 id="链表存在的价值是什么呢"><a href="#链表存在的价值是什么呢" class="headerlink" title="链表存在的价值是什么呢"></a>链表存在的价值是什么呢</h3><ul>
<li>链表的长度的可变的，数组的长度是固定的，在申请数据长度时，就已经在内存中开辟了若干个空间。</li>
<li>链表在内存中不是顺序存储的，可以充分利用内存空间。</li>
</ul>
<h2 id="第八讲"><a href="#第八讲" class="headerlink" title="第八讲"></a>第八讲</h2><h3 id="字符串的顺序存储和链式存储"><a href="#字符串的顺序存储和链式存储" class="headerlink" title="字符串的顺序存储和链式存储"></a>字符串的顺序存储和链式存储</h3><p><strong>顺序存储</strong></p>
<p>是用一组地址连续的存储单元来存储串中的字符序列，一般用定长数组实现。</p>
<p><strong>链式存储</strong></p>
<p>因为字符串结构中，每一个元素都是一个字符，如果简单的将每个链节点存储为一个字符，就会造成很大的空间浪费。</p>
<p>所以可以在每个链节点存入多个字符，最后一个节点尾部用其他符号补全。</p>
<ul>
<li>如果字符串包含的数据量很大，就应该减少链节点，在每个节点放入更多的字符。</li>
<li>如果需要对字符串进行大量的插入和删除数据，如果每个链节点包含的数据过多，操作就会变得很麻烦。</li>
</ul>
<p>总结：链式存储没有顺序存储灵活。性能也没有顺序存储好。</p>
<h3 id="字符串的操作"><a href="#字符串的操作" class="headerlink" title="字符串的操作"></a>字符串的操作</h3><p><strong>字符串的新增操作</strong></p>
<ul>
<li>在中间新增，时间复杂度O(n)</li>
<li>在尾部新增，时间复杂度O(1)</li>
</ul>
<p><strong>字符串的删除操作</strong></p>
<ul>
<li>在中间删除，时间复杂度O(n)</li>
<li>在尾部删除，时间复杂度O(1)</li>
</ul>
<p><strong>字符串的查找操作</strong></p>
<blockquote>
<p><strong>例题1</strong>：假设要从主串 s = “goodgoogle” 中找到 t = “google” 子串。</p>
</blockquote>
<p>思路：</p>
<ul>
<li><p>首先，我们从主串 s 第 1 位开始，判断 s 的第 1 个字符是否与 t 的第 1 个字符相等。</p>
</li>
<li><p>如果不相等，则继续判断主串的第 2 个字符是否与 t 的第1 个字符相等。直到在 s 中找到与 t 第一个字符相等的字符时，然后开始判断它之后的字符是否仍然与 t 的后续字符相等。</p>
</li>
<li><p>如果持续相等直到 t 的最后一个字符，则匹配成功。</p>
</li>
<li><p>如果发现一个不等的字符，则重新回到前面的步骤中，查找 s 中是否有字符与 t 的第一个字符相等。</p>
</li>
</ul>
<p><a href="https://github.com/ruomuc/practice/blob/master/other/algorithm/subString.js">代码实现</a></p>
<blockquote>
<p><strong>例题2</strong>：假设有且仅有 1 个最大公共子串。比如，输入 a = “13452439”， b = “123456”。由于字符串 “345” 同时在 a 和 b 中出现，且是同时出现在 a 和 b 中的最长子串。因此输出 “345”。</p>
</blockquote>
<p>思路：和上面的查找字符串是否包含的思路差不多。多了一个同步遍历的for循环，多维护两个变量存储最长子串的内容和长度。</p>
<p><a href="https://github.com/ruomuc/practice/blob/master/other/algorithm/largestPublicString.js">代码实现</a> </p>
<h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><p>翻转字符串：给定一个字符串，逐个翻转字符串中的每个单词。例如，输入: “the sky is blue”，输出: “blue is sky the”。</p>
<p>思路：</p>
<ol>
<li><p>第一眼看到翻转，我会想到用栈。</p>
</li>
<li><p>先创建一个临时栈和结果栈，遍历字符串入栈，遇到空格时，临时栈出栈并放入另一个栈中，最后入栈一个空字符串。</p>
</li>
<li><p>结果栈出栈，拼接为一个字符串并返回。</p>
</li>
</ol>
<p><a href="https://github.com/ruomuc/practice/blob/master/other/algorithm/reverseWords.js">代码实现</a></p>
<h2 id="第九讲"><a href="#第九讲" class="headerlink" title="第九讲"></a>第九讲</h2><h3 id="树是什么"><a href="#树是什么" class="headerlink" title="树是什么"></a>树是什么</h3><p>树是由节点和边组成的，不存在环的一种数据结构。</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树中，每个节点最多有两个分支。即每个节点最多有两个子节点，分别称作左子节点和右子节点。</p>
<p><strong>满二叉树</strong></p>
<p>除了叶子节点，所有节点都有两个子节点。</p>
<p><strong>完全二叉树</strong></p>
<p>除了最后一层以外，其它层的节点个数都达到最大，并且最后一层的叶子节点都靠左排列。</p>
<p>完全二叉树为什么叫完全二叉树？</p>
<p>从存储空间的利用率来看，不完全二叉树，按照<strong>顺序存储</strong>会浪费大量空间。。</p>
<p><strong>链式存储</strong></p>
<p>像链表一样，每个节点有三个字段，一个存储数据，另外两个分别存放指向左右两个节点的指针。</p>
<p><strong>顺序存储</strong></p>
<p>按照规律吧节点放进数组里。如果根节点从0开始，<code>left=root*2+1  right=root*2+2</code>；从1开始，<code>left=root*2 right=root*2+1</code>。</p>
<h3 id="树的基本操作"><a href="#树的基本操作" class="headerlink" title="树的基本操作"></a>树的基本操作</h3><p><strong>树的遍历</strong></p>
<ul>
<li>前序遍历：父节点-&gt;左子节点-&gt;右子节点</li>
<li>中序遍历：左子节点-&gt;父节点-&gt;右子节点</li>
<li>后序遍历：左子节点-&gt;右子节点-&gt;父节点</li>
</ul>
<p><a href="https://github.com/ruomuc/practice/blob/master/other/algorithm/bTree.js">二叉树的前中后序遍历递归实现</a></p>
<p><a href="https://github.com/ruomuc/practice/blob/master/other/algorithm/bTree2.js">二叉树的前中后序遍历栈实现</a></p>
<p>二叉树的遍历，时间复杂度为O(n)。</p>
<p>对于没有任何特殊性质的二叉树，删除和新增操作时间复杂度为O(1)。</p>
<p>查找操作，需要遍历每一个节点去判断，时间复杂度为O(n)。</p>
<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p><strong>特性</strong></p>
<ul>
<li>二叉查找树中任意一个节点，其左子节点的值一定小于这个节点的值。</li>
<li>二叉查找树中任意一个节点，其右子节点的值一定大于这个节点的值。</li>
<li>在二叉查找树中，会尽可能规避两个节点数值相等的情况。 </li>
<li>对二叉查找树进行中序遍历，就可以输出一个从小到大的有序数据队列。如下图所示，中序遍历的结果就是 10、13、15、16、20、21、22、26。</li>
</ul>
<p><strong>二叉查找树的查找操作</strong><br>在利用二叉查找树执行查找操作时，我们可以进行以下判断：</p>
<ul>
<li><p>首先判断根结点是否等于要查找的数据，如果是就返回。</p>
</li>
<li><p>如果根结点大于要查找的数据，就在左子树中递归执行查找动作，直到叶子结点。</p>
</li>
<li><p>如果根结点小于要查找的数据，就在右子树中递归执行查找动作，直到叶子结点。</p>
</li>
</ul>
<p><strong>二叉查找树的插入操作</strong></p>
<ul>
<li>情况一，如果要删除的结点是某个叶子结点，则直接删除，将其父结点指针指向 null 即可。</li>
<li>情况二，如果要删除的结点只有一个子结点，只需要将其父结点指向的子结点的指针换成其子结点的指针即可。</li>
<li>情况三，如果要删除的结点有两个子结点，则有两种可行的操作方式。<ul>
<li>第一种，找到这个结点的左子树中最大的结点，替换要删除的结点。</li>
<li>第二种，找到这个结点的右子树中最小的结点，替换要删除的结点。</li>
</ul>
</li>
</ul>
<h3 id="树的案例"><a href="#树的案例" class="headerlink" title="树的案例"></a>树的案例</h3><blockquote>
<p>输入一个字符串，判断它在已有的字符串集合中是否出现过?（假设集合中没有某个字符串与另一个字符串拥有共同前缀且完全包含的特殊情况，例如 deep 和 dee。）如，已有字符串集合包含 6 个字符串分别为，cat, car, city, dog,door, deep。输入 cat，输出 true；输入 home，输出 false。</p>
</blockquote>
<p>思路：</p>
<ol>
<li>首先把集合中的子串，按照字节查分，实现一个字典树。</li>
<li>判断输入字符串，按顺序匹配书中的节点，最后以为如果是叶子节点，则说明存在。</li>
</ol>
<p><a href="https://github.com/ruomuc/practice/blob/master/other/algorithm/dictTree.js">代码实现</a></p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>二叉树的遍历操作，时间复杂度都是O(n)。</li>
<li>二叉树的单纯增删操作，时间复杂度都是O(1)。(但是有特性的树增删一般伴随着查找或自平衡)。</li>
<li>普通二叉树的查找操作时间复杂度是O(n)；二叉查找树的查找操作时间复杂度为O(logn)。</li>
</ul>
<h3 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h3><p>给定一棵树，按照层次顺序遍历并打印这棵树。</p>
<p><a href="https://github.com/ruomuc/practice/blob/master/other/algorithm/bTree3.js">层序遍历代码实现</a></p>
<h2 id="第十讲"><a href="#第十讲" class="headerlink" title="第十讲"></a>第十讲</h2><h3 id="哈希表的核心思想"><a href="#哈希表的核心思想" class="headerlink" title="哈希表的核心思想"></a>哈希表的核心思想</h3><p><strong>哈希表</strong>的设计采用了<strong>函数映射</strong>的思想，将记录的存储位置与记录的关键字关联起来。这样的方式能够快速定位到自己想要查找的记录，而且不需要和表中存在的记录的关键字比较后再来进行查找。</p>
<p>数组的局限性是，他可以通过索引来查找，但是不能通过了数据的数值去查找。但是如果有一个方法可以使<code>f(数值) = index</code>,那就可以通过数值找索引，索引找值。</p>
<h3 id="如何设计哈希函数"><a href="#如何设计哈希函数" class="headerlink" title="如何设计哈希函数"></a>如何设计哈希函数</h3><h4 id="直接定制法"><a href="#直接定制法" class="headerlink" title="直接定制法"></a>直接定制法</h4><p>哈希函数为关键字到地址的线性函数。</p>
<p><code>H（key） = a * key + b</code></p>
<p>a，b是常数</p>
<h4 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h4><p>假设关键字集合中的每个关键字<code>key</code>都是由<code>s</code>位数字组成<code>（k1,k2,...,ks）</code></p>
<p>并从中提取均匀分布的若干位组成哈希地址</p>
<h4 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h4><p>如果关键字每一位都有某些数字重复出现，并且频率很高</p>
<p>可以先求关键字的平方值，通过平方值扩大差异，然后取中间几位作为最终存储地址</p>
<h4 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h4><p>如果关键字的位数很多，可以将关键字分割为几个等长的部分</p>
<p>取它们的叠加和的值（舍去进位）作为哈希地址</p>
<h4 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h4><p>预先设置一个数<code>p</code>，然后对关键字进行取余运算。</p>
<p>地址 = <code>key % p</code></p>
<h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>无论哈希函数设计的多好，理论上来说只要输入的数据足够多，哈希冲突就必然会发生，所以哈希冲突只能减少，无法避免。</p>
<h4 id="开放寻址法（开放定址法）"><a href="#开放寻址法（开放定址法）" class="headerlink" title="开放寻址法（开放定址法）"></a>开放寻址法（开放定址法）</h4><p>当遇到哈希冲突时，使用某种探测技术在哈希表形成一个探测序列，然后沿着这个探测序列一次查找下去，当碰到一个空单元时，则插入其中。</p>
<p>假设有一组关键字：[12,13,25,23]，采用哈希函数为除留余数法：<code>H(key) = key % 11</code></p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>插入12</td>
<td></td>
<td>12</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>插入13</td>
<td></td>
<td></td>
<td>13</td>
<td></td>
<td></td>
</tr>
<tr>
<td>插入25</td>
<td></td>
<td></td>
<td></td>
<td>25</td>
<td></td>
</tr>
<tr>
<td>插入23</td>
<td></td>
<td>冲突1</td>
<td>冲突2</td>
<td>冲突3</td>
<td>23</td>
</tr>
</tbody></table>
<h4 id="链地址法（链表法）"><a href="#链地址法（链表法）" class="headerlink" title="链地址法（链表法）"></a>链地址法（链表法）</h4><p>将哈希地址相同的记录存储在一张线性表中</p>
<h3 id="哈希表的优缺点"><a href="#哈希表的优缺点" class="headerlink" title="哈希表的优缺点"></a>哈希表的优缺点</h3><h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><ul>
<li>提供非常快速的插入-删除-查找操作。</li>
<li>查找操作速度比树还要快</li>
</ul>
<h4 id="不足："><a href="#不足：" class="headerlink" title="不足："></a>不足：</h4><ul>
<li>哈希表的数据没有顺序的概念</li>
<li>哈希表的<code>key</code>不允许重复</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><blockquote>
<p>例1：将关键字序列 {7, 8, 30, 11, 18, 9, 14} 存储到哈希表中。哈希函数为： H (key) = (key * 3) % 7，处理冲突采用线性探测法。</p>
</blockquote>
<p><a href="https://github.com/ruomuc/practice/blob/master/other/algorithm/hashtable.js">代码实现</a></p>
<blockquote>
<p>例2：假设有一个在线系统，可以实时接收用户提交的字符串型关键字，并实时返回给用户累积至今这个关键字被提交的次数</p>
</blockquote>
<p>这个如果使用语言内置的<code>Object 或者 Map</code>的话就几行代码，没什么好说的。</p>
<h2 id="第十一讲"><a href="#第十一讲" class="headerlink" title="第十一讲"></a>第十一讲</h2><h3 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h3><p><strong>递归</strong>指的是在函数的定义中使用函数自身的方法。</p>
<p>递归有两层含义：</p>
<ul>
<li>递归问题必须可以分解为若干个规模较小，与原问题形式相同的子问题，并且这些子问题可以用<strong>完全相同的解题思路</strong>来解决。</li>
<li>递归问题的演化过程是一个对原问题从大到小进行拆解的过程，并且会有一个明确的终点（临界点），最后从这个临界点开始，把小问题的答案按照原路返回，原问题便得以解决。</li>
</ul>
<p>递归的实现包含了两个部分：</p>
<ul>
<li>递归主体</li>
<li>终止条件</li>
</ul>
<h3 id="递归的算法思想"><a href="#递归的算法思想" class="headerlink" title="递归的算法思想"></a>递归的算法思想</h3><p>递归的<strong>数学模型</strong>其实就是<strong>数学归纳法</strong></p>
<h4 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h4><p>证明：</p>
<ol>
<li>证明当<code>n=1</code>时命题成立</li>
<li>假设 <code>n=m</code>时，命题成立，name尝试推导出在<code>n=m+1</code>时命题也成立</li>
</ol>
<p>所以当一个问题同时满足以下两个条件时，就可以使用递归的方法求解：</p>
<ol>
<li>可以拆解为除了数据规模以外，求解思路完全相同的子问题</li>
<li>存在终止条件</li>
</ol>
<h4 id="二叉树的中序遍历分析"><a href="#二叉树的中序遍历分析" class="headerlink" title="二叉树的中序遍历分析"></a>二叉树的中序遍历分析</h4><p>分析：</p>
<ol>
<li>对二叉树中的任意结点<ol>
<li>中序遍历左子树</li>
<li>打印这个结点</li>
<li>中序遍历右子树</li>
</ol>
</li>
<li>当某个结点没有左子树或右子树时，终止。</li>
</ol>
<p>当然，这个思路也适用与<strong>前序</strong>和<strong>后序</strong>遍历。</p>
<p><a href="https://github.com/ruomuc/practice/blob/master/other/algorithm/bTree.js">代码很简单</a></p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>写出递归代码的关键在于：<strong>写出递推公式和找出终止条件</strong></p>
<ol>
<li>找到将大问题分解为小问题的规律，并基于此写出递推公式</li>
<li>找出终止条件，就是当找到最简单的问题时，如何写出答案</li>
<li>将递推公式和终止条件翻译成代码</li>
</ol>
<h3 id="汉罗塔问题"><a href="#汉罗塔问题" class="headerlink" title="汉罗塔问题"></a>汉罗塔问题</h3><p>汉诺塔问题是源于印度一个古老传说的益智玩具。</p>
<blockquote>
<p>大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着 64 片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上，并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p>
</blockquote>
<p><img src="https://s0.lgstatic.com/i/image/M00/25/AD/CgqCHl7wi--AaoWAAABKD6oIV5c850.png"></p>
<p>将这个问题拆解为三个小问题：</p>
<ol>
<li><p>把从小到大的<code>n-1</code>个圆盘，从<strong>x</strong>移动到<strong>y</strong></p>
</li>
<li><p>把最大的圆盘，从<strong>x</strong>移动到<strong>z</strong></p>
</li>
<li><p>把从小到大的<code>n-1</code>个圆盘，从<strong>y</strong>移动到<strong>z</strong></p>
</li>
</ol>
<p>我们发现，第一和第三个小问题都是汉罗塔问题</p>
<p>然后我们要找到终止条件：</p>
<ul>
<li>当只剩一个圆盘时，它可以自由自动，所以递归终止。</li>
</ul>
<h4 id="我的思路和理解"><a href="#我的思路和理解" class="headerlink" title="我的思路和理解"></a>我的思路和理解</h4><ul>
<li>假设从小到大有五个盘子，编号为1、2、3、4、5</li>
<li>我们把1~4当做一个整体<code>t</code>，这样只需要三步：<ul>
<li>把<code>t</code>移动到<code>y</code></li>
<li>把<code>5</code>移动到<code>z</code></li>
<li>把<code>t</code>移动到<code>z</code></li>
</ul>
</li>
<li>而我们对<code>t</code>采用相同的操作，当<code>t</code>的盘子数量为1时，递归终止，因为最小的盘子可以随便移动。</li>
</ul>
<p><a href="https://github.com/ruomuc/practice/blob/master/other/algorithm/hanio.js">代码实现</a></p>
<h2 id="第十二讲"><a href="#第十二讲" class="headerlink" title="第十二讲"></a>第十二讲</h2><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><h4 id="什么是分治法"><a href="#什么是分治法" class="headerlink" title="什么是分治法"></a>什么是分治法</h4><p>分治法的思想就是分而治之</p>
<p>将一个大问题，分解成为<code>n</code>个子问题，采用同一种解法，递归的去解决这些子问题，再将每个子问题的解合并，就得到原问题的解。</p>
<h4 id="分治问题的特征"><a href="#分治问题的特征" class="headerlink" title="分治问题的特征"></a>分治问题的特征</h4><ol>
<li><strong>难度在降低</strong>：即原问题的解决难度，随着数据的规模的缩小而降低</li>
<li><strong>问题可分</strong>：原问题可以分解为若干个规模较小的同类型问题</li>
<li><strong>解可合并</strong>：利用所有子问题的解，可以合并出原问题的解</li>
<li><strong>相互独立</strong>：各个子问题之间相互独立，某个子问题的求解不会影响到另一个子问题</li>
</ol>
<h4 id="分治法的使用方法"><a href="#分治法的使用方法" class="headerlink" title="分治法的使用方法"></a>分治法的使用方法</h4><p>分治法需要递归的分解问题再去解决问题，因此<strong>分治法在每轮递归上都包含了分解问题、解决问题、合并结果这三个步骤。</strong></p>
<h4 id="二分查找总结"><a href="#二分查找总结" class="headerlink" title="二分查找总结"></a>二分查找总结</h4><ol>
<li>二分查找的时间复杂度是<code>O(logn)</code>，这也是分治法普遍具备的特性。</li>
<li>二分查找的循环次数不确定，一般是达到某个条件就跳出循环。一般使用<code>while</code>循环加<code>break</code>跳出。</li>
<li>二分查找处理原问题必须是有序的</li>
</ol>
<h3 id="练习题-2"><a href="#练习题-2" class="headerlink" title="练习题"></a>练习题</h3><blockquote>
<p>在一个有序数组中，查找出第一个大于 9 的数字，假设一定存在。例如，arr = { -1, 3, 3, 7, 10, 14, 14 }; 则返回 10。</p>
</blockquote>
<p><a href="https://github.com/ruomuc/practice/blob/master/other/algorithm/bSearch.js">代码实现</a></p>
<h2 id="第十三讲"><a href="#第十三讲" class="headerlink" title="第十三讲"></a>第十三讲</h2><h3 id="常见排序"><a href="#常见排序" class="headerlink" title="常见排序"></a>常见排序</h3><p><a href="https://github.com/ruomuc/practice/blob/master/other/algorithm/sort.js">代码实现</a></p>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>时间复杂度：Ï</p>
<ul>
<li>当输入有序，时间复杂度<code>O(n)</code></li>
<li>当输入逆序，时间复杂度<code>O(n*n)</code></li>
<li>平均时间复杂度<code>O(n*n)</code></li>
</ul>
<p>空间复杂度</p>
<ul>
<li>不需要额外空间<code>O(1)</code></li>
</ul>
<p>当元素相同时，不做交换，是<strong>稳定的排序算法</strong>。</p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>时间复杂度：</p>
<ul>
<li>当输入有序，时间复杂度<code>O(n)</code></li>
<li>当输入逆序，时间复杂度<code>O(n*n)</code></li>
<li>平均时间复杂度<code>O(n*n)</code></li>
</ul>
<p>空间复杂度</p>
<ul>
<li>不需要额外空间<code>O(1)</code></li>
</ul>
<p>当元素相同时，不做交换，是<strong>稳定的排序算法</strong>。</p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>原理：</p>
<p>分治法</p>
<p> 时间复杂度：</p>
<ul>
<li>平均时间复杂度<code>O(nlogn)</code></li>
</ul>
<p>空间复杂度</p>
<ul>
<li>要额外空间<code>O(n)</code></li>
</ul>
<p>是<strong>稳定的排序算法</strong>。</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>原理：</p>
<p>分治法</p>
<p>时间复杂度：</p>
<ul>
<li>当输入有序，时间复杂度<code>O(nlog(n))</code></li>
<li>当输入逆序，时间复杂度<code>O(n*n)</code></li>
<li>大部分情况不会出现出入逆序，平均时间复杂度<code>O(nlog(n))</code></li>
</ul>
<p>空间复杂度</p>
<ul>
<li>不需要额外空间<code>O(1)</code></li>
</ul>
<p>是<strong>不稳定的排序算法</strong></p>
<h3 id="排序算法性能分析"><a href="#排序算法性能分析" class="headerlink" title="排序算法性能分析"></a>排序算法性能分析</h3><table>
<thead>
<tr>
<th></th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>是否稳定</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O(n*n)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n*n)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlog(n))</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlog(n))    最坏情况O(n*n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
</tbody></table>
<h2 id="第十四讲"><a href="#第十四讲" class="headerlink" title="第十四讲"></a>第十四讲</h2><h3 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h3><p><strong>动态规划</strong>是一种运筹学方法，是在多轮决策过程中的最优方法</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ol>
<li><strong>策略</strong>，每轮的动作是决策，多轮决策合在一起常常被称为策略。</li>
<li><strong>策略集合</strong>，由于每轮的决策动作都是一个变量，这就导致合在一起的策略也是一个变量。我们通常会称所有可能的策略为策略集合。因此，动态规划的目标，也可以说是从策略集合中，找到最优的那个策略。</li>
</ol>
<p>动态规划的目标就是从策略集合中找到<strong>最优的几个策略</strong></p>
<h3 id="动态规划的基本方法"><a href="#动态规划的基本方法" class="headerlink" title="动态规划的基本方法"></a>动态规划的基本方法</h3><p>动态规划的解题方法并没有那么标准化，但它有一些宏观层面通用的方法论：</p>
<ol>
<li><strong>分阶段</strong>，将原问题划分成几个子问题。一个子问题就是多轮决策的一个阶段，它们可以是不满足独立性的。</li>
<li><strong>找状态</strong>，选择合适的状态变量 Sk。它需要具备描述多轮决策过程的演变，更像是决策可能的结果。</li>
<li><strong>做决策</strong>，确定决策变量 uk。每一轮的决策就是每一轮可能的决策动作，例如 D2 的可能的决策动作是 D2 -&gt; E2 和 D2 -&gt; E3。</li>
<li><strong>状态转移方程</strong>。这个步骤是动态规划最重要的核心，<code>即 sk+1= uk(sk) </code>。</li>
<li><strong>定目标</strong>。写出代表多轮决策目标的指标函数 <code>Vk,n</code>。</li>
<li><strong>寻找终止条件</strong>。</li>
</ol>
<p>一般而言，具有如下几个特征的问题，可以采用动态规划求解：</p>
<ol>
<li><strong>最优子结构</strong>。它的含义是，原问题的最优解所包括的子问题的解也是最优的。例如，某个策略使得 A 到 G 是最优的。假设它途径了 Fi，那么它从 A 到 Fi 也一定是最优的。</li>
<li><strong>无后效性</strong>。某阶段的决策，无法影响先前的状态。可以理解为今天的动作改变不了历史。</li>
<li><strong>有重叠子问题</strong>。也就是，子问题之间不独立。这个性质是动态规划区别于分治法的条件。如果原问题不满足这个特征，也是可以用动态规划求解的，无非就是杀鸡用了宰牛刀。</li>
</ol>
<h3 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h3><p><img src="https://s0.lgstatic.com/i/image/M00/2A/79/Ciqc1F78bdmAGdktAADnlpYQrHk607.png"></p>
<p>ps：这个有点难呀。。本子上画了好久才理清推导过程</p>
<p><a href="https://github.com/ruomuc/practice/blob/master/other/algorithm/testpath.js">代码实现</a></p>
<h2 id="第十六讲"><a href="#第十六讲" class="headerlink" title="第十六讲"></a>第十六讲</h2><p>解决问题的方法论：</p>
<ol>
<li>复杂度分析。估算问题中复杂度的上限和下限</li>
<li>定位问题。根据问题类型，确定采用何种算法思维</li>
<li>数据操作分析。根据增删查和数据顺序关系去选择合适的数据结构，利用空间换取时间</li>
<li>编码实现</li>
</ol>
<h2 id="第十八讲"><a href="#第十八讲" class="headerlink" title="第十八讲"></a>第十八讲</h2><blockquote>
<p>给定一个链表: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, 和 n = 2。当删除了倒数第二个节点后，链表变为 1 -&gt; 2 -&gt; 3 -&gt; 5。时间复杂度要求为 O(n)</p>
</blockquote>
<p>思路： 其实比较简单，使用快慢指针，假设删除倒数第<code>n</code>个结点，那么快指针就比慢指针先移动<code>n</code>次，然后快慢指针一起移动，最后慢指针的下一个结点就是要删除的结点。</p>
<p><a href="https://github.com/ruomuc/practice/blob/master/other/algorithm/deleteCountDownNode.js">代码实现</a></p>
<p>END~</p>
<h2 id="课程二维码"><a href="#课程二维码" class="headerlink" title="课程二维码"></a>课程二维码</h2><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJQAAACUCAYAAAB1PADUAAAIg0lEQVR4Xu3d0W7jOgyE4fb9H7oLnKtjB8jXAWknbWdvKZHU8BelOE738+vr6+uj/6rAkgKfBWpJybr5T4ECVRBWFShQq3LWWYEqA6sKFKhVOeusQJWBVQUK1KqcdVagysCqAgVqVc46K1BlYFWBArUqZ50VqDKwqkCBWpWzzgpUGVhVoECtyllnY6A+Pz9vVfH8+tY5fmo/J5+uZzue/F0t9vT1uAJ1qlCBmr1vWaAK1EGBdqjTkasjQ4K1Q71Zh1LB0juA7kjyp/my6461vd6746Xrp97Td8q3E9oWVPnJvp2PCnJ3vHT9yn/9DrW9Y6cL1nzZ7y7w3fHS9Reoi+9Y2xuoQIUFE+HppTq9RJ/jp/GUv/JJ46mDKN7V633YAFffoa5ecOr/aoGVT4HClnz1DlIB1VHSAsuf8knjvVpfrbcd6qRAWmAJXKCGt8p330FpfpJDwOhITS/daf4CfnsD/boOJQHTghSoN39SPt3RAqJAZW97tEPhsUSBKlBPGZjuIHU02VNANf7u9Vydj/xf/tXL3UeegJGdgoUvFBYoKXqyq0AF6njJlV7TT4Eq3xRw+W+HCv8i5LtvEBX8xwOlBcquHZ0WWPFkV0Gm8+VfjzUUP+2Asb+rv8tLE0oXXKBmCmvDpt4vP/LShArU7M6V6l2gTneedqgUoeP4twdqtjzPTu8YEuyn2a3QbMT0jrZ+5M2W49kFyhpNRhSo8I3Rnw7kBJbvzC1QBeo7nHx7zMuB+namLxqoS3vasabL0J1t6v/V88d3qFcvQPELlBTatRcoPIaYHgHpc7Xd8t7vrUAVqFXqxkDpTiC7VpMeWdOOoHyVzzm+Opzi3b0e5ct6Xf1dXiqYBHx1wQrUc6TaoU76aAMUqAJ1UEAtvUC9+FcvPFPDHxlsF1T5pUeojuT0udZ0vdogyne6/gf/0zuUCibBtGAVSPFT+7RAyndqnwKgIztdf4ECYamg2jDb9gLVI+/pHS4F7s8BlbZUjdeRpY6igunIVQHlX+ub5i//0/yl/+VHnhaoO0S6gGlBCtTxl8fSU/UZP4faLogS1o5TPhJsuiHSDZPmk/qXXuqwaT0K1EmxAvXi51DbhGtHKN7Urg6n/NKOI3/qMMpX+aTxNX7coVRAJZDaFW9qV4GUrwqoDrjtX/koXmovUPgpegqACpj6a4cK/1ZAvAMufoe8HSqtyHH85R1KO3L7U0sqh/JTh9ARq3w0X/mpI07ja/7DBpx+l7ctiARUgWMBbv57T+qA6QYrUCdFUwEL1FGBAlWgDgpsd/hphx4DOj3y1MK1wHQB0yMxnX91R9T6la/mp/VJ/a3fodKEpwWSwPKfzpc/bRjpowIqX81X/PX1tUNlSKQFVEHlr0ANPzWpvBJYOy6dL3/Kt0ClCmF8eunUp75te7pcAZl2HI0XkFPgVZ9Yn+0jTwJsAyFBZI8FQwcWINN8pkCn9Yn1KVCZZNOCFqhM74fREvDV9nR5Beq5YuPv8tRC0zNegKUApPml+SofrUeAyv92vmm8B323jzwJdPUdQ4Iov+0CFShVJPxUlxZIBRim91Ggpgr2yDsoUKDeHCgVKD3irl3uo/fpYwx1YHXc1K54qX6KH/ub3qEK1FHyKaCaX6CW39lOd4zGq4Cyq8DqAKld8bReferViSL/48cG7VDtUP9XYAyUiBfR0x0h/8ovjf9uG0j5K9/1jje9Q6lgKrgE0fzUriNG/lQgrUfzFT8FII2n/JVfO1T4sy8VSAXRfBWsQEEhFSAVWOPboZ4rNK3HuEOlOy791CRAJIAA+mn5q0NpvbqiSE/Vo0AN3zBNgRQQKrjmF6iwoBJUBZl2yOn8af6aX6AK1NNTRB1QgOsISwG8/MhTgG27BE53cDpeBdJ6785f+Wzbx3eo7YTk7+6CrO/gsCOrA2lDSM9te4E6KaoCtkM9R7BAFajVJjUGSkeQdrSOFNmlRjp/up6rP2VqvToCUz3SeAXqpFiBShE6ji9QBWpG0Fm/6dsG0x2tFiy71EjnT9fTI0+XHFXsxfYUAAEmf+kdJR2flmM73zT+wwaadqgX88SfRaWPAbYLVKBeTUgYXwAUqKOgqR5hOT7Gl/I04Pb4AnX836Sk79sDpYJqgal9KojuUMonXa/uJMpnak/Xo3zpb3qHSgVWQrIXqOP/FiXgpOd0/vqlvEA9L5l2vAo6tRcoKNAO9cc6lHakdkz6YFDjFW8KqOLLvx4rKH91sKvnX37kFajn/4evrgipfgVKW+ZkTwVTwdQR0njtUEcFxs+hpgUQX6n/ApX9n8GpvqzX9mOD9M6w3TEEVJpfOj5djwo0tSv/9IhVPpd3KBU4LYAEUDwJnOYjgdN48pfaFV96pvEKVPiH7AXsNpBpQdP4BWr4B8y0Y9OCqOBpPPlL7YpfoIZApcCkBUk7mPIRQHfHYz5/7VKuAupTT2pXAZSP5hcoKJR2BD0HUkHSeAXquaJ/7lKujpACIyAFtPLR/Hao5Q4lQa8uuOILCNnT/HXJVr6ar3x/fIdKBdJ4CZYWWP5kT+MJCK1f85VvgZJCJ3ta4ND9w/A0noAoUKcHj1OBJagASOPLn+xpvF8PlASTXZfk6ac8xVeBFF/zU8BTfxqv9af2y4+8NKG7C6T80oJcvQGUTxpf60/tBSr81CmB04K2Q50UTQVUQdqhniv05zpUCkw6fnpJ1QZIO8Y5f+Unu/xNN9z2/Ad/29/lpYCk46cFKVBHxaVHWp/1O1SaQDq+QO0CUaBOr6/oiBKAsm8Dn8a7+s70dkClgnf871ZgfOT9bnm6ulSBApUq1vFPFShQBWRVgQK1KmedFagysKpAgVqVs84KVBlYVaBArcpZZwWqDKwqUKBW5ayzAlUGVhUoUKty1lmBKgOrChSoVTnrrECVgVUF/gHdPJ75KNi8NAAAAABJRU5ErkJggg=="></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6之字符串的扩展</title>
    <url>/2020/06/09/ES6%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<p>本文整理一下<code>ES6</code>中字符串的扩展和新增的方法。</p>
<p>可以先去看一下这篇文章<a href="https://liyucang-git.github.io/2019/06/17/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Unicode%E7%BC%96%E7%A0%81/">彻底弄懂Unicode编码</a>，最好用笔和纸撸两遍，下文转换过程将省略。</p>
<br>

<h2 id="字符的-Unicode-表示法"><a href="#字符的-Unicode-表示法" class="headerlink" title="字符的 Unicode 表示法"></a>字符的 Unicode 表示法</h2><p>在<code>JavaScript</code>中，可以使用<code>\uxxxx</code>表示<code>unicode</code>编码，<code>xxxx</code>表示<code>unicode</code>编码的码点，但是当码点超过<code>\u0000 ~ \uFFFF</code>这个区间，会被截断。<br>比如中文<code>𠮷</code>的码点是<code>0x20BB7</code>，但是在<code>JavaScript</code>中输出的是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;\u20BB7&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// ₻7</span></span><br></pre></td></tr></table></figure>
<p>事实上<code>JavaScript</code>只能处理<code>UCS-2</code> 编码。<br>至于什么是<code>UCS-2</code>，两者的关系简单说，<strong>就是 UTF-16 取代了 UCS-2，或者说 UCS-2 整合进了 UTF-16</strong>。所以，现在只有 UTF-16，没有 UCS-2。<br>所以我们把这个码点转化为<code>utf-16</code>双字节表示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;\uD842\uDFB7&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 𠮷</span></span><br></pre></td></tr></table></figure>
<p>所以<code>ES6</code> 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;\u&#123;20BB7&#125;&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 𠮷</span></span><br></pre></td></tr></table></figure>
<br>

<h2 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h2><p>ES6 为字符串添加了遍历器接口，使得字符串可以被<code>for...of</code>循环遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> <span class="string">&#x27;hello&#x27;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// h</span></span><br><span class="line"><span class="comment">// e</span></span><br><span class="line"><span class="comment">// l</span></span><br><span class="line"><span class="comment">// l</span></span><br><span class="line"><span class="comment">// o</span></span><br></pre></td></tr></table></figure>

<p>关键是，<code>for...of</code>可以正确的识别码点，而普通<code>for</code>循环不可以：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="title class_">String</span>.<span class="title function_">fromCodePoint</span>(<span class="number">0x20bb7</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(str[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// �</span></span><br><span class="line"><span class="comment">// �</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> c <span class="keyword">of</span> str)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 𠮷</span></span><br></pre></td></tr></table></figure>
<br>

<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p><code>ES6</code>中可以使用反引号(<strong>`</strong>)来定义字符串，并且可以在其中嵌入变量，函数等。</p>
<span id="more"></span>

<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">`hello world!`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;单行字符串&#x27;</span>, str1); <span class="comment">// 单行字符串 hello world!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">`hello</span></span><br><span class="line"><span class="string">world!`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;多行字符串&#x27;</span>, str2); </span><br><span class="line"><span class="comment">// 多行字符串 hello</span></span><br><span class="line"><span class="comment">// world!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str3 = <span class="string">`hello <span class="subst">$&#123;name&#125;</span>!`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;带变量的模板字符串&#x27;</span>, str3); <span class="comment">// 带变量的模板字符串 hello world!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`hello <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> str4 = <span class="string">`<span class="subst">$&#123;sayHello(<span class="string">&#x27;world&#x27;</span>)&#125;</span>`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;带函数的模板字符串&#x27;</span>, str4); <span class="comment">// 带函数的模板字符串 hello world!</span></span><br></pre></td></tr></table></figure>
<h4 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h4><p>模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</p>
<p><strong>标签模板的解析规则</strong></p>
<ul>
<li>模板字符串中，非变量<code>$&#123;&#125;</code>部分会被变量分割后，放进一个数组中，当做函数的第一个参数。</li>
<li>变量部分，从第二个参数开始，依次传入函数中。</li>
<li>下面的代码中，第二个参数采取了<code>rest</code>的写法，正常应该是有多少个变量，后面就跟多少个参数的。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;zm&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> weight = <span class="string">&#x27;65&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">userInfo</span>(<span class="params">normalArr, ...data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(normalArr, data) <span class="comment">// [ &#x27;用户的基本信息为:年龄=&#x27;, &#x27;姓名=&#x27;, &#x27;体重&#x27;, &#x27;kg&#x27; ] [ 18, &#x27;zm&#x27;, &#x27;65&#x27; ]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">userInfo<span class="string">`用户的基本信息为:年龄=<span class="subst">$&#123;age&#125;</span>姓名=<span class="subst">$&#123;name&#125;</span>体重<span class="subst">$&#123;weight&#125;</span>kg`</span></span><br></pre></td></tr></table></figure>

<p><strong>raw属性</strong></p>
<ul>
<li>标签模板第一个参数有<code>raw</code>属性</li>
<li>区别是第一个参数数组不会对特殊字符进行转义。换行符<code>\n</code>会换行。</li>
<li><code>raw</code>属性会对特殊字符转义。换行符<code>\n</code>会被转义为<code>\\n</code>，输出为<code>\n</code>字符串。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">rawStr</span>(<span class="params">stringArr</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(stringArr[<span class="number">0</span>], stringArr)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(stringArr.<span class="property">raw</span>[<span class="number">0</span>], stringArr.<span class="property">raw</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rawStr<span class="string">`第一行\n第二行`</span></span><br><span class="line"><span class="comment">// 第一行</span></span><br><span class="line"><span class="comment">// 第二行 [ &#x27;第一行\n第二行&#x27; ]</span></span><br><span class="line"><span class="comment">// 第一行\n第二行 [ &#x27;第一行\\n第二行&#x27; ]</span></span><br></pre></td></tr></table></figure>
<br>
## 字符串的新增方法
#### String.fromCodePoint()
`ES5` 提供`String.fromCharCode()`方法不能识别大于`0XFFFF`的码点，所以`ES6`补充了这个方法：
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">0x20bb7</span>)); <span class="comment">// ஷ</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCodePoint</span>(<span class="number">0x20bb7</span>)); <span class="comment">// 𠮷</span></span><br></pre></td></tr></table></figure>
#### String.raw()
会返回一个斜杠都被转义的字符串：
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="title class_">String</span>.<span class="property">raw</span><span class="string">`第一行\n第二行`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`第一行\n第二行`</span>); </span><br><span class="line"><span class="comment">// 第一行</span></span><br><span class="line"><span class="comment">// 第二行</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str); <span class="comment">// 第一行\n第二行</span></span><br></pre></td></tr></table></figure>
#### codePointAt()
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;𠮷a&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="property">length</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charAt</span>(<span class="number">0</span>), str.<span class="title function_">charAt</span>(<span class="number">1</span>), str.<span class="title function_">charAt</span>(<span class="number">2</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charCodeAt</span>(<span class="number">0</span>).<span class="title function_">toString</span>(<span class="number">16</span>), str.<span class="title function_">charCodeAt</span>(<span class="number">1</span>).<span class="title function_">toString</span>(<span class="number">16</span>), str.<span class="title function_">charCodeAt</span>(<span class="number">2</span>).<span class="title function_">toString</span>(<span class="number">16</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">codePointAt</span>(<span class="number">0</span>).<span class="title function_">toString</span>(<span class="number">16</span>), str.<span class="title function_">codePointAt</span>(<span class="number">1</span>).<span class="title function_">toString</span>(<span class="number">16</span>), str.<span class="title function_">codePointAt</span>(<span class="number">2</span>).<span class="title function_">toString</span>(<span class="number">16</span>))</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// � � a</span></span><br><span class="line"><span class="comment">// d842 dfb7 61</span></span><br><span class="line"><span class="comment">// 20bb7 dfb7 61</span></span><br></pre></td></tr></table></figure>
从上面的代码可以看到，`JavaScript`中各种处理字符的方式，`𠮷`这个字符是有四个字节存储的，以`utf-16`表示应该为`0xD842 0xDFB7`,所以长度为3。
虽然`ES6`提供了`codePointAt()`来识别四个字节存储的字符，但是他的下标为2处，并不是字母`a`，所以还是不太对。
可以使用`for...of`：
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;𠮷a&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(ch.<span class="title function_">codePointAt</span>(<span class="number">0</span>).<span class="title function_">toString</span>(<span class="number">16</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 20bb7</span></span><br><span class="line"><span class="comment">// 61</span></span><br></pre></td></tr></table></figure>
那``codePointAt`有什么用呢？
它可以用来判断一个字符是由两个字节还是四个字节组成：
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&#x27;𠮷&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">is32Bit</span>(<span class="params">c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> c.<span class="title function_">codePointAt</span>(<span class="number">0</span>) &gt; <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">is32Bit</span>(s1)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">is32Bit</span>(s2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
#### includes(), startsWith(), endsWith()
- **includes()**：返回布尔值，表示是否找到了参数字符串。第二个参数表示从第几个下标位置开始，包括该位置的值。
- **startsWith()**：返回布尔值，表示参数字符串是否在原字符串的头部。第二个参数表示从第几个下标位置开始，包括该位置的值。
- **endsWith()**：返回布尔值，表示参数字符串是否在原字符串的尾部。第二个参数表示从第几个下标位置开始，不包括该位置的值。
- 以上方法的第二个参数都可以不传，默认为0。
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">startsWith</span>(<span class="string">&#x27;world&#x27;</span>, <span class="number">6</span>)) <span class="comment">// true  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">endsWith</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">5</span>)) <span class="comment">// true   </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">includes</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">6</span>))<span class="comment">// false   </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">includes</span>(<span class="string">&#x27;world&#x27;</span>, <span class="number">6</span>))<span class="comment">// true </span></span><br></pre></td></tr></table></figure>
#### repeat()
`repeat`方法返回一个新字符串，表示将原字符串重复`n`次。
使用比较简单，参数表示重复几次：
- 小数会被取整
- 字符串会转为数字
- `NAN`等共同与0
- `Infinity`和负数会报错
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">2</span>)); <span class="comment">// hellohello</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">2.5</span>)) <span class="comment">// hellohello</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>.<span class="title function_">repeat</span>(<span class="title class_">NaN</span>)) <span class="comment">// &#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
#### padStart()，padEnd()
<font color = rgba(154,69,11)>emm...这个是`ES2017(ES8)`的功能。</font>
也比较简单：
- 第一个参数表示，补全后的最大长度
- 第二参数表示，用来补全的字符串
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;ababx&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;abax&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.<span class="title function_">padEnd</span>(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xabab&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.<span class="title function_">padEnd</span>(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xaba&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;1&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">10</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment">// &quot;0000000001&quot;</span></span><br><span class="line"><span class="string">&#x27;12&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">10</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment">// &quot;0000000012&quot;</span></span><br><span class="line"><span class="string">&#x27;123456&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">10</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment">// &quot;0000123456&quot;</span></span><br></pre></td></tr></table></figure>
#### trimStart()，trimEnd()
- `trimStart()`只消除头部的空格
- `trimEnd()`只消除尾部的空格
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;  abc  &#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="title function_">trim</span>() <span class="comment">// &quot;abc&quot;</span></span><br><span class="line">s.<span class="title function_">trimStart</span>() <span class="comment">// &quot;abc  &quot;</span></span><br><span class="line">s.<span class="title function_">trimEnd</span>() <span class="comment">// &quot;  abc&quot;</span></span><br></pre></td></tr></table></figure>
#### matchAll()
这个我在node 10.x 没有跑通，然后去看了下这是`ES2020`才提出的，node 12.x 才支持。
我也不知道ES6指南为什么有这么多后面的新特性，等正则那一章再简单介绍一下吧。

<p>ps: 我觉得这些新特性，模板字符串我平时用的最多的，但是之前确实不知道标签模板这个功能。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6之解构赋值</title>
    <url>/2020/06/04/ES6%E4%B9%8B%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>左右两边<strong>模式相同</strong>，即可赋值:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b] = [<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b) <span class="comment">// 0 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a,b,[c]] = [<span class="number">0</span>,<span class="number">1</span>,[<span class="number">3</span>]]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b,c) <span class="comment">// 0 1 3</span></span><br></pre></td></tr></table></figure>
<p>左右两边<strong>模式不完全相同</strong>，可以成功赋值部分:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b,c) <span class="comment">// 0 1 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a,b] = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b) <span class="comment">// 0 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a,...b,c] = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b,c) <span class="comment">// 0 [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>
<p>事实上，只要某种数据结构具有 <strong>Iterator 接口</strong>(后面会说到)，都可以采用数组形式的解构赋值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">fibs</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [first, second, third, fourth, fifth, sixth] = <span class="title function_">fibs</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first, second, third, fourth, fifth, sixth) <span class="comment">// 0 1 1 2 3 5</span></span><br></pre></td></tr></table></figure>
<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>首先，<code>ES6</code>允许解构赋值指定默认值，但是必须当值严格相等于<code>undefined</code>才会生效：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>] = [];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [b = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [c = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>结构复制可以引用其它变量，但必须声明过：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [<span class="literal">undefined</span>, <span class="number">1</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x, y); <span class="comment">// ReferenceError: y is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span> , y = x] = [<span class="number">10</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x,y); <span class="comment">// 10 10</span></span><br></pre></td></tr></table></figure>
<p>默认值可以是一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [x = <span class="title function_">f</span>()] = [];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<br>
## 对象的解构赋值
#### 基本用法
可以看到，对象解构赋值，对于顺序没有要求，如果能找到与变量名称相同的`key`值，就赋值，找不到就是`undefined`
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; a, b, c &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c); <span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; c, b, a &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c); <span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; a, c, b &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c); <span class="comment">// 1 undefined undefined</span></span><br></pre></td></tr></table></figure>
如果想要赋值的变量名和对象的`key`值不相同：
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">a</span>: obj1, <span class="attr">b</span>: obj2, <span class="attr">c</span>: obj3 &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1, obj2, obj3); <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure>
对象也可以嵌套赋值,下面的代码中`p`和`y`都是模式，`x`和`obj2`才是变量：
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">p</span>: [</span><br><span class="line">    <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">&#x27;World&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; <span class="attr">y</span>: obj2 &#125;] &#125; = obj;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x, obj2);</span><br></pre></td></tr></table></figure>
#### 默认值
对象的解构赋值也可以设置默认值，生效条件是，对象的属性严格相等与`undefined`：
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; a, b = <span class="number">12</span> &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b); <span class="comment">// 1 12 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">a</span>: obj1, <span class="attr">b</span>: obj2 = <span class="number">12</span> &#125; = &#123; <span class="attr">a</span>: <span class="number">11</span>, <span class="attr">b</span>: <span class="literal">undefined</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1, obj2); <span class="comment">// 11 12 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">a</span>: obj1, <span class="attr">b</span>: obj2 = obj1 &#125; = &#123; <span class="attr">a</span>: <span class="number">12</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1, obj2); <span class="comment">// 12 12</span></span><br></pre></td></tr></table></figure>
<br>
## 字符串解构赋值
字符串被转换成了一个类似数组的对象：
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c, d, e); <span class="comment">// h e l l o</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="number">0</span>: a, <span class="number">1</span>: b, <span class="number">2</span>: c, <span class="number">3</span>: d, <span class="number">4</span>: e, <span class="attr">length</span>: len &#125; = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c, d, e, len); <span class="comment">// h e l l o 5</span></span><br></pre></td></tr></table></figure>
可以看到，字符串即可以作为数组也可以作为对象解构赋值，但是当做对象时，还可以获取到`length`属性。
<br>
## 数值和布尔值的解构赋值
规则是，只要等号右边的值不是对象或数组，就先将其转为对象：
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">__proto__</span>: s &#125; = <span class="title class_">Object</span>(<span class="number">123</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s === <span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">__proto__</span>: s &#125; = <span class="title class_">Object</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s === <span class="title class_">Boolean</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
看过我之前写的那篇原型链的文章，应该能看懂上面的代码。
<br>
## 函数参数的解构赋值
函数的参数也可以使用解构赋值,规则和上面的相同。
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params">[x, y = <span class="number">1</span>], &#123; z, c &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y, z, c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>([<span class="number">1</span>, <span class="number">2</span>], &#123; <span class="attr">z</span>: <span class="number">3</span>, <span class="attr">c</span>: <span class="number">4</span> &#125;)</span><br></pre></td></tr></table></figure>
<br>
## 用途
这部分内容，没什么好说的，拷贝忍者上线~
#### 交换变量值
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure>
#### **从函数返回多个值**

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = <span class="title function_">example</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = <span class="title function_">example</span>();</span><br></pre></td></tr></table></figure>

<h4 id="函数参数的定义"><a href="#函数参数的定义" class="headerlink" title="函数参数的定义"></a><strong>函数参数的定义</strong></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">[x, y, z]</span>) &#123; ... &#125;</span><br><span class="line"><span class="title function_">f</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">&#123;x, y, z&#125;</span>) &#123; ... &#125;</span><br><span class="line"><span class="title function_">f</span>(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="提取-JSON-数据"><a href="#提取-JSON-数据" class="headerlink" title="提取 JSON 数据"></a><strong>提取 JSON 数据</strong></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">status</span>: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(id, status, number);</span><br><span class="line"><span class="comment">// 42, &quot;OK&quot;, [867, 5309]</span></span><br></pre></td></tr></table></figure>

<h4 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a><strong>函数参数的默认值</strong></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery.<span class="property">ajax</span> = <span class="keyword">function</span> (<span class="params">url, &#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">async</span> = <span class="literal">true</span>,</span></span><br><span class="line"><span class="params">  beforeSend = <span class="keyword">function</span> () &#123;&#125;,</span></span><br><span class="line"><span class="params">  cache = <span class="literal">true</span>,</span></span><br><span class="line"><span class="params">  complete = <span class="keyword">function</span> () &#123;&#125;,</span></span><br><span class="line"><span class="params">  crossDomain = <span class="literal">false</span>,</span></span><br><span class="line"><span class="params">  <span class="variable language_">global</span> = <span class="literal">true</span>,</span></span><br><span class="line"><span class="params">  // ... more configs</span></span><br><span class="line"><span class="params">&#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="遍历-Map-结构"><a href="#遍历-Map-结构" class="headerlink" title="遍历 Map 结构"></a><strong>遍历 Map 结构</strong></h4><p>任何部署了 Iterator 接口的对象，都可以用<code>for...of</code>循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot; is &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure>

<h4 id="输入模块的指定方法"><a href="#输入模块的指定方法" class="headerlink" title="输入模块的指定方法"></a><strong>输入模块的指定方法</strong></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">SourceMapConsumer</span>, <span class="title class_">SourceNode</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;source-map&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6之let和const</title>
    <url>/2020/05/28/ES6%E4%B9%8Blet%E5%92%8Cconst/</url>
    <content><![CDATA[<p>我前面写过一篇整理es6的文章<a href="%5Bhttps://ruomuc.gitee.io/blog/2019/02/23/%E5%85%B3%E4%BA%8EES6/%5D(https://ruomuc.gitee.io/blog/2019/02/23/%E5%85%B3%E4%BA%8EES6/)">关于ES6</a>。但是好像太监了。。。因为太长了。</p>
<p>然后不幸的是前两天面试被问到了<code>es6</code>的数组扩展方法，刚好我没看到。。这是一个悲伤的故事，所以我决定看阮一峰老师的<a href="https://es6.ruanyifeng.com/">ECMAScript 6 入门</a>。这次一章一章的整理。尽量做到完全弄懂。<br><br></p>
<h2 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h2><p>没错，又是<code>let</code>，我已经写了不知道多少次了。。。没事多看几次加深理解嘛。。</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h4 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h4><p>正常的for循环：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span> ; i ++)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 循环打出 0-5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>正常循环中使用异步调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span> ; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 一秒后，瞬间输出6个6</span></span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 立刻输出一个 6</span></span><br></pre></td></tr></table></figure>
<p>稍微变型一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span> ; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 每隔1s，输出一个6，一共输出6次</span></span><br><span class="line">  &#125;,i*<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 立刻输出一个 6</span></span><br></pre></td></tr></table></figure>
<p>其实我们的本意是让它一秒后输出12345或者每过1s输出一个对应值。<br>通过上面的几个列子可以得出什么结论？</p>
<ul>
<li>使用var声明的循环变量，立刻调用，会调用到正常的值，比如第一个列子，或者第三个列子的<code>setTimeout</code>的第二个参数。</li>
<li>如果不立刻使用，使用的值是循环结束后的最终值。<br>
在没有`let`的`es6`之前的版本，我们是怎样解决这个问题的呢？
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 一秒后，瞬间输出 0,1,2,3,4,5</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 立刻输出一个 6</span></span><br></pre></td></tr></table></figure>
上面这个方法，使用了一个匿名自执行的函数，将`i`当做参数传递进去，`i`就是一个匿名函数内的变量了，所以外部`i`的修改，不会影响内部变量。。。等下。好像发现了什么，这不是闭包的思想吗？？?
说道闭包，，我之前好像也有文章写过闭包，不过我不用去翻都知道很烂。。
关于闭包，我看了一些博客和知乎的一些回答，发现每个地方对闭包的解释都不大相同，感觉是一个很抽象的概念。
我肯定会重新写一篇文章来专门研究闭包的。。
<br>
我们用`let`写一下试试：
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span> ; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 一秒后，瞬间输出0,1,2,3,4,5</span></span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 立刻输出一个 6</span></span><br></pre></td></tr></table></figure>
可以看到，`let`这时的作用相当于前文中的匿名自执行函数，原理都是每一次循环，`i`值都在一个新的作用域里面。
<font color = red>当然`let i =0`这个声明只会执行一次，JavaScript引擎会在每一次循环结束，会记住循环变量的值，然后再一个新的块里重新声明一个循环变量并把该值赋给它。详见这篇文章[怎么理解for循环中let声明的迭代变量每次是新的变量](https://segmentfault.com/q/1010000007541743)</color>
<br></li>
</ul>
<h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><p>同一作用域中如果在<code>var</code>声明变量之前使用了它，不会报错，会输出<code>undefined</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// undefined</span></span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun</span>();</span><br></pre></td></tr></table></figure>
<p>但是如果是let声明的变量会报错：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// ReferenceError</span></span><br><span class="line">	<span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun</span>();</span><br></pre></td></tr></table></figure>
<h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>暂时性死区很好理解，看起来好像和变量提升一个原理。<br>只要记住，使用let和const声明的变量，任何在未声明之前的操作都是不允许的。</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> b = a;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// undefined</span></span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1	</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun</span>();</span><br></pre></td></tr></table></figure>
<p>但是使用let的话：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">let</span> b = a;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// ReferenceError</span></span><br><span class="line">	<span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1	</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun</span>();</span><br></pre></td></tr></table></figure>
<p><code>ES6</code> 规定暂时性死区和<code>let</code>、<code>const</code>语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在<code> ES5</code> 是很常见的，现在有了这种规定，避免此类错误就很容易了。<br><br></p>
<h4 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h4><p>很容易理解，就是<code>let</code>声明变量时，当前作用域中不允许有相同的变量,下面这几种都会报错：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">var</span> a =<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而且我发现，作用域内声明的全局变量不算是全局，这个规则无论是在那个作用域还是用什么声明<code>var let const</code>，都是一样的</p>
<p>所以建议声明全局变量使用<code>window</code>或者<code>global</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line">&#123;</span><br><span class="line">  a = <span class="number">1</span>; <span class="comment">// ReferenceError 被变量提升规则处理</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">22</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  a = <span class="number">22</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 22</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// c.js</span></span><br><span class="line">a = <span class="number">233</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 233</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">222</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">global</span>.<span class="property">a</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// d.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>)&#123;</span><br><span class="line">  a = <span class="number">233</span>; <span class="comment">// 这个变量不会变为全局变量</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">123</span>; <span class="comment">// 如果去掉这一行，都会输出233，a会变为全局变量。。</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>

<p>这个我也是才发现。。 <strong>-.-!</strong></p>
<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p><code>ES5</code> 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。<br>内层变量覆盖了外层变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// undefined  。这里本意是想使用外层变量，但是由于后面又定义该变量，所以被变量提升了。。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure>
<p>还有就是前文中，for循环中<code>var</code>定义的循环变量在循环结束后，变量不会消失，会泄露造成变量污染。<br><br></p>
<h4 id="块级作用域中的函数声明"><a href="#块级作用域中的函数声明" class="headerlink" title="块级作用域中的函数声明"></a>块级作用域中的函数声明</h4><p>详细的看这里<a href="https://es6.ruanyifeng.com/#docs/let#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E">块级作用域中的函数声明</a>，这里比较绕。。</p>
<ul>
<li><code>ES5</code> 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</li>
<li><code>ES6</code> 规定，块级作用域之中，函数声明语句的行为类似于<code>let</code>，在块级作用域之外不可引用。</li>
</ul>
<p>但是：</p>
<ul>
<li><code>ES5</code>浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数</li>
<li><code>ES6</code> 在<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics">附录 B</a>里面规定，浏览器的实现可以不遵守上面的规定，有自己的<a href="http://stackoverflow.com/questions/31419897/what-are-the-precise-semantics-of-block-level-functions-in-es6">行为方式</a>。<ul>
<li>允许在块级作用域内声明函数。</li>
<li>函数声明类似于<code>var</code>，即会提升到全局作用域或函数作用域的头部。</li>
<li>同时，函数声明还会提升到所在的块级作用域的头部。</li>
</ul>
</li>
</ul>
<p>事实上，<code>node.js</code>貌似也没有遵守这些个规定。  </p>
<p>看代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 环境</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">f</span>();</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的写法等于下面的写法:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">f</span>(); <span class="comment">// I am inside!</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6 环境</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">f</span>();</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的写法等于下面的写法:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">f</span>(); <span class="comment">// undefined</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>



<h2 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h2><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span>; <span class="comment">// SyntaxError: Identifier &#x27;a&#x27; has already been declared</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b; <span class="comment">// SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure>

<p><code>const</code>命令同样<strong>也不能变量提升</strong>，并且<strong>存在暂时性死区</strong>，<strong>只在块级作用域内有效</strong>，<strong>不可重复声明</strong>。</p>
<h4 id="const不可变属性原理"><a href="#const不可变属性原理" class="headerlink" title="const不可变属性原理"></a>const不可变属性原理</h4><p>说白了<code>const</code>命令冻结的是栈中的数据，基本类型冻结的就是它本身的值，而引用类型冻结的是它的地址，对象中的值不会被冻结。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> a = b;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br><span class="line">b[<span class="string">&#x27;a&#x27;</span>] = <span class="number">120</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// &#123; a: 120, b: 2 &#125;</span></span><br></pre></td></tr></table></figure>

<p>如果想要冻结一个对象就要使用<code>Object.freeze()</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> a = b;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(a)</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(b)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br><span class="line">b[<span class="string">&#x27;a&#x27;</span>] = <span class="number">120</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br></pre></td></tr></table></figure>
<p>ES5 只有两种声明变量的方法：<code>var</code>命令和<code>function</code>命令。ES6 除了添加<code>let</code>和<code>const</code>命令，后面章节还会提到，另外两种声明变量的方法：<code>import</code>命令和<code>class</code>命令。所以，ES6 一共有 6 种声明变量的方法。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的this</title>
    <url>/2020/05/24/JavaScript%E4%B8%AD%E7%9A%84this/</url>
    <content><![CDATA[<h2 id="默认绑定规则"><a href="#默认绑定规则" class="headerlink" title="默认绑定规则"></a>默认绑定规则</h2><p>this的指向在函数定义的时候是无法确定的，只有在函数执行的时候才能确定。</p>
<p>因为浏览器和<code>node.js</code>的全局对象有一些区别。</p>
<p>在浏览器中:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">A</span>()</span><br></pre></td></tr></table></figure>

<p>但是在<code>node.js</code>中:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>); <span class="comment">// undefined</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">global</span>.<span class="property">b</span>); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line"><span class="title function_">A</span>()</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以看出：</p>
<ul>
<li>浏览器的<code>this</code>是<code>window</code>对象，<code>node.js</code>的<code>this</code>包含的东西更加多，其中有<code>this.global</code>就是<code>node.js</code>中的全局对象。</li>
<li><code>node.js</code>的全局变量必须使用无修饰符<code>b=2</code>或者<code>global.b=2</code>的方式来声明。</li>
</ul>
<p>补充：</p>
<ul>
<li>严格模式下<code>use strict</code>,浏览器的<strong>函数内部</strong><code>this</code>指向为<code>undefined</code>,而<code>node.js</code>的<code>this</code>为空对象<code>&#123;&#125;</code>。</li>
<li>严格模式下浏览器全局变量只可以使用<code>this.a= 1 window.a=1</code>不能使用<code>a=1</code>,<code>node.js</code>也只能使用<code>global.a=1</code></li>
<li>更多严格模式，或者浏览器环境的<code>js</code>和<code>node.js</code>环境的<code>js</code>后面再详细说明吧。</li>
</ul>
<p>考虑到以上因素，以下全部以浏览器环境为准。。</p>
<h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><span id="more"></span>
<p>大部分情况下，<code>this</code>会指向那个调用它的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">11</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">22</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>) <span class="comment">// undefined</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">b</span>) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="title function_">A</span>();</span><br></pre></td></tr></table></figure>

<p>上面的<code> A()</code>可以理解为<code>window.A()</code>,所以<code>this</code>指向了<code>window</code>，但是window下面没有<code>a</code>这个属性，所以是undefined.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">11</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">22</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>) <span class="comment">// 123</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">b</span>) <span class="comment">// 234</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">234</span>,</span><br><span class="line">  <span class="attr">fn</span>: A</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">666</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">999</span>,</span><br><span class="line">  <span class="attr">obj</span>: obj1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1.<span class="title function_">fn</span>() </span><br><span class="line"></span><br><span class="line">obj2.<span class="property">obj</span>.<span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure>

<p>上面的两种调用方式的结果都是一样的，<code>this.a // 123  this.b // 234</code>。</p>
<p>为什么呢，因为如果存在多次调用，对象属性引用链只有一层或者说最后一层在<strong>调用</strong>位置中起作用。就是说不管调用多少层，<code>this</code>只会指向第一层。</p>
<h2 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h2><p>继续：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">11</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">22</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>) <span class="comment">// 1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">b</span>) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">234</span>,</span><br><span class="line">  <span class="attr">fn</span>: A</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">666</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">999</span>,</span><br><span class="line">  <span class="attr">obj</span>: obj1</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">a</span>=<span class="number">1</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">b</span>=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> fn1 = obj1.<span class="property">fn</span></span><br><span class="line"><span class="keyword">var</span> fn2 = obj2.<span class="property">obj</span>.<span class="property">fn</span></span><br><span class="line"><span class="title function_">fn1</span>()</span><br><span class="line"><span class="title function_">fn2</span>()</span><br></pre></td></tr></table></figure>

<p>上面的<code>fn1</code>和<code>fn2</code>的输出结果都是一样的<code>this.a  // 1 this.b // 2</code></p>
<p>神奇？为什么和上一步的结论不一样呢，为什么这次的多层调用最终<code>this</code>指向了全局？？？（当然也取决于是否严格模式）</p>
<p><strong>原来这里的<code>fn1</code>和<code>fn2</code>都只是拿到了<code>function A</code>的一个引用！！！</strong>不信你输出一下他们的值。</p>
<p>所以说这并没有和上面的结论冲突！！核心在<strong>调用</strong>，调用了才会确定<code>this</code>的指向。</p>
<h2 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h2><p><code>call</code>、<code>apply</code>、<code>bind</code>、和<code>new</code>绑定等</p>
<p>关于<code>call</code>、<code>apply</code>、<code>bind</code>详情可以看<a href="https://hijiangtao.github.io/2017/05/07/Full-Usage-of-Apply-Call-and-Bind-in-JavaScript/">[译] JavaScript 中至关重要的 Apply, Call 和 Bind</a>，这篇文章我看了几遍，也只懂了个大概，他们三个好像区别不是很大，所以我后面会写一篇简单捋一下三者的区别。</p>
<p><code>this</code>指向很好理解，绑定了某个对象，<code>this</code>就指向绑定的对象</p>
<h3 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new"><code>new</code>运算符</a><br>官网说使用**<code>new</code> 运算符<strong>创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</strong><code>new</code>** 关键字会进行如下的操作：</p>
<ol>
<li>创建一个空的简单JavaScript对象（即<code>&#123;&#125;</code>）；**<code> var a = &#123;&#125;</code>**</li>
<li>链接该对象（即设置该对象的构造函数）到另一个对象 ； <strong><code>a.__proto__ = 构造函数.prototype</code></strong></li>
<li>将步骤1新创建的对象作为<code>this</code>的上下文 ；**<code>this 指向 a对象</code>**</li>
<li>如果该函数没有返回<strong>对象</strong>，则返回<code>this</code>。 <strong><code>如果返回的null，还是返回this </code></strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码比较好理解，没什么好说的。</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>显示绑定大于隐式绑定是毋庸置疑的。</p>
<p>主要看看，<code>new</code>绑定和<code>apply call bind</code>谁的优先级高？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">a</span>:<span class="number">123</span>&#125;</span><br><span class="line"><span class="keyword">var</span> foo = A.<span class="title function_">bind</span>(obj1)</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1)</span><br><span class="line"><span class="keyword">var</span> newFoo = <span class="keyword">new</span> <span class="title function_">foo</span>(<span class="number">12</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newFoo.<span class="property">a</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>new</code>操作修改了<code>bind</code>的绑定。</p>
<p>所以最终结果是：<font color = "red" >new绑定 &gt; 显示绑定（call、apply） &gt; 隐式绑定 &gt; 默认绑定</font></p>
<h3 id="如何判断this绑定对象"><a href="#如何判断this绑定对象" class="headerlink" title="如何判断this绑定对象"></a>如何判断this绑定对象</h3><p>如果要判断一个运行中函数的this绑定，就需要找到这个函数的直接调用位置。找到后可以按照顺序应用下面这四条规则来判断this的绑定对象。</p>
<ol>
<li>由new调用？绑定到新创建对象。</li>
<li>由call或者apply（或者bind）调用？绑定到指定对象。</li>
<li>由上下文对象调用？绑定到那个上下文对象。</li>
<li>默认：在严格模式下绑定到undefined，否则绑定到全局对象</li>
</ol>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>说完了<code> this</code>,但是发现好像漏掉了什么，在es6中引入的箭头函数，也和<code>this</code>的指向有一定的关系。</p>
<p>这里只探讨一下箭头函数的<code>this</code>，对于箭头函数的其他特性，有机会在写。</p>
<p><strong>箭头函数默认绑定外层的this对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">b</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">a</span>(); <span class="comment">// obj对象,因为方法a由Obj对象调用</span></span><br><span class="line">obj.<span class="title function_">b</span>(); <span class="comment">// window对象，严格模式会输出undefined</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的代码没什么好分析的，在看一段：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123;</span><br><span class="line">    <span class="attr">fna</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// obj1.a对象</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">b</span>: &#123;</span><br><span class="line">    <span class="attr">fnb</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// window对象</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">c</span>: <span class="keyword">function</span> <span class="title function_">fnc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// obj1 对象</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">d</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">e</span>: <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// obj.e 对象</span></span><br><span class="line">    <span class="keyword">var</span> f1 = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) &#125; <span class="comment">// window对象</span></span><br><span class="line">    <span class="title function_">f1</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">f</span>: <span class="keyword">function</span> <span class="title function_">ff</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// obj1对象</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fff</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// window对象</span></span><br><span class="line">      <span class="keyword">var</span> <span class="title function_">ffff</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// window对象</span></span><br><span class="line">      <span class="title function_">ffff</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fff</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj1.<span class="property">a</span>.<span class="title function_">fna</span>(); </span><br><span class="line">obj1.<span class="property">b</span>.<span class="title function_">fnb</span>(); </span><br><span class="line">obj1.<span class="title function_">c</span>()(); </span><br><span class="line">obj1.<span class="title function_">d</span>()(); </span><br><span class="line">obj1.<span class="title function_">e</span>(); </span><br><span class="line">obj1.<span class="title function_">f</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个：调用<code>fna()</code>方法的为<code>obj1.a</code>这个对象</li>
<li>第二个：箭头函数没有被非箭头函数包含，无论嵌套多少层，都是中指向最外层的this，即window</li>
<li>第三个：箭头函数被非箭头函数包含，<code>this</code>指向调用非箭头函数的对象</li>
<li>第四个：同第二个，无论嵌套多少箭头函数或者对象，<code> this</code>始终指向最外层</li>
<li>第五个：非箭头函数嵌套，里面的函数没有被，所以<code>this</code>指向 全局对象，箭头函数的出现就是为了解决这一类问题</li>
<li>第六个：虽然箭头函数被非箭头函数包含，但是包含它的非箭头函数没有被一个对象调用，所以他们的<code>this</code>指向的都是全局</li>
</ul>
<p>下面看下<code>bind apply call </code>能否修改箭头函数的指向</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj4 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">b</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="title function_">f1</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="title function_">f1</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj4.<span class="title function_">a</span>() <span class="comment">// window</span></span><br><span class="line">obj4.<span class="title function_">b</span>() <span class="comment">// obj4</span></span><br><span class="line"><span class="keyword">var</span> obj5 = &#123;&#125;</span><br><span class="line">obj4.<span class="property">a</span>.<span class="title function_">call</span>(obj5) <span class="comment">// window</span></span><br><span class="line">obj4.<span class="property">b</span>.<span class="title function_">call</span>(obj5) <span class="comment">// obj5</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code> call</code>无法修改箭头函数的指向，由于<code>this</code>在箭头函数中已经按照词法作用域绑定了，无法修改。</li>
<li>但是<code>call</code>可以修改包含箭头函数的非箭头函数的<code>this</code>指向，箭头函数内的<code>this</code>也同时被修改。</li>
<li>由此证明，箭头函数的<code>this</code> 是绑定在包含它的那个非箭头函数上面。</li>
</ul>
<p>最后留一个问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj4 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">b</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="title function_">f1</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="title function_">f1</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj4.<span class="property">b</span></span><br><span class="line"><span class="title function_">bar</span>()</span><br></pre></td></tr></table></figure>

<p>上面的代码会输出什么呢？</p>
<p>虽然是参考的别人的文章，但是我是从头到尾结合很多篇文章捋了一遍的，例子的代码也全部是手敲执行的。。。</p>
<p>参考链接：</p>
<p><a href="https://juejin.im/post/5c049e6de51d45471745eb98">https://juejin.im/post/5c049e6de51d45471745eb98</a></p>
<p><a href="https://www.cnblogs.com/pssp/p/5216085.html">https://www.cnblogs.com/pssp/p/5216085.html</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1031549578462080">https://www.liaoxuefeng.com/wiki/1022910821149312/1031549578462080</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域和同源策略</title>
    <url>/2020/05/23/%E8%B7%A8%E5%9F%9F%E5%92%8C%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>虽然经常遇到和处理跨域的问题，但都是停留于用<code>node</code>的中间件，使用<code>CORS</code>的方式来允许跨域。</p>
<p>这篇文章主要理解跨域和同源策略，就不详细的描述解决方案了，因为跨窗口通信和iframe这些东西作为后端没怎么接触过。</p>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>跨域是指一个域下的文档或脚本试图去请求另一个域下的资源。</p>
<p>受浏览器的<strong>同源策略</strong>限制，无法跨域请求资源，这也是我们。</p>
<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><h5 id="所谓同源："><a href="#所谓同源：" class="headerlink" title="所谓同源："></a>所谓同源：</h5><ul>
<li>协议相同。</li>
<li>域名相同</li>
<li>端口相同</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.example.com/dir2/other.html：同源</span><br><span class="line">http://example.com/dir/other.html：不同源（域名不同）</span><br><span class="line">http://v2.www.example.com/dir/other.html：不同源（域名不同）</span><br><span class="line">http://www.example.com:81/dir/other.html：不同源（端口不同）</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Internet Explorer 的同源策略有两个主要的差异点：</strong><ul>
<li><strong>授信范围</strong>（Trust Zones）：两个相互之间高度互信的域名，如公司域名（corporate domains），则不受同源策略限制。</li>
<li><strong>端口</strong>：IE 未将端口号纳入到同源策略的检查中，因此 <code>https://company.com:81/index.html</code> 和 <code>https://company.com/index.html</code> 属于同源并且不受任何限制。</li>
</ul>
</li>
</ul>
<h5 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h5><p>同源策略是一种浏览器安全策略，设想一个论坛网站可以获取到一个银行网站的<code>cookie</code>会有什么后果？</p>
<p>所以同源策略可以一定程度上防止<code>xss</code>(跨站脚本攻击)和<code>csrf</code>（跨域请求伪造）攻击。</p>
<h5 id="限制范围："><a href="#限制范围：" class="headerlink" title="限制范围："></a>限制范围：</h5><p>文章开头我就说我平时处理的跨域问题主要是请求跨域，但是同源策略不止限制这种情况。</p>
<ul>
<li> Cookie、LocalStorage 和 <a href="https://www.ruanyifeng.com/blog/2018/07/indexeddb.html">IndexDB</a> 无法读取。</li>
<li> DOM 无法获得。</li>
<li> AJAX 请求不能发送。</li>
</ul>
<span id="more"></span>

<h2 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h2><h5 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h5><p><strong>适用范围</strong>：</p>
<p><strong>cookie</strong>和<strong>iframe</strong></p>
<p>假设有A网页<code>w1.ruomu.com</code>,B网页<code>w2.ruomu.com</code>,如果想要两个网页共享<code>cookie</code></p>
<p>设置<code>document.domain=&quot;ruomu.com&quot;</code>,这样两个就可以共享<code>cookie</code></p>
<h5 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a>window.postMessage</h5><p><strong>适用范围</strong>：</p>
<p><strong>LocalStorage</strong>和<strong>iframe</strong></p>
<p><code>window</code>对象新增了一个<code>window.postMessage</code>方法，允许跨窗口通信，不论这两个窗口是否同源。</p>
<p>当然这个API也可以读取其它窗口的<code>LocalStorage</code>。</p>
<p>至于还有<code>片段识别符</code>和<code>window.name</code>等跨窗口通信的方案这里就先不说了</p>
<h4 id="Ajax的跨域问题"><a href="#Ajax的跨域问题" class="headerlink" title="Ajax的跨域问题"></a>Ajax的跨域问题</h4><p>​    作为后端，解决最多的就是这个。。</p>
<p><a href="https://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html"><strong>JSONP</strong></a></p>
<p>​    jsonp是一种<strong>非官方的跨域数据交互协议</strong></p>
<p>基本思想：</p>
<p>​    通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求JSON数据，因为浏览器具有<code>src</code>属性的标签，不受跨域限制（大部分吧），在请求参数传入回调函数方法名，后端返回该方法名的JSON数据。由于<code>&lt;script&gt;</code>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了该回调函数，该函数就会立即调用。</p>
<p><strong>WebSocket</strong></p>
<p>​    WebSocket协议很熟悉，使用<code>ws://</code>非加密和<code>wss://</code>加密 作为前缀。该协议不受同源策略影响。。</p>
<p>​    WebSocket请求头的信息包含了一个<code>Origin</code>，表示该请求的<code>源</code>。服务器可以根据这个字段，自行过滤。</p>
<p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html"><strong>CORS</strong></a></p>
<p>​    CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发<code>GET</code>请求，CORS允许任何类型的请求。</p>
<ul>
<li><strong>Access-Control-Allow-Origin</strong> : 必传字段， 表示接受请求的域名。</li>
<li><strong>Access-Control-Allow-Credentials</strong>：可选字段，表示是否允许发送<code>cookie</code>。</li>
<li><strong>Access-Control-Expose-Headers</strong>: 可选字段，表示除了header的6个基本字段（<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>），还需要什么字段。</li>
</ul>
<p>ps: 后端一般都会有一个cors的中间件。。。</p>
<p>参考链接：</p>
<p>​    <a href="https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</a></p>
<p>​    <a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>
<p>​    <a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存方案</title>
    <url>/2020/05/22/%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>emm…我觉得我学东西就和<code>js</code>的原型链一样，怎么学着学着奇怪的知识就增加了…本来要学的东西一直被挂起….</p>
<h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>强制缓存是通过<code>http</code>请求头里的<code>Cache-Control</code>和<code>Expire</code>字段来控制。</p>
<p><code>Expires</code>是<code>HTTP1.0</code>标准下的字段，所以暂时忽略吧。</p>
<p>以<code>node.js</code>为例:</p>
<p>一般我们这样设置<code>res.setHeader(&#39;Cache-Control&#39;, &#39;public, max-age=xxx&#39;);</code>，代表xxx秒内访问该资源，均使用本地缓存，不在向服务器发起请求。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>如果在<code>xxx</code>秒内，服务器更新了资源，客户端在没有强制刷新的情况下获取到的还是旧的资源。</p>
<p>如果后端发布了新版本，弃用了部分旧的接口，但是客户端由于缓存的存在，还是会调用旧的接口。。</p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><p><code>Etag</code>和<code>Last-Modifie</code></p>
<p>每次都要向服务器验证一下缓存的有效性。</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>很麻烦，缓存失去了意义。</p>
<span id="more"></span>

<h2 id="混合使用"><a href="#混合使用" class="headerlink" title="混合使用"></a>混合使用</h2><p><strong>HTML</strong>：使用协商缓存。</p>
<ul>
<li><p><strong>Etag</strong>:<code>Etag</code> 响应头字段表示资源的版本，浏览器在发送请求时会带 <code>If-None-Match</code> 头字段， 来询问服务器该版本是否仍然可用。如果服务器发现该版本仍然是最新的， 就可以返回 304 状态码指示 UA 继续使用缓存。</p>
</li>
<li><p> <strong>Last-Modified</strong>:与 <code>Etag</code> 类似，<code>Last-Modified</code> HTTP 响应头也用来标识资源的有效性。 不同的是使用修改时间而不是实体标签。对应的请求头字段为<code>If-Modified-Since</code>。</p>
</li>
</ul>
<p><strong>CSS&amp;JS&amp;图片</strong>：使用强缓存，文件命名带上hash值。</p>
<h2 id="webpack的hash"><a href="#webpack的hash" class="headerlink" title="webpack的hash"></a>webpack的hash</h2><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><p>hash是跟整个项目的构建相关，只要项目里有文件更改，整个项目构建的hash值都会更改，并且全部文件都共用相同的hash值</p>
<h4 id="chunkhash"><a href="#chunkhash" class="headerlink" title="chunkhash"></a>chunkhash</h4><p>它根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的哈希值。</p>
<h4 id="contenthash"><a href="#contenthash" class="headerlink" title="contenthash"></a>contenthash</h4><p>如果<code>index.css</code>被<code>index.js</code>引用了，如果index.js更改了代码，css文件就算内容没有任何改变，由于是该模块发生了改变，导致css文件会重复构建。</p>
<p>这个时候，我们可以使用extra-text-webpack-plugin里的contenthash值，保证即使css文件所处的模块里就算其他文件内容改变，只要css文件内容不变，那么不会重复构建。</p>
<p>ps:  因为还没学过webpack和前端构建的东西，这里只是一个知识结构的目录，后面学到再展开。</p>
<hr>
<p>参考链接：</p>
<p><a href="https://juejin.im/post/5c136bd16fb9a049d37efc47">前端缓存最佳实践</a></p>
<p><a href="https://juejin.im/post/5a4502be6fb9a0450d1162ed">webpack中的hash、chunkhash、contenthash区别</a></p>
<p><a href="https://harttle.land/2017/04/04/using-http-cache.html">使用 HTTP 缓存：Etag, Last-Modified 与 Cache-Control
</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo搜索转圈问题</title>
    <url>/2020/05/22/hexo%E6%90%9C%E7%B4%A2%E8%BD%AC%E5%9C%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>今天hexo的搜索功能一直转菊花，对于我这种强迫症来说，博客没有搜索也太难受了吧。</p>
<p>google了一下发现很多人也遇到了这个问题。</p>
<p>说一下我的解决步骤吧。</p>
<h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p>我打开控制台，点击搜索，获取<code>search.xml</code>文件时，并没有报错。</p>
<p>所以我的博客的原因是因为<code>xml</code>文件有特殊字符。</p>
<p>于是我先打开vscode设置，把<code>editor.renderControlCharacters </code>设置为true，用正则的方式去搜索如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;/[\u0000]|[\u0001]|[\u0002]|[\u0003]|[\u0004]|[\u0005]|[\u0006]|[\u0007]|[\u0008]|[\u000b]|[\u000c]|[\u000d]|[\u000e]|[\u000f]|[\u0010]|[\u0011]|[\u0012]|[\u0013]|[\u0014]|[\u0015]|[\u0016]|[\u0017]|[\u0018]|[\u0019]|[\u001a]|[\u001b]|[\u001c]|[\u001d]|[\u001e]|[\u001f]|[\u001c]|[\u007f]/gm</span><br></pre></td></tr></table></figure>

<p>but，我搜不到，于是我打开控制台，找到请求<code>search.xml</code>，点击<code>response</code>，复制内容到编辑器中，推荐用<code>sublime</code>。然后在搜索上面那串正则，搜到之后在原文修改完。</p>
<p><code>hexo clean , hexo g ,hexo d</code>重新部署。</p>
<p>然后用无痕模式试一下，或者强制刷新<code>ctrl+R</code>再清除<code>search.xml</code>的缓存。</p>
<p>大功告成！</p>
<p>参考链接：<a href="https://www.itfanr.cc/2017/11/24/resolve-hexo-blog-search-exception/">解决Hexo博客搜索异常</a></p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript原型链</title>
    <url>/2020/05/21/javascript%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<p>阮一峰老师的说原型链开始是为了解决继承的，因为JavaScript没有子类父类的概念，只有原型对象。</p>
<p>看着别人的讲解，自己跟着画了张图加深理解，对比着图比较容易理解。</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/prototype.png" style="zoom:25%;" />

<h4 id="什么是prototype、-proto-和constructor"><a href="#什么是prototype、-proto-和constructor" class="headerlink" title="什么是prototype、__proto__和constructor?"></a>什么是<code>prototype</code>、<code>__proto__</code>和<code>constructor</code>?</h4><ul>
<li><p><code>__proto__</code>:事实上就是原型链指针</p>
</li>
<li><p><code>prototype</code>:是原型对象</p>
</li>
<li><p><code>constructor</code>: 每一个原型对象都包含一个指向<code>构造函数</code>的指针</p>
</li>
<li><p>大多说情况下，<code>__proto__</code>可以理解为构造器原型，举个例子。</p>
<ul>
<li>```<br>function A(){}var a = new A();a.<strong>proto</strong> === A.prototype;  // 这里A是a的构造函数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### JavaScript的构造函数？</span><br><span class="line"></span><br><span class="line">​	在java中，构造函数可以理解为，实例化类时用来初始化类的函数，但是JavaScript中，构造函数是指**使用`new`来调用的函数，和函数无关，只和调用方式有关。**</span><br><span class="line"></span><br><span class="line">#### `prototype`和`__proto__`的区别?</span><br><span class="line"></span><br><span class="line">- `prototype`只有函数才有这个属性</span><br><span class="line">- `__proto__`每个对象都有这个属性</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">#### `__proto__`属性指向谁?</span><br><span class="line"></span><br><span class="line">`__proto__`指向取决于对象创建时的实现方式</span><br><span class="line"></span><br><span class="line">##### 字面量方式</span><br><span class="line"></span><br><span class="line">`var a = &#123;&#125;;` 等价于`var a = new Object();`</span><br><span class="line"></span><br><span class="line">其实 `a`就是的构造函数就是`function Object()&#123;&#125;`</span><br><span class="line"></span><br><span class="line">根据图可知`a.__proto__ === Object.prototype`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 构造器方式</span><br><span class="line">```javascript</span><br><span class="line">var A = function()&#123;&#125;</span><br><span class="line">var a = new A()</span><br></pre></td></tr></table></figure>
这里栗子上面说过，没什么特别的。<br>其实这样看，字面量方式和构造器方式有点类似。</li>
</ul>
</li>
</ul>
<h5 id="Object-create方式"><a href="#Object-create方式" class="headerlink" title="Object.create方式"></a><code>Object.create</code>方式</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(a1);</span><br></pre></td></tr></table></figure>

<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>看着这段代码和我画的图，看懂了基本就懂了。。。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">__proto__</span>); <span class="comment">//A &#123;&#125;（即构造器function A 的原型对象）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">__proto__</span>.<span class="property">__proto__</span>); <span class="comment">//Object &#123;&#125;（即构造器function Object 的原型对象）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>); <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(A.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>); <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">__proto__</span>===A.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">__proto__</span>.<span class="property">__proto</span>===A.<span class="property">__proto__</span>.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>参考链接:</p>
<ul>
<li><a href="https://www.cnblogs.com/shuiyi/p/5305435.html">三张图搞懂JavaScript的原型对象与原型链</a></li>
<li><a href="https://www.zhihu.com/question/34183746">js中__proto__和prototype的区别和关系？</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html">Javascript继承机制的设计思想</a></li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title>css的相对单位和绝对单位</title>
    <url>/2020/05/19/css%E7%9A%84%E7%9B%B8%E5%AF%B9%E5%8D%95%E4%BD%8D%E5%92%8C%E7%BB%9D%E5%AF%B9%E5%8D%95%E4%BD%8D/</url>
    <content><![CDATA[<p>在查资料的时候，发现网上有的人说 <code>px</code>是相对单位，有的人说<code>px</code>是绝对单位。。<a href="https://www.zhihu.com/question/67571440">px是相对单位还是绝对单位？</a></p>
<ul>
<li>《css权威指南》第三章-单位和值的小节“长度单位”中简易说明了px是相对长度单位。</li>
<li>《The Lengths of CSS》中指出px是绝对长度单位。</li>
</ul>
<p>我看了一下，我个人偏向于px是个绝对单位，因为px的大小一般情况下是固定的，只是对于高分辨率的设备，大小会发生变动。。</p>
<h2 id="绝对单位"><a href="#绝对单位" class="headerlink" title="绝对单位"></a>绝对单位</h2><p>此类单位的长度值与其代表的物理长度相等。</p>
<h4 id="px"><a href="#px" class="headerlink" title="px"></a>px</h4><ul>
<li>在低分辨率设备上，1px = 1像素</li>
<li>在高分辨率设备上，1px = 1/96in，1px不一定等于1像素（比如4.7英寸的iphone上 1px=2像素）</li>
<li>对于图片显示，1px = 1图片像素，比如：一个600x400分辨率的照片的的CSS宽高即为600px和400px（在4.7英寸iphone上要用1200x800个像素点显示）</li>
</ul>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1in = 2.54cm = 25.4mm = 72pt = 6pc = 96px</span><br></pre></td></tr></table></figure>

<h2 id="相对单位"><a href="#相对单位" class="headerlink" title="相对单位"></a>相对单位</h2><p>相对单位的长度值是根据其他参照物的长度计算得出的。</p>
<h4 id=""><a href="#" class="headerlink" title="%"></a>%</h4><ul>
<li>对<code>font-size</code>设置百分比值，参照物为浏览器默认字体大小<code>16px</code>。即<code>font-size:62.5%</code>为<code>10px</code></li>
<li>如果对<code>div</code>使用的话，以父元素为参照物。<strong>另外我发现，<code>%</code>不受父元素的宽高被<code>margin</code>、<code>padding</code>、<code>border</code>此类变大的影响。</strong></li>
</ul>
<h4 id="em"><a href="#em" class="headerlink" title="em"></a>em</h4><ul>
<li>em代表元素的当前字体大小，如果元素的<code>font-size</code>为<code>2cm</code>，那么<code>1em</code>即表示<code>2cm</code></li>
<li>如果em直接用于<code>font-size</code>属性，如<code>font-size: 2em</code>，则em表示为父元素字体的大小</li>
<li>如果元素没有font-size属性，就找父级元素，如果都没有设置，就用浏览器默认的<code>font-size</code>16px<span id="more"></span>
<h4 id="ex"><a href="#ex" class="headerlink" title="ex"></a>ex</h4></li>
</ul>
<p>不推荐使用</p>
<p>ex很少被使用，ex表现的大小与字体的x-height相关。x-height大致等于字体中小写字母（例如a，c，m或o）的高度。相同<code>font-size</code>的不同字体的x-height可能会有很大的差别，所以使用ex产生的效果存在很大的不确定性。</p>
<h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><p>rem表示的是根元素（html元素的）字体大小。在每个元素里面em都可能不一样，但是rem都是一致的。</p>
<h4 id="ch"><a href="#ch" class="headerlink" title="ch"></a>ch</h4><p><code>css3</code>中加入的新单位，用的比较少，表示当前字体中的 <code>0</code> (零、unicode 字符 U+0030) 的宽度</p>
<h4 id="vw，wh，vmin，vmax"><a href="#vw，wh，vmin，vmax" class="headerlink" title="vw，wh，vmin，vmax"></a>vw，wh，vmin，vmax</h4><ul>
<li><p>都是<code>css3</code>新加入的元素，以视窗为参照物。</p>
</li>
<li><p><code>vw</code>是视窗宽度的 <code>1/100</code></p>
</li>
<li><p><code>vh</code>是视窗高度的<code>1/100</code></p>
</li>
<li><p><code>vmin</code>是<code>vh</code>和<code>vw</code>中的较小值</p>
</li>
<li><p><code>vmax</code>是<code>vh</code>和<code>vw</code>中的较大值</p>
</li>
</ul>
<h2 id="各种单位的主要作用"><a href="#各种单位的主要作用" class="headerlink" title="各种单位的主要作用"></a>各种单位的主要作用</h2><table>
<thead>
<tr>
<th>输出媒介</th>
<th>推荐</th>
<th>偶尔使用</th>
<th>不推荐</th>
</tr>
</thead>
<tbody><tr>
<td>屏幕</td>
<td>em, px, %</td>
<td>ex</td>
<td>pt, cm, mm, in, pc</td>
</tr>
<tr>
<td>打印</td>
<td>em, cm, mm, in, pt, pc, %</td>
<td>px, ex</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库必知必会</title>
    <url>/2020/05/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
    <content><![CDATA[<h2 id="常用关系型数据库"><a href="#常用关系型数据库" class="headerlink" title="常用关系型数据库"></a>常用关系型数据库</h2><ul>
<li><strong>Oracle：</strong>功能强大，主要缺点就是贵</li>
<li><strong>MySQL：</strong>互联网行业中最流行的数据库，这不仅仅是因为MySQL的免费。可以说关系数据库场景中你需要的功能，MySQL都能很好的满足，后面详解部分会详细介绍MySQL的一些知识点</li>
<li><strong>MariaDB：</strong>是MySQL的分支，由开源社区维护，MariaDB虽然被看作MySQL的替代品，但它在扩展功能、存储引擎上都有非常好的改进</li>
<li><strong>PostgreSQL：</strong>也叫PGSQL，PGSQL类似于Oracle的多进程框架，可以支持高并发的应用场景，PG几乎支持所有的SQL标准，支持类型相当丰富。PG更加适合严格的企业应用场景，而MySQL更适合业务逻辑相对简单、数据可靠性要求较低的互联网场景。</li>
</ul>
<h2 id="常用非关系型数据库"><a href="#常用非关系型数据库" class="headerlink" title="常用非关系型数据库"></a>常用非关系型数据库</h2><ul>
<li><strong>Redis：</strong>提供了持久化能力，支持多种数据类型。Redis适用于数据变化快且数据大小可预测的场景。</li>
<li><strong>MongoDB：</strong>一个基于分布式文件存储的数据库，将数据存储为一个文档，数据结构由键值对组成。MongoDB比较适合表结构不明确，且数据结构可能不断变化的场景，不适合有事务和复杂查询的场景。</li>
<li><strong>HBase：</strong>建立在HDFS，也就是Hadoop文件系统之上的分布式面向列的数据库。类似于谷歌的大表设计，HBase可以提供快速随机访问海量结构化数据。在表中它由行排序，一个表有多个列族以及每一个列族可以有任意数量的列。 HBase依赖HDFS可以实现海量数据的可靠存储，适用于数据量大，写多读少，不需要复杂查询的场景。</li>
<li><strong>Cassandra：</strong>一个高可靠的大规模分布式存储系统。支持分布式的结构化Key-value存储，以高可用性为主要目标。适合写多的场景，适合做一些简单查询，不适合用来做数据分析统计。</li>
<li><strong>Pika：</strong>一个可持久化的大容量类Redis存储服务， 兼容五种主要数据结构的大部分命令。Pika使用磁盘存储，主要解决Redis大容量存储的成本问题。</li>
</ul>
<h2 id="NewSQL数据库（新一代关系型数据库）"><a href="#NewSQL数据库（新一代关系型数据库）" class="headerlink" title="NewSQL数据库（新一代关系型数据库）"></a><strong>NewSQL数据库（新一代关系型数据库）</strong></h2><ul>
<li><strong>TiDB：</strong>开源的分布式关系数据库，几乎完全兼容MySQL，能够支持水平弹性扩展、ACID事务、标准SQL、MySQL语法和MySQL协议，具有数据强一致的高可用特性。既适合在线事务处理，也适合在线分析处理。</li>
<li><strong>OceanBase：</strong>OceanBase是蚂蚁金服的数据库，OB是可以满足金融级的可靠性和数据一致性要求的数据库系统。当你需要使用事务，并且数据量比较大，就比较适合使用OB。不过目前OB已经商业化，不再开源。</li>
</ul>
<h2 id="数据库事务特性"><a href="#数据库事务特性" class="headerlink" title="数据库事务特性"></a><strong>数据库事务特性</strong></h2><ul>
<li><strong>原子性：</strong>是指事务由原子的操作序列组成，所有操作要么全部成功，要么全部失败回滚。</li>
<li><strong>一致性：</strong>是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处以一致性状态。比如在做多表操作时，多个表要么都是事务后新的值，要么都是事务前的旧值。</li>
<li><strong>隔离性：</strong>是指多个用户并发访问数据库时，数据库为每个用户执行的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。事务的隔离级别我们稍后介绍。</li>
<li><strong>持久性：</strong>是指一个事务一旦提交并执行成功，那么对数据库中数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li>
</ul>
<h2 id="事物并发问题与隔离级别"><a href="#事物并发问题与隔离级别" class="headerlink" title="事物并发问题与隔离级别"></a><strong>事物并发问题与隔离级别</strong></h2><h5 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a><strong>事务并发问题</strong></h5><ul>
<li><strong>脏读：</strong>脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据，例如，账户A转帐给B500元，B余额增加后但事务还没有提交完成，此时如果另外的请求中获取的是B增加后的余额，这就发生了脏读，因为事务如果失败回滚时，B的余额就不应该增加。</li>
<li><strong>不可重复读：</strong>不可重复读是指对于数据库中某个数据，一个事务范围内多次查询返回了不同的数据值，这是由于在多次查询之间，有其他事务修改了数据并进行了提交。</li>
<li><strong>幻读：</strong>是指一个事务中执行两次完全相同的查询时，第二次查询所返回的结果集跟第一个查询不相同。与不可重复读的区别在于，不可重复读是对同一条记录，两次读取的值不同。而幻读是记录的增加或删除，导致两次相同条件获取的结果记录数不同。</li>
</ul>
<h5 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h5><ul>
<li><strong>读未提交：</strong>也就是可以读取到其他事务未提交的内容，这是最低的隔离级别，这个隔离级别下，前面提到的三种并发问题都有可能发生。</li>
<li><strong>读已提交：</strong>就是只能读取到其他事务已经提交的数据。这个隔离级别可以解决脏读问题。</li>
<li><strong>可重复读：</strong>可以保证整个事务过程中，对同数据的多次读取结果是相同的。这个级别可以解决脏读和不可重复读的问题。MySQL默认的隔离级别就是可重复读。</li>
<li><strong>串行化：</strong>这是最高的隔离级别，所有事务操作都依次顺序执行。这个级别会导致并发度下降，性能最差。不过这个级别可以解决前面提到的所有并发问题。</li>
</ul>
<h2 id="事务分类"><a href="#事务分类" class="headerlink" title="事务分类"></a><strong>事务分类</strong></h2><ul>
<li><strong>扁平化事务</strong>：在扁平事务中，所有的操作都在同一层次，这也是我们平时使用最多的一种事务。它的主要限制是不能提交或者回滚事务的某一部分，要么都成功，要么都回滚。</li>
<li><strong>带保存点的扁平事务：</strong>为了解决第一种事务的弊端，就有了第二种带保存点的扁平事务。它允许事务在执行过程中回滚到较早的状态，而不是全部回滚。通过在事务中插入保存点，当操作失败后，可以选择回滚到最近的保存点处。</li>
<li><strong>链事务：</strong>可以看做是第二种事务的变种。它在事务提交时，会将必要的上下文隐式传递给下一个事务，当事务失败时就可以回滚到最近的事务。不过，链事务只能回滚到最近的保存点，而带保存点的扁平化事务是可以回滚到任意的保存点。</li>
<li>**嵌套事务:**由顶层事务和子事务构成，类似于树的结构。一般顶层事务负责逻辑管理，子事务负责具体的工作，子事务可以提交，但真正提交要等到父事务提交，如果上层事务回滚，那么所有的子事务都会回滚。</li>
<li><strong>分布式事务：</strong>是指分布式环境中的扁平化事务。<ul>
<li><strong>XA协议：</strong>是保证强一致性的刚性事务。实现方式有两段式提交和三段式提交。两段式提交需要有一个事务协调者来保证所有的事务参与者都完成了第一阶段的准备工作。如果协调者收到所有参与者都准备好的消息，就会通知所有的事务执行第二阶段提交。一般场景下两段式提交已经能够很好得解决分布式事务了，然而两阶段在即使只有一个进程发生故障时，也会导致整个系统存在较长时间的阻塞。三段式提交通过增加Pre-commit阶段来减少前面提到的系统阻塞的时间。三段式提交很少在实际中使用，简单了解就可以了。</li>
<li><strong>TCC：</strong>是满足最终一致性的柔性事务方案。TCC采用补偿机制，核心思想是对每个操作，都要注册对应的确认和补偿操作。它分为三个阶段：Try阶段主要对业务系统进行检测及资源预留；Confirm阶段对业务系统做确认提交。Cancel阶段是在业务执行错误，执行回滚，释放预留的资源。</li>
<li><strong>消息事务：</strong>第三种方案是消息一致性方案。基本思路是将本地操作和发送消息放在一个事务中，保证本地操作和消息发送要么都成功要么都失败。下游应用订阅消息，收到消息后执行对应操作。</li>
<li>**GTS/Fescar:**阿里云中的全局事务服务GTS，对应的开源版本是Fescar。Fescar基于两段式提交进行改良，剥离了分布式事务方案对数据库在协议支持上的要求。使用Fescar的前提是分支事务中涉及的资源，必须是支持ACID事务的关系型数据库。分支的提交和回滚机制，都依赖于本地事务来保障。 Fescar的实现目前还存在一些局限，比如事务隔离级别最高支持到读已提交级别。</li>
</ul>
</li>
</ul>
<h2 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a><a href="https://www.runoob.com/mongodb/nosql.html">CAP定理</a></h2><p>在计算机科学中, CAP定理（CAP theorem）, 又被称作 布鲁尔定理（Brewer’s theorem）, 它指出对于一个分布式计算系统来说，不可能同时满足以下三点:</p>
<ul>
<li><strong>一致性(Consistency)</strong> (所有节点在同一时间具有相同的数据)</li>
<li><strong>可用性(Availability)</strong> (保证每个请求不管成功或者失败都有响应)</li>
<li><strong>分隔容忍(Partition tolerance)</strong> (系统中任意信息的丢失或失败不会影响系统的继续运作)</li>
</ul>
<p>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。</p>
<p>因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：</p>
<ul>
<li>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</li>
<li>CP - 满足一致性，分区容忍性的系统，通常性能不是特别高。</li>
<li>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</li>
</ul>
<h2 id="NoSQL的优点-缺点"><a href="#NoSQL的优点-缺点" class="headerlink" title="NoSQL的优点/缺点"></a>NoSQL的优点/缺点</h2><span id="more"></span>
<p>优点:</p>
<ul>
<li>高可扩展性</li>
<li> 分布式计算</li>
<li> 低成本</li>
<li> 架构的灵活性，半结构化数据</li>
<li> 没有复杂的关系</li>
</ul>
<p>缺点:</p>
<ul>
<li>没有标准化</li>
<li> 有限的查询功能（到目前为止）</li>
<li> 最终一致是不直观的程序</li>
</ul>
<h2 id="三个范式"><a href="#三个范式" class="headerlink" title="三个范式"></a><a href="https://www.zhihu.com/question/24696366">三个范式</a></h2><ul>
<li><p>第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</p>
</li>
<li><p>第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。</p>
</li>
<li><p>第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y</p>
</li>
</ul>
<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h5 id="常用SQL语句"><a href="#常用SQL语句" class="headerlink" title="常用SQL语句"></a><a href="https://ruomuc.gitee.io/blog/2019/02/12/MySql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">常用SQL语句</a></h5><p>​    推荐《mysql必知必会》这本书</p>
<h5 id="mysql的基本数据类型"><a href="#mysql的基本数据类型" class="headerlink" title="mysql的基本数据类型"></a>mysql的基本数据类型</h5><table>
<thead>
<tr>
<th>TINYINT</th>
<th>1 byte</th>
<th>(-128，127)</th>
<th>(0，255)</th>
<th>小整数值</th>
</tr>
</thead>
<tbody><tr>
<td>SMALLINT</td>
<td>2 bytes</td>
<td>(-32 768，32 767)</td>
<td>(0，65 535)</td>
<td>Sss大整数值</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3 bytes</td>
<td>(-8 388 608，8 388 607)</td>
<td>(0，16 777 215)</td>
<td>大整数值</td>
</tr>
<tr>
<td>INT或INTEGER</td>
<td>4 bytes</td>
<td>(-2 147 483 648，2 147 483 647)</td>
<td>(0，4 294 967 295)</td>
<td>大整数值</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8 bytes</td>
<td>(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td>
<td>(0，18 446 744 073 709 551 615)</td>
<td>极大整数值</td>
</tr>
<tr>
<td>FLOAT</td>
<td>4 bytes</td>
<td>(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>
<td>0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>
<td>单精度 浮点数值</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>8 bytes</td>
<td>(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td>0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td>双精度 浮点数值</td>
</tr>
<tr>
<td>DECIMAL</td>
<td>对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td>
<td>依赖于M和D的值</td>
<td>依赖于M和D的值</td>
<td>小数值</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>CHAR</th>
<th>0-255 bytes</th>
<th>定长字符串</th>
</tr>
</thead>
<tbody><tr>
<td>VARCHAR</td>
<td>0-65535 bytes</td>
<td>变长字符串</td>
</tr>
<tr>
<td>TINYBLOB</td>
<td>0-255 bytes</td>
<td>不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>0-255 bytes</td>
<td>短文本字符串</td>
</tr>
<tr>
<td>BLOB</td>
<td>0-65 535 bytes</td>
<td>二进制形式的长文本数据</td>
</tr>
<tr>
<td>TEXT</td>
<td>0-65 535 bytes</td>
<td>长文本数据</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>0-16 777 215 bytes</td>
<td>二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>0-16 777 215 bytes</td>
<td>中等长度文本数据</td>
</tr>
<tr>
<td>LONGBLOB</td>
<td>0-4 294 967 295 bytes</td>
<td>二进制形式的极大文本数据</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>0-4 294 967 295 bytes</td>
<td>极大文本数据</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>DATE</th>
<th>3</th>
<th>1000-01-01/9999-12-31</th>
<th>YYYY-MM-DD</th>
<th>日期值</th>
</tr>
</thead>
<tbody><tr>
<td>TIME</td>
<td>3  bytes</td>
<td>‘-838:59:59’/‘838:59:59’</td>
<td>HH:MM:SS</td>
<td>时间值或持续时间</td>
</tr>
<tr>
<td>YEAR</td>
<td>1 bytes</td>
<td>1901/2155</td>
<td>YYYY</td>
<td>年份值</td>
</tr>
<tr>
<td>DATETIME</td>
<td>8 bytes</td>
<td>1000-01-01 00:00:00/9999-12-31 23:59:59</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4 bytes</td>
<td>1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td>
<td>YYYYMMDD HHMMSS</td>
<td>混合日期和时间值，时间戳</td>
</tr>
</tbody></table>
<h6 id="INT-INTEGER"><a href="#INT-INTEGER" class="headerlink" title="INT(INTEGER)"></a>INT(INTEGER)</h6><p><code>TINYINT</code>,<code>SMALLINT</code>,<code>MEDIUMINT</code>,<code>BIGINT</code>同理。</p>
<p><code>int</code>的长度是4字节， <code>INT(M)</code>的意思是现在最大宽度为<code>M</code>。如果你选择了<code>zero fill</code>，不足<code>M</code>位会给前面自动补<code>0</code>，如果不选，大于<code>M</code>位正常显示。索引如果不为了<code>补0</code>，<code>M</code>指定多少都无所谓。。</p>
<h6 id="DECIMAL"><a href="#DECIMAL" class="headerlink" title="DECIMAL"></a>DECIMAL</h6><p>FLOAT 类型固定占用4个字节， DOUBLE 类型固定占用8个字节</p>
<p>DECIMAL(M,D) ，其中 M 表示最大位数，D 表示小数点右侧的位数。这里的“位”不是二进制的比特位，而是指十进制的数字的位数。</p>
<h6 id="varchar和char"><a href="#varchar和char" class="headerlink" title="varchar和char"></a>varchar和char</h6><p>CHAR(n) 和 VARCHAR(n) 两者中的 n 含义均为该字段最大可容纳的<strong>字符</strong>数。</p>
<p>CHAR(n) 和 VARCHAR(n) <strong>字段值的占用空间不是固定的，而是由实际存入的内容决定的</strong>。</p>
<h5 id="MySQL中主要的存储引擎"><a href="#MySQL中主要的存储引擎" class="headerlink" title="MySQL中主要的存储引擎"></a><strong>MySQL中主要的存储引擎</strong></h5><ul>
<li><strong>MyISAM</strong>是MySQL官方提供的存储引擎，其特点是支持全文索引，查询效率比较高，缺点是不支持事务、使用表级锁。</li>
<li><strong>InnoDB</strong>在5.5版本后成为了Mysql的默认存储引擎，特点是支持ACID事务、支持外键、支持行级锁提高了并发效率</li>
</ul>
<h5 id="drop、delete与truncate区别？"><a href="#drop、delete与truncate区别？" class="headerlink" title="drop、delete与truncate区别？"></a><strong>drop、delete</strong>与<strong>truncate</strong>区别？</h5><ul>
<li><strong>delete和truncate</strong>只删除表的数据不删除表的结构</li>
<li>速度,一般来说: <strong>drop&gt; truncate &gt;delete</strong></li>
<li><strong>delete</strong>语句是dml,这个操作会放到<strong>rollback segement</strong>中,事务提交之后才生效，如果有相应的<strong>trigger</strong>,执行的时候将被触发</li>
<li><strong>truncate,drop</strong>是ddl, 操作立即生效,原数据不放到r<strong>ollback segment</strong>中,不能回滚. 操作不触发<strong>trigger</strong></li>
</ul>
<h5 id="MySQL中的锁"><a href="#MySQL中的锁" class="headerlink" title="MySQL中的锁"></a><strong>MySQL中的锁</strong></h5><h6 id="MyISAM使用表级锁"><a href="#MyISAM使用表级锁" class="headerlink" title="MyISAM使用表级锁"></a>MyISAM使用表级锁</h6><ul>
<li>表锁开销小，加锁快，不会出现死锁；但是锁的粒度大，发生锁冲突的概率高，并发访问效率比较低。</li>
</ul>
<h6 id="InnoDB使用行级锁"><a href="#InnoDB使用行级锁" class="headerlink" title="InnoDB使用行级锁"></a>InnoDB使用行级锁</h6><ul>
<li>行级锁开销大，加锁慢，有可能会出现死锁，不过因为锁定粒度最小，发生锁冲突的概率低，并发访问效率比较高。</li>
</ul>
<h6 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h6><p><strong>共享锁</strong>也就是读锁，其他事务可以读，但不能写。MySQL可以通过Lock In Share Mode语句显示使用共享锁。</p>
<h6 id="排它锁"><a href="#排它锁" class="headerlink" title="排它锁"></a>排它锁</h6><p><strong>排他锁</strong>就是写锁，其他事务不能读取，也不能写。对于Update、Delete和INSERT语句，InnoDB会自动给涉及的数据集加排他锁，或者使用select for update显示使用排他锁。</p>
<h6 id="乐观锁和悲观锁是什么"><a href="#乐观锁和悲观锁是什么" class="headerlink" title="乐观锁和悲观锁是什么?"></a><a href="https://www.open-open.com/lib/view/open1452046967245.html">乐观锁和悲观锁</a>是什么?</h6><ul>
<li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</li>
<li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性</li>
</ul>
<h5 id="MySQL的存储过程与函数"><a href="#MySQL的存储过程与函数" class="headerlink" title="MySQL的存储过程与函数"></a><strong>MySQL的存储过程与函数</strong></h5><h6 id="什么是存储过程？"><a href="#什么是存储过程？" class="headerlink" title="什么是存储过程？"></a>什么是存储过程？</h6><ul>
<li>存储过程是一些预编译的SQL语句。</li>
<li>存储过程是一个预编译的代码块，执行效率比较高</li>
<li>一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率</li>
<li>可以一定程度上确保数据安全</li>
</ul>
<h6 id="存储过程的优缺点？"><a href="#存储过程的优缺点？" class="headerlink" title="存储过程的优缺点？"></a>存储过程的优缺点？</h6><p>优点：</p>
<ul>
<li>执行效率比较高</li>
<li>可以降低网络通信量，提高通信速率</li>
<li>可以一定程度上确保数据安全</li>
</ul>
<p>缺点：</p>
<ul>
<li>存储过程一般与数据库实现绑定，使用存储过程会降低程序的可移植性</li>
</ul>
<h5 id="为什么不推荐使用外键？"><a href="#为什么不推荐使用外键？" class="headerlink" title="为什么不推荐使用外键？"></a>为什么不推荐使用外键？</h5><p><a href="https://www.zhihu.com/question/39062169">详见</a></p>
<p>优点：</p>
<ul>
<li>关系型数据库，外键的约束为我们保证了数据主从关系和产生的先后关系，级联操作为我们的update和delete带来了不少方便。</li>
</ul>
<p>缺点：</p>
<ul>
<li>数据库需要维护外键的内部管理。</li>
<li>外键等于把数据的一致性事务实现，全部交给数据库服务器完成；</li>
<li>有了外键，当做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，而不得不消耗资源</li>
<li>外键还会因为需要请求对其他表内部加锁而容易出现死锁情况。</li>
<li>总的来说就是性能问题，然后不易于表的变动和扩展。</li>
</ul>
<p>限制：</p>
<ul>
<li>所有tables必须是InnoDB型，它们不能是临时表。</li>
<li>在引用表中，必须有一个索引，外键列以同样的顺序被列在其中作为第一列。这样一个索引如果不存在，它必须在引用表里被自动创建。</li>
<li>不支持对外键列的索引前缀。这样的后果之一是BLOB和TEXT列不被包括在一个外键中，这是因为对这些列的索引必须总是包含一个前缀长度</li>
<li>InnoDB不对那些外键或包含NULL列的被引用键值检查外键约束</li>
</ul>
<h5 id="mysql8-0的新特性"><a href="#mysql8-0的新特性" class="headerlink" title="mysql8.0的新特性"></a>mysql8.0的新特性</h5><ul>
<li><p>默认字符集格式改为了UTF8</p>
</li>
<li><p>增加了隐藏索引的功能，隐藏后的索引不会被查询优化器使用，可以使用这个特性用于性能调试</p>
</li>
<li><p>支持了通用表表达式，使复杂查询中的嵌入表语句更加清晰</p>
</li>
<li><p>新增了<a href="https://zhuanlan.zhihu.com/p/92654574">窗口函数</a>的概念，它可以用来实现新的查询方式。窗口函数与 SUM、COUNT等集合函数类似，但不会将多行查询结果合并，而是将结果放在多行中。即窗口函数不需要GROUP BY。</p>
<ul>
<li><p>同时具有分组和排序的功能</p>
</li>
<li><p>同时具有分组和排序的功能</p>
</li>
<li><p><code>&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt; order by &lt;用于排序的列名&gt;)</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="MySQL调优"><a href="#MySQL调优" class="headerlink" title="MySQL调优"></a><strong>MySQL调优</strong></h3><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p> <strong>索引是什么？</strong></p>
<ul>
<li>索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。</li>
</ul>
<p><strong>索引的优缺点</strong></p>
<p>优点：</p>
<ul>
<li><p>索引加快数据库的检索速度</p>
</li>
<li><p>唯一索引可以确保每一行数据的唯一性</p>
</li>
<li><p>通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能</p>
</li>
<li><p><font color=red><strong>因此索引比较适合用在读多写少的场景。</strong></font></p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>需要额外的磁盘空间来保存索引</p>
</li>
<li><p>对于插入、更新、删除等操作由于更新索引会增加额外的开销</p>
</li>
</ul>
<p><strong>mysql有几种索引类型?</strong></p>
<ul>
<li> <strong>唯一索引：</strong>就是索引列中的值必须是唯一的，但是允许出现空值。这种索引一般用来保证数据的唯一性，比如保存账户信息的表，每个账户的id必须保证唯一，如果重复插入相同的账户id时会MySQL返回异常。</li>
<li> <strong>主键索引：</strong>是一种特殊的唯一索引，但是它不允许出现空值。</li>
<li> <strong>普通索引：</strong>与唯一索引不同，它允许索引列中存在相同的值。例如学生的成绩表，各个学科的分数是允许重复的，就可以使用普通索引。</li>
<li> <strong>联合索引：</strong>就是由多个列共同组成的索引。一个表中含有多个单列的索引并不是联合索引，联合索引是对多个列字段按顺序共同组成一个索引。应用联合索引时需要注意最左原则，就是Where查询条件中的字段必须与索引字段从左到右进行匹配。比如，一个用户信息表，用姓名和年龄组成了联合索引，如果查询条件是姓名等于张三，那么满足最左原则；如果查询条件是年龄大于20，由于索引中最左的字段是姓名不是年龄，所以不能使用这个索引。</li>
<li> <strong>全文索引：</strong>前面提到了，MyISAM引擎中实现了这个索引，在5.6版本后InnoDB引擎也支持了全文索引，并且在5.7.6版本后支持了中文索引。全文索引只能在CHAR,VARCHAR,TEXT类型字段上使用，底层使用倒排索引实现。要注意对于大数据量的表，生成全文索引会非常消耗时间也非常消耗磁盘空间。</li>
</ul>
<p><strong>索引实现?</strong></p>
<ul>
<li><a href="%5Bhttps://ruomuc.gitee.io/blog/2019/05/11/%E5%85%B3%E4%BA%8Emysql%E7%9A%84%E7%B4%A2%E5%BC%95/%5D(https://ruomuc.gitee.io/blog/2019/05/11/%E5%85%B3%E4%BA%8Emysql%E7%9A%84%E7%B4%A2%E5%BC%95/)"><strong>B+树实现</strong></a>：b+树比较适合用作’&gt;’或’&lt;’这样的范围查询，是MySQL中最常使用的一种索引实现。</li>
<li><strong>R-tree：</strong>是一种用于处理多维数据的数据结构，可以对地理数据进行空间索引。不过实际业务场景中使用的比较少。</li>
<li><strong>Hash：</strong>是使用散列表来对数据进行索引，Hash方式不像Btree那样需要多次查询才能定位到记录，因此Hash索引的效率高于B-tree，但是不支持范围查找和排序等功能.实际使用的也比较少。</li>
<li><strong>FullText：</strong>就是我们前面提到的全文索引，是一种记录关键字与对应文档关系的倒排索引。</li>
</ul>
<h4 id="一手好-SQL-是如何炼成的？"><a href="#一手好-SQL-是如何炼成的？" class="headerlink" title="一手好 SQL 是如何炼成的？"></a><a href="https://mp.weixin.qq.com/s/ZBgv-s-_ojWMiTZYTVx-iQ">一手好 SQL 是如何炼成的？</a></h4><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>详细用法可以看这里<a href="http://redisdoc.com/">redis文档</a>或者这里<a href="%5Bhttps://ruomuc.gitee.io/blog/2019/03/26/%E5%85%B3%E4%BA%8Eredis%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/%5D">关于redis的基本操作</a></p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="五种基本类型"><a href="#五种基本类型" class="headerlink" title="五种基本类型"></a>五种基本类型</h5><ul>
<li><code>String</code>字符串<ul>
<li>session</li>
<li>kv缓存。比如分布式锁。</li>
<li>数值计数计算器。DECR INCR DECRBY INCRBY</li>
<li><code>bitmap</code>。存二进制数据，统计用户每天登陆情况，统计用户活跃数。</li>
</ul>
</li>
<li><code>Hash</code>哈希<ul>
<li>聚集数据</li>
<li>详情页</li>
</ul>
</li>
<li><code>List</code>列表<ul>
<li>评论列表</li>
<li>消息队列</li>
<li>队列和栈数据结构的东西。</li>
</ul>
</li>
<li><code>Set</code>集合<ul>
<li>抽奖</li>
<li>验证码</li>
<li>扑克牌游戏</li>
</ul>
</li>
<li><code>SortedSet</code>有序集合</li>
</ul>
<h5 id="高级一点的数据类型"><a href="#高级一点的数据类型" class="headerlink" title="高级一点的数据类型"></a>高级一点的数据类型</h5><ul>
<li><a href="https://www.runoob.com/redis/redis-hyperloglog.html">HyperLogLog</a>是用来做基数统计的算法,所谓基数就是不重复元素的个数，可以用<code>Set</code>或<code>bitmap</code>来做，但是数据大了没有这个HyperLogLog效率高，<a href="https://zhuanlan.zhihu.com/p/58519480">HyperLogLog的实现原理</a>。</li>
<li><a href="https://blog.huangz.me/diary/2015/redis-geo.html">GEO</a>。Redis 的 GEO 特性将在 Redis 3.2 版本释出， 这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作。</li>
<li><a href="https://www.runoob.com/redis/redis-pub-sub.html">Pub/Sub发布订阅</a>。可以用来做消息队列。<a href="http://www.hellokang.net/redis/message-queue-by-redis.html#_1-%E6%A6%82%E8%BF%B0">基于Redis实现消息队列典型方案</a></li>
</ul>
<h5 id="更高级一点的模块"><a href="#更高级一点的模块" class="headerlink" title="更高级一点的模块"></a>更高级一点的模块</h5><ul>
<li><a href="https://juejin.im/post/5cfd060ee51d4556f76e8067">布隆过滤器</a>。可以了解一下什么是<a href="https://blog.csdn.net/zeb_perfect/article/details/54135506">缓存穿透，缓存雪崩和缓存击穿</a></li>
<li><a href="https://oss.redislabs.com/redisearch/Quick_Start.html">RediSearch</a>。基于redis的一个搜索引擎。</li>
<li>Redis-ML。。。这个涉及到机器学习。就不了解了</li>
</ul>
<h4 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h4><p>同时开启<code>RDB</code>和<code>AOF</code>，redis会使用<code>AOF</code>文件恢复而不使用<code>RDB</code>文件。</p>
<h5 id="快照RDB"><a href="#快照RDB" class="headerlink" title="快照RDB"></a>快照RDB</h5><p>RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。</p>
<p>原理： redis会调用fork()产生一个子进程，子进程会把数据写入到一个临时的RDB文件，当子进程写完之后，用临时的RDB文件替换掉旧的RDB文件。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>性能好</li>
<li>恢复快</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>两个备份时间点之间如果服务器宕机，中间的数据会丢失。</li>
</ul>
<p>**配置(redis.conf)**：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RDB文件名，默认为dump.rdb。</span></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">dump.rdb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存点可以设置多个。每60秒，如果数据发生了1000次以上的变动，Redis就会自动保存快照文件</span></span><br><span class="line"><span class="string">save</span> <span class="number">60</span> <span class="number">1000</span> <span class="comment">#60秒后至少1000个key有变动</span></span><br><span class="line"><span class="string">save</span> <span class="number">300</span> <span class="number">10</span> <span class="comment">#300秒后至少10个key有变动</span></span><br><span class="line"><span class="string">save</span> <span class="number">60</span> <span class="number">10000</span> <span class="comment">#60秒后至少10000个key有变动</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用快照，注释所有save，或者在最后一条加上</span></span><br><span class="line"><span class="string">save</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认Redis会采用LZF对数据压缩 yes打开，no关闭</span></span><br><span class="line"><span class="string">rdbcompression</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据校验文件完整性，会损失10%左右性能，yes打开，no关闭</span></span><br><span class="line"><span class="string">rdbchecksum</span> <span class="literal">yes</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>手动生成快照</strong>：</p>
<ul>
<li>save 。 同步生成RDB文件，会阻塞其它客户端请求，不建议使用</li>
<li>bgsave。<ul>
<li>调用BGSAVE会立刻返回ok</li>
<li>redis会产生一个子进程保存快照，并恢复主进程处理客户端请求</li>
<li>使用<code>LASTSAVE</code>来查看操作是否成功</li>
</ul>
</li>
</ul>
<h5 id="追加式文件-AOF"><a href="#追加式文件-AOF" class="headerlink" title="追加式文件 AOF"></a>追加式文件 AOF</h5><p>记录你的每一条操作指令，恢复数据其实就是执行一遍文件保存的指令。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>比RDB可靠。可以制定不同的fsync策略。</li>
<li>当AOF文件太大时，Redis会自动在后台进行重写。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>相同数据情况下，AOF会被RDB文件大。<strong>极端情况下，假设有一个运行了几年的redis服务，但是操作只有创建一个key，删除一个key，rdb最多会保存一个数据，但是aof文件会有非常多的数据。</strong></li>
<li>在某些fsync策略下，速度会比RDB慢。</li>
</ul>
<p><strong>配置</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开aof功能</span></span><br><span class="line"><span class="string">appendonly</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件存放目录，与RDB共用。默认为当前工作目录。</span></span><br><span class="line"><span class="string">dir</span> <span class="string">./</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认文件名为appendonly.aof</span></span><br><span class="line"><span class="string">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># always是每次都会追加，everysec是一秒追加一次，no是不追加。。推荐一秒一次，丢失数据只丢一秒，性能也不会太慢。</span></span><br><span class="line"><span class="comment"># appendfsync always</span></span><br><span class="line"><span class="string">appendfsync</span> <span class="string">everysec</span></span><br><span class="line"><span class="comment"># appendfsync no</span></span><br></pre></td></tr></table></figure>

<h5 id="aof文件重写"><a href="#aof文件重写" class="headerlink" title="aof文件重写"></a>aof文件重写</h5><p>日志重新解决的就是我上面描述的问题，假设有十万条命令的执行结果就是增加一个key，那么aof文件恢复会依次执行这十万条命令，就很浪费性能，所以redis支持后台重建aof文件。</p>
<p>工作原理：</p>
<ul>
<li>Redis调用fork()，产生一个子进程。</li>
<li>子进程把新的AOF写到一个临时文件里。</li>
<li>主进程持续把新的变动写到内存里的buffer，同时也会把这些新的变动写到旧的AOF里，这样即使重写失败也能保证数据的安全。</li>
<li>当子进程完成文件的重写后，主进程会获得一个信号，然后把内存里的buffer追加到子进程生成的那个新AOF里。</li>
</ul>
<p><strong>重写配置</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Redis会记住自从上一次重写后AOF文件的大小（如果自Redis启动后还没重写过，则记住启动时使用的AOF文件的大小）。</span></span><br><span class="line"><span class="comment"># 如果当前的文件大小比起记住的那个大小超过指定的百分比，则会触发重写。</span></span><br><span class="line"><span class="comment"># 同时需要设置一个文件大小最小值，只有大于这个值文件才会重写，以防文件很小，但是已经达到百分比的情况。</span></span><br><span class="line"></span><br><span class="line"><span class="string">auto-aof-rewrite-percentage</span> <span class="number">100</span></span><br><span class="line"><span class="string">auto-aof-rewrite-min-size</span> <span class="string">64mb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 百分比设置为0会禁用这个功能</span></span><br><span class="line"><span class="string">auto-aof-rewrite-percentage</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="主从和集群"><a href="#主从和集群" class="headerlink" title="主从和集群"></a>主从和集群</h4><ul>
<li>Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。</li>
<li>Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</li>
</ul>
<h4 id="redis面试问题"><a href="#redis面试问题" class="headerlink" title="redis面试问题"></a>redis面试问题</h4><p><a href="https://zhuanlan.zhihu.com/p/32540678">天下无难试之Redis面试题刁难大全</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/89620471">redis吊打面试官系列。。。</a></p>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h3 id="什么是MOngoDB？"><a href="#什么是MOngoDB？" class="headerlink" title="什么是MOngoDB？"></a>什么是MOngoDB？</h3><ul>
<li>MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。</li>
<li>MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。</li>
<li>MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>redis</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs必知必会</title>
    <url>/2020/05/13/nodejs%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    怎么说呢，很多东西其实之前都整理过，但那是一个学习的过程，很多东西不够准确、严谨。突然就想把看过学过的零散知识重新整理一遍。</p>
<h2 id="JavaScript基础问题"><a href="#JavaScript基础问题" class="headerlink" title="JavaScript基础问题"></a>JavaScript基础问题</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><h5 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h5><h6 id="一般数据类型"><a href="#一般数据类型" class="headerlink" title="一般数据类型"></a>一般数据类型</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// undefined</span></span><br><span class="line"> <span class="keyword">typeof</span> []; <span class="comment">// object</span></span><br><span class="line"> <span class="keyword">typeof</span> <span class="string">&#x27;123&#x27;</span>; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>; <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span>; <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;; <span class="string">&quot;function&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// &quot;object&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="特殊的数据类型"><a href="#特殊的数据类型" class="headerlink" title="特殊的数据类型"></a>特殊的数据类型</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// object 因为null是一个空对象</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>; <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>(<span class="string">&quot;a&quot;</span>); <span class="comment">// &quot;symbol&quot;</span></span><br></pre></td></tr></table></figure>



<h5 id="instanceof操作符"><a href="#instanceof操作符" class="headerlink" title="instanceof操作符"></a>instanceof操作符</h5><blockquote>
<p>instanceof操作符主要用来<strong>检查构造函数的原型是否在对象的原型链上</strong>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s <span class="keyword">instanceof</span> <span class="title class_">String</span>; <span class="comment">// true</span></span><br><span class="line">s <span class="keyword">instanceof</span> <span class="title class_">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>接下来让我们搞点事情：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">s.<span class="property">__proto__</span> = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// 这是把s变量的原型链指向，Object的原型链。</span></span><br><span class="line"></span><br><span class="line">s <span class="keyword">instanceof</span> <span class="title class_">String</span>; <span class="comment">// false</span></span><br><span class="line">s <span class="keyword">instanceof</span> <span class="title class_">Object</span>; <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>利用instanceof操作符，我们可以对自定义的对象进行判断：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span> (name) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fizz = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;fizz&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fizz <span class="keyword">instanceof</span> <span class="title class_">Animal</span> <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h5><blockquote>
<p>实际上我们也可以通过constructor属性来达到类型判断的效果：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fizz <span class="keyword">instanceof</span> <span class="title class_">Animal</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h5 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h5><p>利用toString方法基本上可以解决所有内置对象类型的判断：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">type</span> (obj) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>, obj, []).<span class="title function_">replace</span>(<span class="regexp">/^\[object\s(\w+)\]$/</span>, <span class="string">&#x27;$1&#x27;</span>).<span class="title function_">toLowerCase</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">type</span>(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;123&#x27;</span>)) <span class="comment">// string</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="类型比较"><a href="#类型比较" class="headerlink" title="类型比较"></a>类型比较</h4><h5 id="全等"><a href="#全等" class="headerlink" title="全等==="></a>全等<code>===</code></h5><ul>
<li>全等不会进行类型转换，类型不相等就是false。</li>
<li>类型相等之后会再去比较数值。<ul>
<li>基本数据类型 <code>number、string、boolean</code>会直接比较值。</li>
<li>引用数据类型 <code>Object、Array、Function</code>会比较地址。</li>
</ul>
</li>
<li><code>+0</code>和<code>-0</code>是全等的，<code>NaN</code>和<code>NaN</code>是不全等的。</li>
</ul>
<h5 id="相等"><a href="#相等" class="headerlink" title="相等=="></a>相等<code>==</code></h5><p>被比较值A \ 被比较值B | undefined | null | Number |   String   |  Boolean    | Object     |<br>| :——————-: | :——-: | :–: | :—-: | —- | :— | —- |<br>| <strong>undefined</strong>         | true | true | false | false | false | IsFalsy(B) |<br>| <strong>null</strong>              | true | true | false | false | false | IsFalsy(B) |<br>| <strong>Number</strong>            | false | false | A === B | A === ToNumber(B) | A === ToNumber(B) | A== ToPrimitive(B) |<br>| <strong>String</strong>            | false | false | ToNumber(A)===B | A === B | ToNumber(A)===ToNumber(B) | A== ToPrimitive(B) |<br>| <strong>Boolean</strong>           | false | false | ToNumber(A)===B | ToNumber(A)===ToNumber(B) | A === B | ToNumber(A) == ToPrimitive(B) |<br>| <strong>Object</strong>            | false | false | ToPrimitive(A) == B | ToPrimitive(A) == B | ToPrimitive(A) == ToNumber(B) | A === B |</p>
<ul>
<li><p>相等的比较规则是：<code>先检查类型是否相同，类型相同直接进行全等比较，类型不同根据上表中规则进行类型转化，在进行全等比较。</code></p>
</li>
<li><p>但不是所有的类型都满足上述规则。</p>
<ul>
<li>Object类型转为原始值之后，使用的相等和其他值进行比较。就是说要再比较类型，转换类型，再进行全等比较。</li>
<li>undefined和null是相等的。并且一般情况下，他们不和其他任何类型的数据相等。但是当有类似于<code>document.all</code>这种效仿<code>undefined</code>对象时，他们相等。</li>
</ul>
</li>
<li><p>转换规则：</p>
<ul>
<li><code>ToNumber(A)</code> 尝试在比较前将参数 A 转换为数字。</li>
<li><code>ToPrimitive(A)</code>通过尝试调用 A 的<code>A.toString()</code> 和 <code>A.valueOf()</code> 方法，将参数 A 转换为原始值。</li>
</ul>
</li>
</ul>
<h5 id="Object-is-value1-value2"><a href="#Object-is-value1-value2" class="headerlink" title="Object.is(value1,value2)"></a>Object.is(value1,value2)</h5><blockquote>
<p><strong><code>Object.is()</code> 判断两个值是否<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness">相同</a>。如果下列任何一项成立，则两个值相同:</strong></p>
</blockquote>
<ul>
<li>两个值都是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a></li>
<li>两个值都是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a></li>
<li>两个值都是 <code>true</code> 或者都是 <code>false</code></li>
<li>两个值是由相同个数的字符按照相同的顺序组成的字符串</li>
<li>两个值指向同一个对象</li>
<li>两个值都是数字并且<ul>
<li>都是正零 <code>+0</code></li>
<li>都是负零 <code>-0</code></li>
<li>都是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a></li>
<li>都是除零和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a> 外的其它同一个数字</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>与相等（==）和全等（===）不同点</strong>s</p>
</blockquote>
<ul>
<li>与普通<code>==</code>不同的是，<code>Object.is()</code>不会对数据进行数据类型转换。</li>
<li>与全等<code>===</code>不同的是，<code>Object.is(NaN,NaN) </code>结果是<code>true</code>，而<code>Object.is(-0,+0) </code>结果是<code>false</code>。这与<code>全等（===）</code>刚好相反。</li>
</ul>
<hr>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>关于作用域的问题<a href="https://book.douban.com/subject/26351021/">《你不知道的 JavaScript》</a> 讲的很好, 推荐细读。这里只说一下简单围绕<code>var</code>、<code>let</code>、<code>const</code>说一下。</p>
<h5 id="var和let的区别"><a href="#var和let的区别" class="headerlink" title="var和let的区别"></a>var和let的区别</h5><p>详情请看<a href="https://es6.ruanyifeng.com/#docs/let">阮一峰老师的es6教程</a>，这里大概说几个常用的区别。</p>
<ol>
<li>let声明的变量只在当前块有效。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let变量只在块中生效</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>let不存在变量提升。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量提升</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有变量提升会报错</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo2)</span><br><span class="line"><span class="keyword">let</span> foo2 = <span class="number">11</span>; <span class="comment">// foo2 is not defined</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>let声明变量有暂时性死区。let声明变量后，这个变量就和当前块绑定，不受外部影响。一般只要遵循先声明后使用的规范，就不会有这种问题。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">	tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// tmp is not defined</span></span><br><span class="line">	<span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>let变量不允许重复声明。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a1 = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a1 = <span class="number">1</span>; <span class="comment">// Identifier &#x27;a1&#x27; has already been declared</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func3</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a2 = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> a2 = <span class="number">1</span>; <span class="comment">// Identifier &#x27;a2&#x27; has already been declared</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func1</span>();</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> arg; <span class="comment">// Identifier &#x27;arg&#x27; has already been declared。 因为形参其实也是一个变量。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的写法都不会有问题</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> arg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg); <span class="comment">// 10</span></span><br><span class="line">  <span class="keyword">var</span> arg = <span class="number">100</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg); <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>大多数情况下，强烈建议，在函数中，尤其是for循环中使用let。因为var很容易造成一些不必要的bug。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// undefined 这里我们的本意是输出new Date()，但是由于var的变量提升，导致输出了undefined</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="number">5</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 5</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>(); <span class="comment">// 可以发现let声明的变量，如果本块内没有赋值，它回去外层作用域找值，如果有赋值，只要在本快内，都不会受到其它地方赋值的影响。</span></span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 5  这里的i本来只是for循环中用来计数的一个变量，但是循环完成后，i泄露为了全局变量。</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>let可以代替匿名自执行函数的写法，当你在for循环中调用一个异步方法时，它使用的总是循环变量的最终值。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 输出10个10</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果改写成这样</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    (<span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 输出0-9</span></span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用let声明变量更加简单</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 输出0-9，因为let声明的变量是块级变量，所以不需要使用函数调用的方式来隔离</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="const"><a href="#const" class="headerlink" title="const"></a>const</h5><ol>
<li><strong>const</strong>声明一个只读变量一旦声明，常量的值就不能变，如果再次声明会报错。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">a = <span class="number">2</span>; <span class="comment">// Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>const</strong>变量声明时，必须初始化，不能留到后面赋值</p>
</li>
<li><p><strong>const</strong>和<strong>let</strong>一样，只在块级作用域生效，不存在变量提升，存在暂时性死区</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 10</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line">        <span class="keyword">const</span> a = <span class="number">5</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>()</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>const</strong> 变量声明变量不可变的本质。</li>
</ol>
<p>基本数据类型，值存在栈中，const声明时，变量值不可改变。</p>
<p>引用数据类型，值在堆中，栈中只是一个指向这个值在堆中的一个地址，不可改变的是这个地址，而不是堆中的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.<span class="title function_">push</span>(<span class="string">&#x27;Hello&#x27;</span>); <span class="comment">// 可执行</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, a.<span class="property">length</span>) <span class="comment">// [ &#x27;Hello&#x27; ] 1</span></span><br><span class="line">a.<span class="property">length</span> = <span class="number">0</span>;    <span class="comment">// 可执行 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, a.<span class="property">length</span>) <span class="comment">// [] 0</span></span><br><span class="line">a = [<span class="string">&#x27;Dave&#x27;</span>];    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>如果要彻底冻结一个对象，使用<code>Object.freeze</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line">foo.<span class="property">prop</span> = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个冻结对象函数，递归冻结。</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">constantize</span> = (<span class="params">obj</span>) =&gt; &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj);</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>( <span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span> ) &#123;</span><br><span class="line">      <span class="title function_">constantize</span>( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><p>详情见 <a href="https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">阮一峰老师的闭包讲解</a></p>
<ul>
<li><p>通俗来讲，就是函数外部是无法访问函数内部的变量，但是通过闭包处理，就可以在函数外部访问函数内部的变量。</p>
</li>
<li><p>引用轮子哥的话： 闭包不是私有，闭的意思不是“封闭内部状态”，而是”封闭外部状态“。</p>
</li>
<li><p>举个列子，栗子中的<code>f2</code>函数就是闭包：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">f2</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="title function_">f1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 999</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n) <span class="comment">// ReferenceError: n is not defined</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="值传递和引用传递？"><a href="#值传递和引用传递？" class="headerlink" title="值传递和引用传递？"></a>值传递和引用传递？</h3><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>​    先来看一张图</p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/20180322141202_19288.png"></p>
<ul>
<li>由图可知，非基本类型，栈内存储的是实际值在堆中的一个地址，通过这个地址找到实际的值。</li>
<li>关于引用传递和传引用，js到有没有传引用，移步<a href="%5Bhttps://ruomuc.gitee.io/blog/2019/05/22/js%E4%B9%8B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/%5D(https://ruomuc.gitee.io/blog/2019/05/22/js%E4%B9%8B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/)">js之你不知道的引用传递</a></li>
</ul>
<h5 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h5><ul>
<li><p>深拷贝和浅拷贝是对JavaScript “引用传递” 的一种应用。</p>
</li>
<li><p>假设你要将一个对象复制给另一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zm&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = obj;</span><br><span class="line"></span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&#x27;ruomu&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123; name: &#x27;ruomu&#x27; &#125; 为什么我修改obj2的值，但是obj也变了呢。。因为其实他们存储了相同的地址值，指向了堆内同一对象。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zm&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: obj.<span class="property">name</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&#x27;ruomu&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123; name: &#x27;zm&#x27; &#125; 可以看到这里就不会被修改了，因为基础类型存储在栈中，修改就是直接修改栈中的值。</span></span><br></pre></td></tr></table></figure></li>
<li><p>所以使用对象赋值时要非常小心，因为node是异步的，不知道在哪里就修改了那个对象，会引起很多bug。所以通常我们想copy一个对象时，需要一些特殊的处理来达到目的。<a href="%5Bhttps://ruomuc.gitee.io/blog/2018/06/26/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/%5D(https://ruomuc.gitee.io/blog/2018/06/26/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/)">深拷贝和浅拷贝</a></p>
<ul>
<li>上面的连接有几种写好的深度拷贝方法，就不重复造轮子了。当然最简单的当然是<code>JSON.parse(JSON.stringify(obj))</code> 。</li>
</ul>
</li>
</ul>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h5 id="v8内存的大小"><a href="#v8内存的大小" class="headerlink" title="v8内存的大小"></a>v8内存的大小</h5><ul>
<li>64位下新生代的空间为64MB，老生代为1400MB。</li>
<li>32为下新生代的空间为16MB，老生代为700MB。</li>
<li>修改新生代和老生代内存的方式<ul>
<li>**<code>--max_semi_space_size=xxxx</code>**。修改新生代内存，单位为KB</li>
<li>**<code>--max-old-space-size=xxxx</code>**。修改老生代内存，单位为MB</li>
</ul>
</li>
</ul>
<h5 id="v8内存清理机制"><a href="#v8内存清理机制" class="headerlink" title="v8内存清理机制"></a>v8内存清理机制</h5><ul>
<li><a href="%5Bhttps://ruomuc.gitee.io/blog/2018/07/31/V8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6/%5D(https://ruomuc.gitee.io/blog/2018/07/31/V8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6/)">V8的垃圾回收机制和内存限制</a></li>
<li>新生代，牺牲空间换时间，只能使用新生代一半的内存。<ul>
<li>最开始的变量放在新生代的from空间</li>
<li>执行垃圾回收时，将存活的对象从新生代的from空间放到to空间，非存活对象会被释放。</li>
<li>完成从from到to空间的复制后，from空间和to空间会发生角色互换。</li>
</ul>
</li>
<li>对象晋升<ul>
<li>对象晋升发生的时间是在，将新生代from空间中存活的对象复制到to空间的时候。</li>
<li>对象晋升的条件是：<ul>
<li>新生代to空间的占用率达到25%以上，对象直接被放入老生代空间中。</li>
<li>对象已经经历过一次新生代空间（Scavenge）的回收。</li>
</ul>
</li>
</ul>
</li>
<li>老生代空间<ul>
<li>老生代空间的对象一般都是存活时间比较久的对象，所以如果采用新生代空间的<code>Scavenge</code>算法，复制对象效率会很低，而且空间会浪费一半。所以v8老生代空间主要采用了<code>Mark-Sweep</code>和<code>Mark-Compact</code>相结合的方式进行垃圾回收。</li>
<li>Mark-Sweep是标记清除的意思，它分为标记阶段和清除阶段。它最大的问题是，清理完成后，内存空间会不连续。<ul>
<li>标记阶段。遍历堆中所有的对象，并标记活着的对象。</li>
<li>清除阶段。清除没有被标记的对象。</li>
</ul>
</li>
<li>Mark-Compact是标记整理的意思，它分为标记，整理，清除三步。它的问题是速度比较慢，但是内存空间是连续的。<ul>
<li>标记和Mark-Sweep一样</li>
<li>整理。将活着的对象往一端移动。</li>
<li>清除。活着的对象移动完成后，清除掉边界外的内存。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="如何高效的使用内存"><a href="#如何高效的使用内存" class="headerlink" title="如何高效的使用内存"></a>如何高效的使用内存</h5><blockquote>
<p>内存被释放条件是，该对象没有被引用。</p>
</blockquote>
<ul>
<li><p>全部变量的释放条件是进程退出。所以全部变量会长时间存在于老生代内存中，所以尽量少定义全局变量，并及时对全局变量进行释放。</p>
<ul>
<li><code>global.foo = undefined</code>或者<code>delete global.foo</code></li>
<li>上面两种方式并不会释放掉原本<code>global.foo</code>指向的对象，而是取消对其的引用，在下一次gc的时候，如果没有其他指向其的引用，那么就会被释放。</li>
</ul>
</li>
<li><p>闭包可以实现外部作用域访问内部作用域中的变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">f2</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="title function_">f1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>引用上面闭包用到的一段代码。正常情况下，f1执行完成后，函数作用域内的变量都会随着作用域的销毁而被回收。但是这里的<code>b</code>保持对f2的引用，而f2访问了变量n，所以这里的函数和变量都不会被释放。</p>
</li>
<li><p>滥用闭包是内存泄露的重要原因之一。</p>
</li>
</ul>
</li>
</ul>
<h5 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h5><blockquote>
<p>内存泄露的排查还是比较复杂，需要配合日志和性能监控工具排查，这里只简单说几种情况。</p>
</blockquote>
<ul>
<li>缓存。（请使用redis或者buffer）</li>
<li>消费队列。（同上）</li>
<li>作用域未释放。（闭包）</li>
<li>cnode上面一个大佬写的<a href="https://cnodejs.org/topic/58eb5d378cda07442731569f"><strong>轻松排查线上Node内存泄漏问题</strong></a></li>
</ul>
<h5 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h5><p>​    看了下，网上关于node内存监控的东西很少，但最后试了下还是alinode最方便，对代码没有侵入。<a href="https://help.aliyun.com/document_detail/60338.html?spm=a2c4g.11174283.3.1.119930b1FamJTU">5分钟入门alinode</a></p>
<ul>
<li>安全问题。alinode好像没有开源，但是部署在本机上给alinode上传数据的agenthub是开源了的，可以自己抓包或者查看源代码，检查其是否上传敏感数据。</li>
<li>付费。目前alinode好像完全免费的，至于以后会不会收费，不知道。</li>
</ul>
<h3 id="es6基本语法"><a href="#es6基本语法" class="headerlink" title="es6基本语法"></a>es6基本语法</h3><p><a href="https://es6.ruanyifeng.com/">阮一峰老师的es入门教程</a></p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ul>
<li><p><a href="%5Bhttps://ruomuc.gitee.io/blog/2018/07/03/node-js%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/%5D(https://ruomuc.gitee.io/blog/2018/07/03/node-js%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/)">模块机制整理</a></p>
</li>
<li><p><a href="http://nodejs.cn/api/modules.html#modules_modules">官方模块文档</a></p>
</li>
<li><p><a href="https://cnodejs.org/topic/5734017ac3e4ef7657ab1215">exports和module.exports的区别</a></p>
<ul>
<li>总结一下就是，一直用module.exports总不会错的。</li>
</ul>
</li>
<li><p><a href="http://nodejs.cn/api/modules.html#modules_the_module_wrapper">模块封装器</a></p>
<ul>
<li>所以说通过<code>var let const </code>的作用范围是当前模块，而不加修饰的变量定义会造成全局污染，因为模块的作用域其实是函数作用域。</li>
</ul>
</li>
<li><p>为什么包装在全局的时候，项目中使用的时候会找不到。</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000019198107">https://segmentfault.com/a/1190000019198107</a></li>
<li>node扫描包的顺序是，<strong>从当前层向外层依次找node_modules文件夹</strong>，全局包的安装路径不符合这个规则的，所以找不到。</li>
</ul>
</li>
</ul>
<h2 id="事件-异步"><a href="#事件-异步" class="headerlink" title="事件/异步"></a>事件/异步</h2><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>​    详情可以看<a href="https://javascript.ruanyifeng.com/advanced/promise.html#toc9">阮一峰老师写的Promise对象</a></p>
<ul>
<li><p>Promise 的设计思想就是，所有异步任务都返回一个Promise实例。</p>
</li>
<li><p>Promise对象的状态：</p>
<ul>
<li>异步操作未完成（pending）</li>
<li>异步操作成功（fulfilled）</li>
<li>异步操作失败（rejected）</li>
</ul>
</li>
<li><p>Promise的状态变化的特点：</p>
<ul>
<li>只能从未完成（pending） ——&gt; 操作成功（fulfilled）/ 操作失败（rejected）。</li>
<li>状态一旦发生变化就不会再次改变。</li>
</ul>
</li>
<li><p>JavaScript提供原生的构造函数，用来生成Promise实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 异步操作失败 */</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>resolve的作用是把promise实例的状态从未完成（pending） ——&gt; 操作成功（fulfilled）</li>
<li>rejected的作用是把promise实例的状态从未完成（pending） ——&gt;操作失败（rejected）</li>
</ul>
</li>
<li><p>异常捕获</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">auto.<span class="title function_">getData</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">results</span>) &#123;</span><br><span class="line">     res.<span class="title function_">send</span>(results);</span><br><span class="line">&#125;, next);</span><br><span class="line">auto.<span class="title function_">getData</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">results</span>) &#123;</span><br><span class="line">     res.<span class="title function_">send</span>(results);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(next);</span><br></pre></td></tr></table></figure>

<ul>
<li>上述两种写法，第一种写法，只能捕获getData()产生的错误，而第二种写法，可以捕获到整个Promise调用链中的错误。</li>
</ul>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/58428287">Promise的实现原理</a></p>
</li>
</ul>
<h3 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h3><ul>
<li><code>Events</code>是node.js一个非常重要的 core 模块，比如 <code>Stream</code> 是基于 <code>Events</code> 实现的, 而 <code>fs</code>, <code>net</code>, <code>http</code> 等模块都依赖 <code>Stream</code></li>
<li>另外可以注意一下的是, 有些同学喜欢用 emitter 来监控某些类的状态, 但是在这些类释放的时候可能会忘记释放 emitter, 而这些类的内部可能持有该 emitter 的 listener 的引用从而导致内存泄漏</li>
</ul>
<h3 id="阻塞-异步"><a href="#阻塞-异步" class="headerlink" title="阻塞/异步"></a>阻塞/异步</h3><ul>
<li><p>如何判断接口是否异步? 是否只要有回调函数就是异步?</p>
<ul>
<li>看文档</li>
<li>console.log 打印看看</li>
<li>看是否有 IO 操作</li>
</ul>
</li>
<li><p>阻塞/非阻塞？异步同步？</p>
<ul>
<li>之前面试被问到过，我的理解如下：</li>
<li>假设面试完之后，HR给你打电话，告诉你你被录用了。如果你直接告诉了HR你同意或是拒绝，这就是**<code>同步</code><strong>，如果你说，我现在没时间，过两天再给你答复，这样就是</strong><code>异步</code><strong>；HR在听到你说过两天给他答复时，她继续去给下一个求职者打电话，这样就是</strong><code>非阻塞</code><strong>，如果HR什么都不敢，一直等着你的回复，这就是</strong><code>阻塞</code>**。</li>
<li>我不知道理解的有没有问题。。。知乎上搜了很多，大概也是这么个意思。</li>
</ul>
</li>
<li><p>死循环对js的项目会有什么影响？</p>
<ul>
<li>Node.js 中执行 js 代码的过程是单线程的. 只有当前代码都执行完, 才会切入事件循环, 然后从事件队列中 pop 出下一个回调函数开始执行代码。</li>
<li>所以死循环就会让服务器停止所有响应，如果死循环里面有其他操作可能就会栈溢出或者内存溢出直接挂掉。</li>
</ul>
</li>
<li><p>一个简单的sleep函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>(), expire = start + ms;</span><br><span class="line">  <span class="keyword">while</span> (<span class="title class_">Date</span>.<span class="title function_">now</span>() &lt; expire) ;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>如何实现一个异步的 reduce?</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">getPromise</span> = (<span class="params">key</span>) =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reduce item:&#x27;</span>, key ** <span class="number">2</span>)</span><br><span class="line">            <span class="title function_">resolve</span>(key ** <span class="number">2</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reduce start&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reduce result:&#x27;</span>, <span class="keyword">await</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="title function_">reduce</span>(<span class="function">(<span class="params">result, cursor</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> <span class="title function_">result</span>() + <span class="keyword">await</span> <span class="title function_">getPromise</span>(cursor)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">async</span> () =&gt; <span class="number">0</span>)())</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reduce end&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event-loop"></a>Event-loop</h3><p>​    <a href="https://cnodejs.org/topic/5a9108d78d6e16e56bb80882"><strong>不要混淆nodejs和浏览器中的event loop</strong></a>是我在cnode论坛上看到的一篇有关时间循环的文章。而且这个东西只要你搞清楚下面那几个异步调用的执行顺序，更深的东西也没必要花时间去研究，意义不大。。</p>
<ul>
<li><p>timers：执行<code>setTimeout()</code> 和 <code>setInterval()</code>中到期的callback。</p>
</li>
<li><p>I/O callbacks：上一轮循环中有少数的I/Ocallback会被延迟到这一轮的这一阶段执行</p>
</li>
<li><p>idle, prepare：仅内部使用</p>
</li>
<li><p>poll：最为重要的阶段，执行I/O callback，在适当的条件下会阻塞在这个阶段</p>
</li>
<li><p>check：执行<code>setImmediate</code>的callback</p>
</li>
<li><p>close callbacks：执行close事件的callback，例如<code>socket.on(&quot;close&quot;,func)</code></p>
</li>
<li><p><strong>补充说明：<code>process.nextTick()</code>在每个阶段结束都会执行。如果你仅仅是想产生一个异步调用，建议使用<code>setImmediate。</code></strong> </p>
</li>
</ul>
<blockquote>
<p>看懂下面这段的输出就大概知道执行顺序了，另外<a href="https://zhuanlan.zhihu.com/p/25407758">知乎的这篇文章也可以帮你理解</a>。</p>
<p>我们分析一下：</p>
<ol>
<li>setTimeout 和 setInterval  是回调执行是在  Timers阶段，setImmediate 回调执行是在 check 阶段，并且他们都会被放到下一轮执行，所以肯定是后三个输出，并且 setImmediate 在最后。</li>
<li>Promise.then 和 process.nextTick，点击上面那个《不要混淆nodejs和浏览器中的event loop》，根据大佬分析可知， process.nextTick是在每一个阶段结尾都会执行，并且在结尾调用了<code>      runMicrotasks();//microtasks将会在此时执行，例如Promise</code> ，所以Promise.then是在process.nextTick后面一丢丢执行。</li>
<li>setTimeout 和 setInterval 执行顺序取决于谁先被放进回调队列。这样输出结果就完全解释的通了。</li>
</ol>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;interval&#x27;</span>)</span><br><span class="line">	<span class="built_in">clearInterval</span>(interval)</span><br><span class="line">&#125;, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;immediate&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick&#x27;</span>) &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promiseFun = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="title function_">resolve</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promiseFun</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise&#x27;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入顺序如下</span></span><br><span class="line">nextTick</span><br><span class="line">promise</span><br><span class="line">timeout</span><br><span class="line">interval</span><br><span class="line">immediate</span><br></pre></td></tr></table></figure>



<h3 id="并行-并发"><a href="#并行-并发" class="headerlink" title="并行/并发"></a>并行/并发</h3><p>​    转一张图，其实这里大部分东西都是根据eleme那个大佬发的内容整理的，最后我会把引用的文章或帖子尽量都贴出来。</p>
<p><img src="https://camo.githubusercontent.com/a986e69f6ef3236fda5fb7e0e0e9b5cb1133f6ba/687474703a2f2f6a6f6561726d732e6769746875622e696f2f696d616765732f636f6e5f616e645f7061722e6a7067"></p>
<ul>
<li><p>什么是并发： 两个人用一个咖啡机。</p>
</li>
<li><p>什么是并行：两队人用两个咖啡机。</p>
</li>
<li><p>node中的并发： </p>
<ul>
<li>Node.js 通过事件循环来挨个抽取事件队列中的一个个 Task 执行, 从而避免了传统的多线程情况下 <code>2个队列对应 1个咖啡机</code> 的时候上下文切换以及资源争抢/同步的问题。</li>
<li>node的大并发只是拿到请求就扔进队列而已，并不是自己处理能力有多厉害，所以说适合I/O密集型业务，CPU密集型业务的话需要一定的优化(算法，c++扩展)并且没有那么擅长把。。</li>
</ul>
</li>
<li><p>node的并行： 通过 <code>cluster</code> 来添加一个咖啡机。</p>
</li>
</ul>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><blockquote>
<p>了解进程前，先看看<a href="https://mp.weixin.qq.com/s?__biz=MzIyNDU2NTc5Mw==&mid=2247483699&idx=1&sn=a64b349baa8662c27ac211de130eb28b&chksm=e80c4e7ddf7bc76b7869f74605588a6bd3f6a960d9cb19b1a9c4e3518156092c9fc25bf74d54&scene=21#wechat_redirect">进程和线程的区别</a></p>
</blockquote>
<h3 id="process"><a href="#process" class="headerlink" title="process"></a><a href="http://nodejs.cn/api/process.html#process_process">process</a></h3><ul>
<li><p>前文提到的process.nextTick也是process的一个方法，那么递归调用呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick&#x27;</span>);</span><br><span class="line">  process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="title function_">test</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会不停的输出nextTick,因为这样永远跳不出本轮循环。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">test</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也会不停的输出timeout，但是不会阻塞其它异步回调，因为总是插入到下一次循环。</span></span><br></pre></td></tr></table></figure></li>
<li><p>进程的当前工作目录是什么? 有什么作用?</p>
<ul>
<li>当前进程启动的目录, 通过<code>process.cwd()</code>获取当前工作目录 (current working directory), 通常是命令行启动的时候所在的目录 (也可以在启动时指定), 文件操作等使用相对路径的时候会相对当前工作目录来获取文件.</li>
</ul>
</li>
</ul>
<h3 id="标准流"><a href="#标准流" class="headerlink" title="标准流"></a>标准流</h3><p>​    <code>process.stderr</code>, <code>process.stdout</code> 以及 <code>process.stdin</code> 三个标准流</p>
<ul>
<li><p><code>console.log</code> 是同步还是异步? </p>
<ul>
<li><code>console.log</code>同步还是异步要取决于操作系统。详见<a href="http://nodejs.cn/api/process.html#process_a_note_on_process_i_o">进程 I/O 的注意事项</a></li>
</ul>
</li>
<li><p>如何实现一个 console.log?可以参见<a href="https://zhuanlan.zhihu.com/p/79562970">Console 模块解读及简单实现</a></p>
<ul>
<li>其实核心的话就是这句<code>    process.stdout.**write**(params);</code>。。</li>
</ul>
</li>
</ul>
<h3 id="Child-Process"><a href="#Child-Process" class="headerlink" title="Child Process"></a>Child Process</h3><ul>
<li><p>spawn() 启动一个子进程来执行命令</p>
<ul>
<li>options.detached 父进程死后是否允许子进程存活</li>
<li>options.stdio 指定子进程的三个标准流</li>
</ul>
</li>
<li><p>spawnSync() 同步版的 spawn, 可指定超时, 返回的对象可获得子进程的情况</p>
</li>
<li><p>exec() 启动一个子进程来执行命令, 带回调参数获知子进程的情况, 可指定进程运行的超时时间</p>
</li>
<li><p>execSync() 同步版的 exec(), 可指定超时, 返回子进程的输出 (stdout)</p>
</li>
<li><p>execFile() 启动一个子进程来执行一个可执行文件, 可指定进程运行的超时时间</p>
</li>
<li><p>execFileSync() 同步版的 execFile(), 返回子进程的输出, 如何超时或者 exit code 不为 0, 会直接 throw Error</p>
</li>
<li><p>fork() 加强版的 spawn(), 返回值是 ChildProcess 对象可以与子进程交互</p>
</li>
<li><p>child_process.fork 与 POSIX 的 fork 有什么区别?</p>
<ul>
<li>Node.js 的 <code>child_process.fork()</code> 在 Unix 上的实现最终调用了 POSIX <a href="http://man7.org/linux/man-pages/man2/fork.2.html">fork(2)</a>, 而 POSIX 的 fork 需要手动管理子进程的资源释放 (waitpid), child_process.fork 则不用关心这个问题, Node.js 会自动释放, 并且可以在 option 中选择父进程死后是否允许子进程存活。</li>
</ul>
</li>
<li><p><code>child.kill</code> 与 <code>child.send</code> 的区别?</p>
<ul>
<li>前者基于信号系统，后者基于IPC通道。</li>
</ul>
</li>
<li><p>父进程或子进程的死亡是否会影响对方? 什么是孤儿进程?</p>
<ul>
<li>子进程死亡不会影响父进程, 不过子进程死亡时（线程组的最后一个线程，通常是“领头”线程死亡时），会向它的父进程发送死亡信号. 反之父进程死亡, 一般情况下子进程也会随之死亡, 但如果此时子进程处于可运行态、僵死状态等等的话, 子进程将被<code>进程1</code>（init 进程）收养，从而成为孤儿进程. 另外, 子进程死亡的时候（处于“终止状态”），父进程没有及时调用 <code>wait()</code> 或 <code>waitpid()</code> 来返回死亡进程的相关信息，此时子进程还有一个 <code>PCB</code> 残留在进程表中，被称作僵尸进程。</li>
</ul>
</li>
</ul>
<h3 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a><a href="http://nodejs.cn/api/cluster.html#cluster_cluster">Cluster</a></h3><ul>
<li>worker 进程是由 child_process.fork() 方法创建的, 所以可以通过 IPC 在主进程和子进程之间相互传递服务器句柄。</li>
<li>cluster 模块提供了两种分发连接的方式。<ul>
<li>第一种方式 (默认方式, 不适用于 windows), 通过时间片轮转法（round-robin）分发连接. 主进程监听端口, 接收到新连接之后, 通过时间片轮转法来决定将接收到的客户端的 socket 句柄传递给指定的 worker 处理. 至于每个连接由哪个 worker 来处理, 完全由内置的循环算法决定</li>
<li>第二种方式是由主进程创建 socket 监听端口后, 将 socket 句柄直接分发给相应的 worker, 然后当连接进来时, 就直接由相应的 worker 来接收连接并处理</li>
<li>使用第二种方式时理论上性能应该较高, 然后时间上存在负载不均衡的问题, 比如通常 70% 的连接仅被 8 个进程中的 2 个处理, 而其他进程比较清闲</li>
</ul>
</li>
</ul>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>​    IPC (Inter-process communication) 进程间通信技术. 常见的进程间通信技术列表如下:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>无连接</th>
<th>可靠</th>
<th>流控制</th>
<th>优先级</th>
</tr>
</thead>
<tbody><tr>
<td>普通PIPE</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>命名PIPE</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>消息队列</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>信号量</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>共享存储</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>UNIX流SOCKET</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>UNIX数据包SOCKET</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
</tbody></table>
<blockquote>
<p>在 IPC 通道建立之前, 父进程与子进程是怎么通信的? 如果没有通信, 那 IPC 是怎么建立的?</p>
</blockquote>
<p>​    在通过 child_process 建立子进程的时候, 是可以指定子进程的 env (环境变量) 的. 所以 Node.js 在启动子进程的时候, 主进程先建立 IPC 频道, 然后将 IPC 频道的 fd (文件描述符) 通过环境变量 (<code>NODE_CHANNEL_FD</code>) 的方式传递给子进程, 然后子进程通过 fd 连上 IPC 与父进程建立连接</p>
<blockquote>
<p>什么是 IPC 通信，如何建立 IPC 通信？什么场景下需要用到 IPC 通信？</p>
</blockquote>
<p>​    IPC (Inter-process communication) ，即进程间通信技术，由于每个进程创建之后都有自己的独立地址空间，实现 IPC 的目的就是为了进程之间资源共享访问。实现 IPC 的方式有多种：管道、消息队列、信号量、Domain Socket，Node.js 通过 pipe 来实现。</p>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><blockquote>
<p>什么是守护进程？</p>
</blockquote>
<p>​    简单说就是不会因为用户退出终端而停止运行的进程。</p>
<blockquote>
<p>pm2就是一个以守护进程启动nodejs应用的工具，<a href="https://cnodejs.org/topic/57adfadf476898b472247eac">如何编写一个守护进程?</a></p>
</blockquote>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><h4 id="什么是Buffer"><a href="#什么是Buffer" class="headerlink" title="什么是Buffer?"></a>什么是Buffer?</h4><ul>
<li>Buffer 是 Node.js 中用于处理二进制数据的类。</li>
<li>Buffer类的实例非常类似整数数组，但Buffer实例创建之后其<code>大小是固定不变的</code>。</li>
</ul>
<h4 id="Buffer支持的字符编码？"><a href="#Buffer支持的字符编码？" class="headerlink" title="Buffer支持的字符编码？"></a>Buffer支持的字符编码？</h4><ul>
<li><strong>ascii</strong> - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。</li>
<li><strong>utf8</strong> - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。</li>
<li><strong>utf16le</strong> - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。</li>
<li><strong>ucs2</strong> - <strong>utf16le</strong> 的别名。</li>
<li><strong>base64</strong> - Base64 编码。</li>
<li><strong>latin1</strong> - 一种把 <strong>Buffer</strong> 编码成一字节编码的字符串的方式。</li>
<li><strong>binary</strong> - <strong>latin1</strong> 的别名。</li>
<li><strong>hex</strong> - 将每个字节编码为两个十六进制字符。</li>
</ul>
<h4 id="创建Buffer实例的方法？"><a href="#创建Buffer实例的方法？" class="headerlink" title="创建Buffer实例的方法？"></a>创建Buffer实例的方法？</h4><ul>
<li><p><strong>Buffer.alloc(size[, fill[, encoding]])：</strong> 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0</p>
</li>
<li><p><strong>Buffer.allocUnsafe(size)：</strong> 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据</p>
</li>
<li><p><strong>Buffer.allocUnsafeSlow(size)</strong></p>
</li>
<li><p><strong>Buffer.from(array)：</strong> 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）</p>
</li>
<li><p><strong>Buffer.from(arrayBuffer[, byteOffset[, length]])：</strong> 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。</p>
</li>
<li><p><strong>Buffer.from(buffer)：</strong> 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例</p>
</li>
<li><p><strong>Buffer.from(string[, encoding])：</strong> 返回一个被 string 的值初始化的新的 Buffer 实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf1 = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">10</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf1); <span class="comment">// &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</span></span><br><span class="line"><span class="keyword">const</span> buf2 = <span class="title class_">Buffer</span>.<span class="title function_">allocUnsafe</span>(<span class="number">10</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf2) <span class="comment">// &lt;Buffer 4c 46 80 05 01 00 00 00 4c 46&gt;</span></span><br><span class="line"><span class="keyword">const</span> buf3 = <span class="title class_">Buffer</span>.<span class="title function_">allocUnsafe</span>(<span class="number">10</span>).<span class="title function_">fill</span>(<span class="number">0</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf3); <span class="comment">// &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Buffer常用操作？"><a href="#Buffer常用操作？" class="headerlink" title="Buffer常用操作？"></a><a href="https://www.runoob.com/nodejs/nodejs-buffer.html">Buffer常用操作</a>？</h4><ul>
<li><p>写入缓冲区<code>buf.write(string[, offset[, length]][, encoding])</code></p>
</li>
<li><p>从缓冲区读取数据 <code>buf.toString([encoding[, start[, end]]])</code></p>
</li>
<li><p>将 Buffer 转换为 JSON 对象 <code>buf.toJSON()</code></p>
</li>
<li><p>缓冲区合并 <code>Buffer.concat(list[, totalLength])</code></p>
</li>
<li><p>缓冲区比较 <code>buf.compare(otherBuffer);</code></p>
<ul>
<li>返回值小于 0 。<code>buf</code>在<code>otherBuffer</code>之前</li>
<li>返回值等于 0 。<code>buf</code>和<code>otherBuffer</code>相同</li>
<li>返回值大于 0 。<code>buf</code>在<code>otherBuffer</code>之后</li>
</ul>
</li>
<li><p>拷贝缓冲区<code>buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</code></p>
<ul>
<li>把 buf9插入到buf10的第三位。  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf9 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;zmaaaassss&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> buf10 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;ruomu&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf9) <span class="comment">// &lt;Buffer 7a 6d 61 61 61 61 73 73 73 73&gt;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf10) <span class="comment">// &lt;Buffer 72 75 6f 6d 75&gt;</span></span><br><span class="line">buf9.<span class="title function_">copy</span>(buf10,<span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf10); <span class="comment">// &lt;Buffer 72 75 6f 7a 6d&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="String-Decoder"><a href="#String-Decoder" class="headerlink" title="String Decoder"></a><a href="http://nodejs.cn/api/string_decoder.html#string_decoder_string_decoder">String Decoder</a></h3><p>​    字符串解码器 (String Decoder) 是一个用于将 Buffer 拿来 decode 到 string 的模块, 是作为 Buffer.toString 的一个补充, 它支持多字节 UTF-8 和 UTF-16 字符。</p>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a><a href="http://nodejs.cn/api/stream.html#stream_stream">Stream</a></h3><h4 id="流的类型"><a href="#流的类型" class="headerlink" title="流的类型"></a>流的类型</h4><ul>
<li><a href="http://nodejs.cn/s/9JUnJ8"><code>Writable</code></a> - 可写入数据的流（例如 <a href="http://nodejs.cn/s/VdSJQa"><code>fs.createWriteStream()</code></a>）。</li>
<li><a href="http://nodejs.cn/s/YuDKX1"><code>Readable</code></a> - 可读取数据的流（例如 <a href="http://nodejs.cn/s/wiVPXD"><code>fs.createReadStream()</code></a>）。</li>
<li><a href="http://nodejs.cn/s/2iRabr"><code>Duplex</code></a> - 可读又可写的流（例如 <a href="http://nodejs.cn/s/wsJ1o1"><code>net.Socket</code></a>）。</li>
<li><a href="http://nodejs.cn/s/fhVJQM"><code>Transform</code></a> - 在读写过程中可以修改或转换数据的 <code>Duplex</code> 流（例如 <a href="http://nodejs.cn/s/n6ED45"><code>zlib.createDeflate()</code></a>）。</li>
</ul>
<h2 id="Netword"><a href="#Netword" class="headerlink" title="Netword"></a>Netword</h2><h3 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h3><p>可以参见网上流传比较广的一个例子, 连续调用两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下几种常见的情况:</p>
<ul>
<li>A. 先接收到 data1, 然后接收到 data2 .</li>
<li>B. 先接收到 data1 的部分数据, 然后接收到 data1 余下的部分以及 data2 的全部.</li>
<li>C. 先接收到了 data1 的全部数据和 data2 的部分数据, 然后接收到了 data2 的余下的数据.</li>
<li>D. 一次性接收到了 data1 和 data2 的全部数据.</li>
</ul>
<p>其中的 BCD 就是我们常见的粘包的情况. 而对于处理粘包的问题, 常见的解决方案有:</p>
<ul>
<li>多次发送之前间隔一个等待时间<ul>
<li>只需要等上一段时间再进行下一次 send 就好, 适用于交互频率特别低的场景. 缺点也很明显, 对于比较频繁的场景而言传输效率实在太低. 不过几乎不用做什么处理。</li>
</ul>
</li>
<li>关闭 Nagle 算法<ul>
<li>关闭 Nagle 算法, 在 Node.js 中你可以通过 <a href="https://nodejs.org/dist/latest-v6.x/docs/api/net.html#net_socket_setnodelay_nodelay"><code>socket.setNoDelay()</code></a> 方法来关闭 Nagle 算法, 让每一次 send 都不缓冲直接发送。该方法比较适用于每次发送的数据都比较大 (但不是文件那么大), 并且频率不是特别高的场景. 如果是每次发送的数据量比较小, 并且频率特别高的, 关闭 Nagle 纯属自废武功。</li>
</ul>
</li>
<li>进行封包/拆包<ul>
<li>封包/拆包是目前业内常见的解决方案了. 即给每个数据包在发送之前, 于其前/后放一些有特征的数据, 然后收到数据的时候根据特征数据分割出来各个数据包。</li>
</ul>
</li>
</ul>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><table>
<thead>
<tr>
<th>协议</th>
<th>连接性</th>
<th>双工性</th>
<th>可靠性</th>
<th>有序性</th>
<th>有界性</th>
<th>拥塞控制</th>
<th>传输速度</th>
<th>量级</th>
<th>头部大小</th>
</tr>
</thead>
<tbody><tr>
<td>TCP</td>
<td>面向连接 (Connection oriented)</td>
<td>全双工(1:1)</td>
<td>可靠 (重传机制)</td>
<td>有序 (通过SYN排序)</td>
<td>无, 有粘包情况</td>
<td>有</td>
<td>慢</td>
<td>低</td>
<td>20~60字节</td>
</tr>
<tr>
<td>UDP</td>
<td>无连接 (Connection less)</td>
<td>n:m</td>
<td>不可靠 (丢包后数据丢失)</td>
<td>无序</td>
<td>有消息边界, <strong>无粘包</strong></td>
<td>无</td>
<td>快</td>
<td>高</td>
<td>8字节</td>
</tr>
</tbody></table>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul>
<li>GET 和 POST 有什么区别?<ul>
<li>只有语义上的区别，你可以不遵守。</li>
<li>GET产生一个TCP数据包；POST产生两个TCP数据包。但是有些浏览器POST只发一个数据包。</li>
</ul>
</li>
<li>POST 和 PUT 有什么区别?<ul>
<li>POST 是新建 (create) 资源, 非幂等, 同一个请求如果重复 POST 会新建多个资源。</li>
<li>PUT 是 Update/Replace, 幂等, 同一个 PUT 请求重复操作会得到同样的结果。</li>
</ul>
</li>
</ul>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><ul>
<li><p>DNS 模块中 .lookup 与 .resolve 的区别?</p>
<ul>
<li><table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
<th>同步</th>
<th>网络请求</th>
<th>速度</th>
</tr>
</thead>
<tbody><tr>
<td>.lookup(hostname[, options], cb)</td>
<td>通过系统自带的 DNS 缓存 (如 <code>/etc/hosts</code>)</td>
<td>同步</td>
<td>无</td>
<td>快</td>
</tr>
<tr>
<td>.resolve(hostname[, rrtype], cb)</td>
<td>通过系统配置的 DNS 服务器指定的记录 (rrtype指定)</td>
<td>异步</td>
<td>有</td>
<td>慢</td>
</tr>
</tbody></table>
</li>
<li><p>当你要解析一个域名的 ip 时, 通过 .lookup 查询直接调用 <code>getaddrinfo</code> 来拿取地址, 速度很快, 但是如果本地的 hosts 文件被修改了, .lookup 就会拿 hosts 文件中的地方, 而 .resolve 依旧是外部正常的地址。</p>
</li>
</ul>
</li>
<li><p>hosts 文件是什么? 什么叫 DNS 本地解析?</p>
<ul>
<li>hosts 文件是个没有扩展名的系统文件, 其作用就是将网址域名与其对应的 IP 地址建立一个关联“数据库”, 当用户在浏览器中输入一个需要登录的网址时, 系统会首先自动从 hosts 文件中寻找对应的IP地址。</li>
</ul>
</li>
</ul>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>​    RPC (Remote Procedure Call Protocol) 基于 TCP/IP 来实现调用远程服务器的方法, 与 http 同属应用层. 常用于构建集群, 以及微服务 </p>
<h4 id="常见的RPC方式"><a href="#常见的RPC方式" class="headerlink" title="常见的RPC方式"></a>常见的RPC方式</h4><ul>
<li>Thrift<ul>
<li><strong>Thrift</strong>是一种由FaceBook为“大规模跨语言服务”开发的接口描述语言](<a href="https://zh.wikipedia.org/wiki/%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80)%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E3%80%82">https://zh.wikipedia.org/wiki/接口描述语言)和二进制通讯协议。</a></li>
</ul>
</li>
<li>HTTP<ul>
<li>使用 HTTP 协议来进行 RPC 调用也是很常见的, 相比 TCP 连接, 通过通过 HTTP 的方式性能会差一些, 但是在使用以及调试上会简单一些. 近期比较有名的框架参见 <a href="http://www.grpc.io/">gRPC</a>。</li>
</ul>
</li>
<li>MQ<ul>
<li>使用消息队列 (Message Queue) 来进行 RPC 调用 (RPC over mq) 在业内有不少例子, 比较适合业务解耦/广播/限流等场景.</li>
</ul>
</li>
</ul>
<h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><h3 id="TTY"><a href="#TTY" class="headerlink" title="TTY"></a>TTY</h3><p>​    “tty” 原意是指 “teletype” 即打字机, “pty” 则是 “pseudo-teletype” 即伪打字机. 在 Unix 中, <code>/dev/tty*</code> 是指任何表现的像打字机的设备, 例如终端 (terminal)。</p>
<ul>
<li><p>使用w命令可以看到当前登录的用户情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">USER     TTY      FROM              LOGIN@  IDLE WHAT</span><br><span class="line">zhangming console  -                27 420  13days -</span><br><span class="line">zhangming s002     -                日17       - -zsh</span><br><span class="line">zhangming s003     -                14:35       - w</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="OS模块"><a href="#OS模块" class="headerlink" title="OS模块"></a>OS模块</h3><table>
<thead>
<tr>
<th>os.EOL</th>
<th>根据当前系统, 返回当前系统的 <code>End Of Line</code></th>
</tr>
</thead>
<tbody><tr>
<td>os.arch()</td>
<td>返回当前系统的 CPU 架构, 如 <code>&#39;x86&#39;</code> 和 <code>&#39;x64&#39;</code></td>
</tr>
<tr>
<td>os.constants</td>
<td>返回系统常量</td>
</tr>
<tr>
<td>os.cpus()</td>
<td>返回 CPU 每个核的信息</td>
</tr>
<tr>
<td>os.endianness()</td>
<td>返回 CPU 字节序, 如果是大端字节序返回 <code>BE</code>, 小端字节序则 <code>LE</code></td>
</tr>
<tr>
<td>os.freemem()</td>
<td>返回系统空闲内存的大小, 单位是字节</td>
</tr>
<tr>
<td>os.homedir()</td>
<td>返回当前用户的根目录</td>
</tr>
<tr>
<td>os.hostname()</td>
<td>返回当前系统的主机名</td>
</tr>
<tr>
<td>os.loadavg()</td>
<td>返回负载信息</td>
</tr>
<tr>
<td>os.networkInterfaces()</td>
<td>返回网卡信息 (类似 <code>ifconfig</code>)</td>
</tr>
<tr>
<td>os.platform()</td>
<td>返回编译时指定的平台信息, 如 <code>win32</code>, <code>linux</code>, 同 <code>process.platform()</code></td>
</tr>
<tr>
<td>os.release()</td>
<td>返回操作系统的分发版本号</td>
</tr>
<tr>
<td>os.tmpdir()</td>
<td>返回系统默认的临时文件夹</td>
</tr>
<tr>
<td>os.totalmem()</td>
<td>返回总内存大小(同内存条大小)</td>
</tr>
<tr>
<td>os.type()</td>
<td>根据 <code>[uname](https://en.wikipedia.org/wiki/Uname#Examples)</code> 返回系统的名称</td>
</tr>
<tr>
<td>os.uptime()</td>
<td>返回系统的运行时间，单位是秒</td>
</tr>
<tr>
<td>os.userInfo([options])</td>
<td>返回当前用户信息</td>
</tr>
</tbody></table>
<blockquote>
<p> 不同系统的换行符（EOL）的区别</p>
</blockquote>
<table>
<thead>
<tr>
<th>符号</th>
<th>系统</th>
</tr>
</thead>
<tbody><tr>
<td>LF（\n）</td>
<td>在 Unix 或 Unix 相容系统 (GNU/Linux, AIX, Xenix, Mac OS X, …)、BeOS、Amiga、RISC OS</td>
</tr>
<tr>
<td>CR+LF</td>
<td>MS-DOS、微软视窗操作系统 (Microsoft Windows)、大部分非 Unix 的系统</td>
</tr>
<tr>
<td>CR  (\r)</td>
<td>Apple II 家族, Mac OS 至版本9</td>
</tr>
</tbody></table>
<h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><p>​    Node.js 内置的 path 是用于处理路径问题的模块. 不过众所周知, 路径在不同操作系统下又不可调和的差异。所以不要自己随便拼接路径，要使用<code>Path.join()</code>或者<code>Path.resolve()</code>。</p>
<table>
<thead>
<tr>
<th>POSIX</th>
<th>值</th>
<th>Windows</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>path.posix.sep</td>
<td><code>&#39;/&#39;</code></td>
<td>path.win32.sep</td>
<td><code>&#39;\\&#39;</code></td>
</tr>
<tr>
<td>path.posix.normalize(‘/foo/bar//baz/asdf/quux/..’)</td>
<td><code>&#39;/foo/bar/baz/asdf&#39;</code></td>
<td>path.win32.normalize(‘C:\temp\foo\bar..&#39;)</td>
<td><code>&#39;C:\\temp\\foo\\&#39;</code></td>
</tr>
<tr>
<td>path.posix.basename(‘/tmp/myfile.html’)</td>
<td><code>&#39;myfile.html&#39;</code></td>
<td>path.win32.basename(‘C:\temp\myfile.html’)</td>
<td><code>&#39;myfile.html&#39;</code></td>
</tr>
<tr>
<td>path.posix.join(‘/asdf’, ‘/test.html’)</td>
<td><code>&#39;/asdf/test.html&#39;</code></td>
<td>path.win32.join(‘/asdf’, ‘/test.html’)</td>
<td><code>&#39;\\asdf\\test.html&#39;</code></td>
</tr>
<tr>
<td>path.posix.relative(‘/root/a’, ‘/root/b’)</td>
<td><code>&#39;../b&#39;</code></td>
<td>path.win32.relative(‘C:\a’, ‘c:\b’)</td>
<td><code>&#39;..\\b&#39;</code></td>
</tr>
<tr>
<td>path.posix.isAbsolute(‘/baz/..’)</td>
<td><code>true</code></td>
<td>path.win32.isAbsolute(‘C:\foo..’)</td>
<td><code>true</code></td>
</tr>
<tr>
<td>path.posix.delimiter</td>
<td><code>&#39;:&#39;</code></td>
<td>path.win32.delimiter</td>
<td><code>&#39;,&#39;</code></td>
</tr>
<tr>
<td>process.env.PATH</td>
<td><code>&#39;/usr/bin:/bin&#39;</code></td>
<td>process.env.PATH</td>
<td><code>C:\Windows\system32;C:\Program Files\node\&#39;</code></td>
</tr>
<tr>
<td>PATH.split(path.posix.delimiter)</td>
<td><code>[&#39;/usr/bin&#39;, &#39;/bin&#39;]</code></td>
<td>PATH.split(path.win32.delimiter)</td>
<td><code>[&#39;C:\\Windows\\system32&#39;, &#39;C:\\Program Files\\node\\&#39;]</code></td>
</tr>
</tbody></table>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><table>
<thead>
<tr>
<th>环境变量</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td><code>NODE_DEBUG=module[,…]</code></td>
<td>指定要打印调试信息的核心模块列表</td>
</tr>
<tr>
<td><code>NODE_PATH=path[:…]</code></td>
<td>指定搜索目录模块路径的前缀列表</td>
</tr>
<tr>
<td><code>NODE_DISABLE_COLORS=1</code></td>
<td>关闭 REPL 的颜色显示</td>
</tr>
<tr>
<td><code>NODE_ICU_DATA=file</code></td>
<td>ICU (Intl object) 数据路径</td>
</tr>
<tr>
<td><code>NODE_REPL_HISTORY=file</code></td>
<td>持久化存储REPL历史文件的路径</td>
</tr>
<tr>
<td><code>NODE_TTY_UNSAFE_ASYNC=1</code></td>
<td>设置为1时, 将同步操作 stdio (如 console.log 变成同步)</td>
</tr>
<tr>
<td><code>NODE_EXTRA_CA_CERTS=file</code></td>
<td>指定 CA (如 VeriSign) 的额外证书路径</td>
</tr>
</tbody></table>
<h3 id="负载"><a href="#负载" class="headerlink" title="负载"></a>负载</h3><p>​    负载是衡量服务器运行状态的一个重要概念. 通过负载情况, 我们可以知道服务器目前状态是清闲, 良好, 繁忙还是即将 crash。</p>
<p>​    PM2管理node进程，<a href="https://wohugb.gitbooks.io/pm2/content/features/quick-start.html">pm2入门</a></p>
<h2 id="错误处理-调试"><a href="#错误处理-调试" class="headerlink" title="错误处理/调试"></a><a href="https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md">错误处理/调试</a></h2><h3 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h3><blockquote>
<p>在 Node.js 中的错误主要有一下四种类型：</p>
</blockquote>
<table>
<thead>
<tr>
<th>错误</th>
<th>名称</th>
<th>触发</th>
</tr>
</thead>
<tbody><tr>
<td>Standard JavaScript errors</td>
<td>标准 JavaScript 错误</td>
<td>由错误代码触发</td>
</tr>
<tr>
<td>System errors</td>
<td>系统错误</td>
<td>由操作系统触发</td>
</tr>
<tr>
<td>User-specified errors</td>
<td>用户自定义错误</td>
<td>通过 throw 抛出</td>
</tr>
<tr>
<td>Assertion errors</td>
<td>断言错误</td>
<td>由 <code>assert</code> 模块触发</td>
</tr>
</tbody></table>
<blockquote>
<p>其中标准的 JavaScript 错误常见有：</p>
</blockquote>
<ul>
<li>EvalError: 调用 eval() 出现错误时抛出该错误</li>
<li>SyntaxError: 代码不符合 JavaScript 语法规范时抛出该错误</li>
<li>RangeError: 数组越界时抛出该错误</li>
<li>ReferenceError: 引用未定义的变量时抛出该错误</li>
<li>TypeError: 参数类型错误时抛出该错误</li>
<li>URIError: 误用全局的 URI 处理函数时抛出该错误</li>
</ul>
<blockquote>
<p>在 Node.js 中错误处理主要有一下几种方法:</p>
</blockquote>
<ul>
<li><p>callback(err, data) 回调约定</p>
</li>
<li><p>throw / try / catch</p>
</li>
<li><p>EventEmitter 的 error 事件</p>
</li>
</ul>
<p>​    <a href="https://github.com/joyent/node-verror">vError模块</a>让 Error 一层层封装, 并在每一层将错误的信息一层层的包上, 最后拿到的 Error 直接可以从 message 中获取用于定位问题的关键信息.</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><h4 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h4><p>​    黑盒测试 (Black-box Testing), 测试应用程序的功能, 而不是其内部结构或运作. 测试者不需了解代码、内部结构等, 只需知道什么是应用应该做的事, 即当键入特定的输入, 可得到一定的输出. 测试者通过选择<code>有效输入</code>和<code>无效输入</code>来验证是否正确的输出. 此测试方法可适合大部分的软件测试, 例如集成测试 (Integration Testing) 以及系统测试 (System Testing)。</p>
<h4 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h4><p>​    白盒测试 (White-box Testing) 测试应用程序的内部结构或运作, 而不是测试应用程序的功能 (即黑盒测试). 在白盒测试时,以编程语言的角度来设计测试案例. 白盒测试可以应用于单元测试 (Unit Testing)、集成测试 (Integration Testing) 和系统的软件测试流程, 可测试在集成过程中每一单元之间的路径, 或者主系统跟子系统中的测试。</p>
<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>​    单元测试 (Unit Testing) 是白盒测试的一种, 用于针对程序模块进行正确性检验的测试工作. 单元 (Unit) 是指<strong>最小可测试的部件</strong>. 在过程化编程中, 一个单元就是单个程序、函数、过程等; 对于面向对象编程, 最小单元就是方法, 包括基类、抽象类、或者子类中的方法。</p>
<h4 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h4><p>覆盖率通常由四个维度贡献:</p>
<ul>
<li><p>行覆盖率 (line coverage) 是否每一行都执行了？</p>
</li>
<li><p>函数覆盖率 (function coverage) 是否每个函数都调用了？</p>
</li>
<li><p>分支覆盖率 (branch coverage) 是否每个if代码块都执行了？</p>
</li>
<li><p>语句覆盖率 (statement coverage) 是否每个语句都执行了？</p>
</li>
</ul>
<p>常用的测试覆盖率框架 <a href="https://www.ruanyifeng.com/blog/2015/06/istanbul.html">istanbul</a></p>
<h4 id="常见测试工具"><a href="#常见测试工具" class="headerlink" title="常见测试工具"></a>常见测试工具</h4><ul>
<li><a href="https://github.com/mochajs/mocha">Mocha</a></li>
<li>ava</li>
<li>Jest</li>
</ul>
<h4 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h4><p>​    压力测试 (Stress testing), 是保证系统稳定性的一种测试方法. 通过预估系统所需要承载的 QPS, TPS 等指标, 然后通过如 <a href="http://jmeter.apache.org/">Jmeter</a> 等压测工具模拟相应的请求情况, 来验证当前应能能否达到目标。</p>
<h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><ul>
<li>Assert<ul>
<li>Node.js 中内置的 <code>assert</code> 模块也是属于断言模块的一种, 但是官方在文档中有注明, 该内置模块主要是用于内置代码编写时的基本断言需求, 并不是一个通用的断言库 (<strong>not intended to be used as a general purpose assertion library</strong>)</li>
</ul>
</li>
<li><a href="https://github.com/chaijs/chai">Chai</a></li>
<li><a href="https://github.com/shouldjs/should.js">should.js</a></li>
</ul>
]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>又老了一岁</title>
    <url>/2020/01/08/%E5%8F%88%E8%80%81%E4%BA%86%E4%B8%80%E5%B2%81/</url>
    <content><![CDATA[<p>2020年01月08日星期3，如往常一样上下班，下班后独自点了一份山东炒面加一份火腿鸡蛋煎饼，小撑。平时都是二选一，想着过生日，奢侈一下嘛。。</p>
<p>回家楼底下买了一个蛋糕切片，没有生日快乐的样式，所以选了个小猪佩奇。</p>
<p>本来是想发个朋友圈的，想了下没啥意思，自己的生日成为只有自己知道的秘密也挺有意思的。</p>
<p>佩奇祝我来年顺利。心想事成。</p>
<img src="/blog/images/2020/WechatIMG1.jpeg" style="zoom:25%;" />

<img src="/blog/images/2020/WechatIMG2.jpeg" style="zoom:33%;" />



]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql的processlist和explain</title>
    <url>/2019/11/17/mysql%E7%9A%84processlist%E5%92%8Cexplain/</url>
    <content><![CDATA[<h2 id="show-processlist"><a href="#show-processlist" class="headerlink" title="show processlist"></a>show processlist</h2><p>一般用到 <code>show processlist</code> 或 <code>show full processlist</code> 都是为了查看当前 mysql 是否有压力，都在跑什么语句，当前语句耗时多久了，有没有什么慢 SQL 正在执行之类的。</p>
<h6 id="每一列代表的意思"><a href="#每一列代表的意思" class="headerlink" title="每一列代表的意思"></a>每一列代表的意思</h6><ul>
<li><code>id</code>:链接mysql 服务器线程的唯一标识，可以通过kill来终止此线程的链接。</li>
<li><code>user</code>:当前线程链接数据库的用户</li>
<li><code>host</code>:显示这个语句是从哪个ip 的哪个端口上发出的。可用来追踪出问题语句的用户</li>
<li><code>db</code>:线程链接的数据库，如果没有则为null</li>
<li><code>command</code>:显示当前连接的执行的命令，一般就是休眠或空闲（sleep），查询（query），连接（connect）</li>
<li><code>time</code>：线程处在当前状态的时间，单位是秒</li>
<li><code>state</code>:显示使用当前连接的sql语句的状态，很重要的列，后续会有所有的状态的描述，请注意，state只是语句执行中的某一个状态，一个 sql语句，已查询为例，可能需要经过copying to tmp table，Sorting result，Sending data等状态才可以完成</li>
<li><code>info</code>:线程执行的sql语句，如果没有语句执行则为null。这个语句可以使客户端发来的执行语句也可以是内部执行的语句</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询非 Sleep 状态的链接，按消耗时间倒序展示，自己加条件过滤</span><br><span class="line">select id, db, user, host, command, time, state, info</span><br><span class="line">from information_schema.processlist</span><br><span class="line">where command != &#x27;Sleep&#x27;</span><br><span class="line">order by time desc </span><br></pre></td></tr></table></figure>
<h6 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询执行时间超过2分钟的线程，然后拼接成 kill 语句</span><br><span class="line">select concat(&#x27;kill &#x27;, id, &#x27;;&#x27;)</span><br><span class="line">from information_schema.processlist</span><br><span class="line">where command != &#x27;Sleep&#x27;</span><br><span class="line">and time &gt; 2*60</span><br><span class="line">order by time desc </span><br></pre></td></tr></table></figure>

<h6 id="主要的状态有"><a href="#主要的状态有" class="headerlink" title="主要的状态有"></a>主要的状态有</h6><ul>
<li><code>checking table</code>:　正在检查数据表（这是自动的）。</li>
<li><code>Closing tables</code>:　正在将表中修改的数据刷新到磁盘中，同时正在关闭已经用完的表。这是一个很快的操作，如果不是这样的话，就应该确认磁盘空间是否已经满了或者磁盘是否正处于重负中。</li>
<li><code>copyng to tmp table on disk</code>:　由于临时结果集大于tmp_table_s`ize，正在将临时表从内存存储转为磁盘存储以此节省内存。</li>
<li><code>creating tmp table</code>:　正在创建临时表以存放部分查询结果。</li>
<li><code>locked</code>:　被其他查询锁住了。</li>
<li><code>sending data</code>:　正在处理SELECT查询的记录，同时正在把结果发送给客户端。</li>
<li><code>sleeping </code>:　正在等待客户端发送新请求.。</li>
</ul>
<h2 id="explain-优化sql"><a href="#explain-优化sql" class="headerlink" title="explain 优化sql"></a>explain 优化sql</h2><h6 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h6><ul>
<li><code>explain select</code></li>
<li><code>EXPLAIN EXTENDED SELECT ....</code>  将执行计划“反编译”成SELECT语句，运行<code>SHOW WARNINGS</code> 可得到被MySQL优化器优化后的查询语句 </li>
<li><code>EXPLAIN PARTITIONS SELECT ....</code> 用于分区表的EXPLAIN</li>
</ul>
<span id="more"></span>
<h6 id="通过explain可以知道mysql是如何处理语句，分析出查询或是表结构的性能瓶颈。通过expalin可以得到："><a href="#通过explain可以知道mysql是如何处理语句，分析出查询或是表结构的性能瓶颈。通过expalin可以得到：" class="headerlink" title="通过explain可以知道mysql是如何处理语句，分析出查询或是表结构的性能瓶颈。通过expalin可以得到："></a>通过explain可以知道mysql是如何处理语句，分析出查询或是表结构的性能瓶颈。通过expalin可以得到：</h6><ul>
<li> 表的读取顺序</li>
<li>表的读取操作的操作类型</li>
<li>哪些索引可以使用</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询`</li>
</ul>
<h6 id="explain显示字段"><a href="#explain显示字段" class="headerlink" title="explain显示字段"></a>explain显示字段</h6><ul>
<li><code>id</code>:语句的执行顺序标识</li>
<li><code>select_type</code>:使用的查询类型，主要有以下几种查询类型<ul>
<li><code>simple</code>:简单类型,语句中没有子查询或union</li>
<li><code>Primary</code>:查询中若包含任何复杂的子部分，最外层查询则被标记为：PRIMARY，不是主键</li>
<li><code>union</code>:UNION之后的第二个SELECT，则被标记为UNION，第一个select 为primary </li>
<li><code>dependent subquery</code>:子查询中内层中第一个select语句</li>
<li><code>dependent union</code>:子查询中union后的select，依赖于外部的结果集。</li>
<li><code>SUBQUERY</code></li>
<li><code>devived</code>:派生表的查询语句</li>
<li><code>uncacheable subquery </code>:结果集无法缓存的子查询</li>
<li><code>union result </code>:union中合并的结果</li>
</ul>
</li>
<li><code>table</code> :显示这一步所访问的数据库中表的名称</li>
<li><code>type</code>:这列很重要,显示了连接使用了哪种类别,有无使用索引。从最好到最差的连接类型为：<ul>
<li><code>system</code>:system为const一个特例，即表中只有一条记录。</li>
<li><code>const</code>:const是在where条件以常量作为查询条件，表中最多有一条记录匹配。由于是常量，所以实际上只需要读一次。</li>
<li><code>eq_ref</code>:最多只会有一条匹配结果，一般是通过主键或是唯一索引来访问。一般会出现在连接查询的语句中。</li>
<li><code>ref</code>:非唯一性索引扫描，返回匹配某个单独值的所有行。常见于使用<strong>非唯一索引即唯一索引的非唯一前缀</strong>进行的查找</li>
<li><code>range</code>:索引范围扫描，常见于between、&lt;、&gt;、in等的查询</li>
<li><code>index</code>:全索引树被扫描Full Index Scan</li>
<li><code>all</code>:全表扫描，效果是最不理想的。</li>
</ul>
</li>
<li><code>possible_keys</code>:查询可以利用的索引，如果没有任何索引可以使用，就会显示成null，这项对内容的优化时索引的调整非常重要。</li>
<li><code>key</code>:从<strong>possible_keys</strong>中所选择使用的索引</li>
<li><code>key_len</code>:key_len列显示mysql决定使用的键长度，如果键是null，则长度为null。使用的索引长度，一般越短越好。</li>
<li><code>ref</code>:表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</li>
<li><code>rows</code>:通过系统收集到的统计信息，估计出来的结果集记录条数</li>
<li><code>extra</code>:查询中每一步实现的额外细节信息。。</li>
</ul>
<p>其实就是一些能google到的东西，之前用的不多所以没在意，现在整理一下。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>linux的0和1</title>
    <url>/2019/10/26/linux%E7%9A%840%E5%92%8C1/</url>
    <content><![CDATA[<p>很久没写博客了，因为之前写的东西够消化很久了。而且现在也不想搬运文档之类的东西，写就写点自己的东西吧。。。</p>
<p>虽然前面的博客搬运工居多，但也是一个知识的整理的过程吧。技术越来越好之后，尽量写一些自己体会过的东西。</p>
<p>而且现在又到笔记用的多，博客没什么灵感。</p>
<h2 id="linux的真与假"><a href="#linux的真与假" class="headerlink" title="linux的真与假"></a>linux的真与假</h2><p>虽然linux会一些简单的命令，但是shell脚本确实不怎么会写，所以无聊想了解一些shell的语法，然后发现在linux中，0表示真，1表示假。</p>
<p>真的是这样吗？amazing！</p>
<h5 id="看这样一个语句"><a href="#看这样一个语句" class="headerlink" title="看这样一个语句"></a>看这样一个语句</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 1 -eq 1 ]; echo $? // 0</span><br><span class="line">then echo &quot;true&quot;</span><br><span class="line">else echo &quot;false&quot;</span><br><span class="line">	fi</span><br><span class="line">// true</span><br><span class="line">if [ 1 -eq 11 ]; echo $? // 1</span><br><span class="line">then echo &quot;true&quot;</span><br><span class="line">else echo &quot;false&quot;</span><br><span class="line">	fi</span><br><span class="line">// false</span><br></pre></td></tr></table></figure>

<h5 id="在看这样一个语句"><a href="#在看这样一个语句" class="headerlink" title="在看这样一个语句"></a>在看这样一个语句</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if test 1 -eq 1; echo $? // 0</span><br><span class="line">then echo &quot;true&quot;</span><br><span class="line">else echo &quot;false&quot;</span><br><span class="line">	fi</span><br><span class="line">	// true</span><br><span class="line">	</span><br><span class="line">if test 1 -eq 11; echo $? // 1</span><br><span class="line">then echo &quot;true&quot;</span><br><span class="line">else echo &quot;false&quot;</span><br><span class="line">	fi</span><br><span class="line">	//false</span><br></pre></td></tr></table></figure>

<ul>
<li><code>[ ]</code> 和 <code>test</code> 的作用从上面的代码来看，都是做逻辑运算。。（ps：更多作用和细节下次再说吧！）</li>
<li>因为在shell中，每个表达式执行完退出的时候，都会返回一个退出状态码，上面的<code>echo $? </code>的作用是:<code>前一个命令的退出状态，可用于获取函数返回值</code></li>
<li>这样看来，当返回值为0时，进入了<code>真</code>的逻辑块。</li>
</ul>
<h5 id="那这样呢？"><a href="#那这样呢？" class="headerlink" title="那这样呢？"></a>那这样呢？</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 0 ]; echo $? //0</span><br><span class="line">	then echo &quot;true&quot;</span><br><span class="line">else echo &quot;false&quot;</span><br><span class="line">fi</span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">if [ 1 ]; echo $? //0</span><br><span class="line">	then echo &quot;true&quot;</span><br><span class="line">else echo &quot;false&quot;</span><br><span class="line">fi</span><br><span class="line">// true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>现在知道上面的语句为什么都输出了<code>true</code>了吗？</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>当 <code>0</code>和<code>1</code>作为退出码的时候确实表示真假，真实因为shell中是没有<code>while(1)</code>这种用法的。</li>
<li>所以可以理解为 0 为 真  1 为假，但是原理还是要知道的。</li>
</ul>
<p>Ps: 做web开发的时候，前后端约定 <code>&#123;code:0,message:&#39;success&#39;&#125;</code>，这时状态码0也是代表成功的意思！</p>
]]></content>
      <categories>
        <category>计算机网络与操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql之事务</title>
    <url>/2019/06/26/mysql%E4%B9%8B%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>本文于 2021年07月14日19:39:57 重新整理。。。之前写的自己都有点看不下去。</p>
<h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h4><p>简单来说，事务就是要保证一组数据的操作，要么全部成功，要么全部失败。</p>
<p>在 mysql 中，事务是由引擎实现的，比如 InnoDB 支持事务，而 MyISAM 就不支持事务。</p>
<span id="more"></span>

<h4 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h4><p>常说的 ACID 就是事务的四大特性：</p>
<ul>
<li><strong>原子性（Atomicity）</strong>：事务是一个原子操作，要么全部成功，要么全部失败。</li>
<li><strong>一致性 （Consistency）</strong>：事务要保证数据库整体数据的完整性和业务的数据的一致性，事务成功提交整体数据修改，事务错误则回滚到数据回到原来的状态。</li>
<li><strong>隔离性（Isolation）</strong>：并行执行的事务之间互不干扰，隔离开来。(这里涉及到隔离级别）</li>
<li><strong>持久性（Atomicity）</strong>：事务成功提交后，只要修改的数据都会进行持久化，不会因为异常、宕机而造成数据错误或丢失。</li>
</ul>
<h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><p>事务为什么要隔离级别呢，因为数据你<strong>隔离的越严密</strong>，那么<strong>效率</strong>就越低，所以这里需要根据业务选择，使二者有一个平衡点。</p>
<br>

<p>隔离级别：</p>
<ul>
<li>读未提交：一个事务还未提交时，它的变更就能被其它事务看到。</li>
<li>读已提交：一个事务提交后，它做的变更才会被其它事务看到。</li>
<li>可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。</li>
<li>串行化：这个是效率做低的，对同一行记录操作时，会加“读锁”或“写锁”，后访问的事务必须等前面的事务完成。</li>
</ul>
<p>这是极客时间课程里的一张图：</p>
<img src="https://static001.geekbang.org/resource/image/7d/f8/7dea45932a6b722eb069d2264d0066f8.png" alt="img" style="zoom:25%;" />

<ul>
<li>若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。</li>
<li>若隔离级别是“读已提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。</li>
<li>若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</li>
<li>若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。</li>
</ul>
<p>ps: 我觉得这个描述非常好理解了，引用自极客时间。</p>
<h4 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h4><p>InnoDB 使用 undo log 实现事务，每条记录在更新时都会同时记录一条回滚操作，通过回滚操作就可以得到前一个状态的值。</p>
<p>undo log 是一个逻辑日志，记录的是操作过程，并且是逆向的操作过程。</p>
<p>比如 你 insert.. 就会记录一个 delete… 的操作。</p>
<p>ps: 这里主要是看到之前写过一篇事务的文章，看不下去就重新整理了一点。没有深入和扩展开来。这一片就这样吧</p>
<p>参考链接：</p>
<ul>
<li>极客时间，《mysql实战45讲》</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>js之你不知道的引用传递</title>
    <url>/2019/05/22/js%E4%B9%8B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<p>之前有一篇文章<a href="%5Bhttps://ruomuc.gitee.io/blog/2018/06/26/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/%5D(https://ruomuc.gitee.io/blog/2018/06/26/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/)">深拷贝和浅拷贝</a>说明了js中传值和传引用，或者叫值传递和引用传递。</p>
<p>可能是我闲的蛋疼吧。</p>
<p>假设有这样一段代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">item</span>:<span class="literal">true</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">item</span>:<span class="literal">false</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeValue</span>(<span class="params">a,obj1,obj2</span>)&#123;</span><br><span class="line">	a = <span class="number">123</span>;</span><br><span class="line">  obj1 = &#123;<span class="attr">item</span>:<span class="literal">false</span>&#125;</span><br><span class="line">  obj2.<span class="property">item</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">changeValue</span>(a,obj1,obj2)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2)</span><br></pre></td></tr></table></figure>

<p>执行结果是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">123</span><br><span class="line">&#123;item:true&#125;</span><br><span class="line">&#123;item:true&#125;</span><br></pre></td></tr></table></figure>

<p>关于传值、传地址、传引用。我是在一片<a href="https://blog.csdn.net/zx3517288/article/details/53363798">c++的博文</a>找到的，不知道准不准确。</p>
<p>按文中说法，如果是传引用的话，没有实参的拷贝，对形参的修改必然反映到实参上，而这里没有。而传地址，只有对形参指向的对象的修改，才会影响实参，对形参本身的修改(这里的obj2修改的不是自己，而是自己指向的对象)，并不会影响实参(这里的obj1指向了另一个对象，也就是更新了变量保存的地址)。</p>
<p>所以我觉得这里因该是传地址。</p>
<p>顺便提一下，我在看java的时候，所有地方都说java只有值传递！！！</p>
<p>传地址是不是也是一种传值呢，java的非基本数据类型，栈上的变量存的也是对象在堆中的地址。</p>
<p>再贴一条我在stackoverflow上看到的讨论帖<a href="https://stackoverflow.com/questions/518000/is-javascript-a-pass-by-reference-or-pass-by-value-language">Is JavaScript a pass-by-reference or pass-by-value language?</a>，我觉得上面解释是符合这段代码的结果的。</p>
<p>欢迎来怼。。。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>关于mysql的索引</title>
    <url>/2019/05/11/%E5%85%B3%E4%BA%8Emysql%E7%9A%84%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<hr>
<p>本篇文章于2021年7月18日15:25:27。。重构之</p>
<p>主要最近在看一个 mysql 的课，然后看到之前写过索引相关的文章，看不下去了，重构之。（捂脸）</p>
<hr>
<p>什么是索引呢？简单来说，索引就像是书本的目录一样，目的是提高查询效率。</p>
<span id="more"></span>

<h2 id="索引的常见实现"><a href="#索引的常见实现" class="headerlink" title="索引的常见实现"></a>索引的常见实现</h2><p>哈希表：</p>
<ul>
<li><p>哈希表适用于等值查询的场景，是最快的 O(1)</p>
</li>
<li><p>区间查询就需要全部扫描一遍了，速度很慢 O(n)</p>
</li>
</ul>
<p>有序数组：</p>
<ul>
<li>有序数组无论是等值查询和区间查询性能都不错</li>
<li>但是新增数据的时候，有序数组要保证有序，需要把插入位置之后的数据全部后移，成本太高</li>
<li>所以，有序数组只适合用于静态存储引擎</li>
</ul>
<p>平衡二叉树：</p>
<ul>
<li>二叉搜索树是一个很常见的数据结构，它的查询操作平均复杂度为 O(lgn)，相应的平衡二叉树的平衡操作时间复杂度也是O(lgn)</li>
<li>虽然二叉搜索树的效率很高，但是层数太多了，每多一层可能都意味着一次磁盘IO操作，这样看来是很慢的</li>
<li>N 叉树，我们增加树的 “叉”，就可以减少树的深度，就可以尽量检查访问磁盘的次数</li>
</ul>
<h2 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h2><p>本文主要说的 mysql 的索引，InnoDB是 mysql 的主要引擎（虽然MyISAM也使用B+Tree作为索引结构，但是本文默认都是基于InnoDB）。</p>
<p><a href="https://zhuanlan.zhihu.com/p/54102723">b树 和 b+树，请看这篇文章</a></p>
<p>最重要的一点是，b+树的非叶子结点只做索引，叶子结点保存有全部的数据，并且只有叶子节点带有指向卫星数据的指针。</p>
<h3 id="主键索引和非主键索引"><a href="#主键索引和非主键索引" class="headerlink" title="主键索引和非主键索引"></a>主键索引和非主键索引</h3><p><strong>主键索引</strong>叶子结点的卫星数据，保存的是<strong>整行的数据</strong>。</p>
<p><strong>非主键索引</strong>叶子结点的卫星数据，保存的是<strong>主键的值</strong>。</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/dcda101051f28502bd5c4402b292e38d.png" style="zoom:25%;" />

<h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p>我们知道了主键索引和非主键索引的区别了，假设有一张表t，id是主键索引，name是非主键索引，那么请问：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">=</span> xx;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> name <span class="operator">=</span> xx;</span><br></pre></td></tr></table></figure>

<p>这两条查询有什么区别吗？哪个效率更高？</p>
<p>答案显然是第一条：</p>
<ul>
<li>第一条sql：从 id 这个索引对应的B+树上，找到 xx 这条数据，然后卫星数据已经是整行记录了，直接返回就行了</li>
<li>第二条sql：从 name 这个索引对应的B+树上，找到xx这条数据，然后得到主键的值，在用这个值重复上一步，然后返回这行数据</li>
</ul>
<p>从非主键索引树查询到主键数据，再回主键索引树查找最终数据，这个过程我们称之为<strong>回表</strong>。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>前面我们知道了什么是回表，那我怎么样可以不回表呢？</p>
<p>覆盖索引的概念和回表刚好是相反的。。就是说无需回表，就可以获取到所需数据。</p>
<p>所以这是为什么我们尽量要减少 <code>select * </code> 的写法。</p>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>前面我们知道一个索引就对应一个B+树，创建的索引越多内存占用就越大。。</p>
<p>所以我们可以创建联合索引。。</p>
<p>并且联合索引的命中是 “最左匹配原则”，就是说联合索引的创建顺序是会对索引命中有影响的。</p>
<p>关于联合索引的命中和失效情况，有非常多，这里不展开讲。随便一搜能搜到很多。（涉及范围查询，排序等等）</p>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>这个其实也没什么好说的，就是mysql5.6之后的一个优化。</p>
<p>假设表t，有 id 的主键索引，有 （name, age） 的联合索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> name<span class="operator">=</span>ruomu <span class="keyword">and</span> age<span class="operator">=</span><span class="number">23</span>;</span><br></pre></td></tr></table></figure>

<p>在 mysql5.6 之前：</p>
<ul>
<li>去 (a,b) 索引对应b+树，查询到满足 name=ruomu 的结点</li>
<li>回表去判断是否满足 age=23 这个条件</li>
</ul>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/b32aa8b1f75611e0759e52f5915539ac.jpg" style="zoom:25%;" />

<p>有了索引下推之后：</p>
<ul>
<li>去 (a,b) 索引对应b+树，查询到 name=ruomu 的结点</li>
<li>因为是联合索引，所以 b 的值应该也在结点中呀，所以直接排除掉不满足 age=23 的</li>
<li>用满足条件的数据取回表，(因为是 select * 嘛。。还是会回表)，这样会少很多次回表。</li>
</ul>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/76e385f3df5a694cc4238c7b65acfe1b.jpg" style="zoom:25%;" />

<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>唯一索引，使用数据库的机制来约束数据的唯一性。</p>
<p>和普通索引的区别就是，新增数据的时候，需要判断数据的唯一性，要把磁盘的数据读取到内存中，不能使用change buffer 来缓存。</p>
<p>这里不展开说了，后面可能会整理一些关于， redo log、undo log、binlog、change buffer的文章。</p>
<h3 id="为什么b-树比b树更适合作为索引？"><a href="#为什么b-树比b树更适合作为索引？" class="headerlink" title="为什么b+树比b树更适合作为索引？"></a>为什么b+树比b树更适合作为索引？</h3><p>这是一个面试高频题吧？当做对本文的一个总结</p>
<ul>
<li>b+树的非叶子结点只有关键字，不保存卫星数据，所以一页能保存的关键字就更多，减少了IO读取的次数</li>
<li>b+树的卫星数据都在叶子节点上，查询效率固定为O(lgn)，比较稳定</li>
<li>b+树的所有叶子结点，使用链表有序连接，这样扫库和范围查询时效率更高</li>
</ul>
<p>ps: 本文只是一个框架吧，没有太多展开，对之前文章的一个重新整理。。</p>
<p>参考链接：</p>
<ul>
<li>极客时间《mysql实战45讲》</li>
<li>网络资料</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql之左右联结</title>
    <url>/2019/04/14/mysql%E4%B9%8B%E5%B7%A6%E5%8F%B3%E8%81%94%E7%BB%93/</url>
    <content><![CDATA[<p>之前对联结表的看理解好像不是很明确，于是又看了一些资料。</p>
<p>再次之前假装先建立两张表:</p>
<ul>
<li>tableA:三个字段(id,title,price)，五条记录</li>
<li>tableB:三个字断(id, title,price),三条记录</li>
<li>两张表之间有两条记录的price相同</li>
</ul>
<h2 id="内联结"><a href="#内联结" class="headerlink" title="内联结"></a>内联结</h2><p><code>INNER JOIN</code></p>
<p><code>select * from tableA INNER JOIN tableB ON a.title = b.title where tableA.price &gt; 100</code></p>
<p>上面语句的意思是，获取tableA和tableB中 title 字段相等的记录。</p>
<p>执行过程大概如下：</p>
<ul>
<li>因为上面假设的时候，他们是有两条记录满足price字段相等，所以这里会返回两条结果。</li>
<li>然后再在这两条结果里面筛选price&gt;100的结果</li>
</ul>
<h2 id="左联结"><a href="#左联结" class="headerlink" title="左联结"></a>左联结</h2><p><code>LEFT JOIN</code></p>
<p><code>select * from tableA LEFT JOIN tableB ON a.title = b.title where tableA.price &gt; 100</code></p>
<p>执行过程如下：</p>
<ul>
<li>因为tableA是有五条记录的，所以联结的时候先是会返回五条记录，以左边的表为准。如果右边的表的记录少于左边，那么填充NULL</li>
<li>然后在根据where子句的条件筛选出最终的结果</li>
</ul>
<h2 id="右联结"><a href="#右联结" class="headerlink" title="右联结"></a>右联结</h2><p><code>RIGHT JOIN</code></p>
<p><code>select * from tableA RIGHT JOIN tableB ON a.title = b.title where tableA.price &gt; 100</code></p>
<p>执行过程如下：</p>
<ul>
<li>因为tableB是有3条记录的，所以联结的时候先是会返回3条记录，以右边的表为准。如果右边的表的记录少于左边，那么填充NULL</li>
<li>然后在根据where子句的条件筛选出最终的结果</li>
</ul>
<p>其实左右联结可以通过两张表调换顺序实现。</p>
<p>总结一下：</p>
<ul>
<li>内联结两张表都受影响，返回满足on条件的记录</li>
<li>左联结只有右表受到影响，左表在没有where子句筛选时，返回所有记录。</li>
<li>右联结和左联结相反，只有左表受到影响，返回右表的所有记录。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>写了一个命令行的聊天室</title>
    <url>/2019/03/23/%E5%86%99%E4%BA%86%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%81%8A%E5%A4%A9%E5%AE%A4/</url>
    <content><![CDATA[<p><a href="https://github.com/ruomuc/test_demos/tree/master/command-chat">完整项目gihub地址传送门&gt;&gt;&gt;</a><br>基本功能：</p>
<ul>
<li>运行前端提示输入昵称，昵称不能和别人重复</li>
<li>可以创建聊天室，默认名字为 昵称+的聊天室</li>
<li>加入和创建聊天室是输入序号的</li>
<li>命令行的很简陋，因为不会画web界面，但是命令行很有科技感好嘛。。</li>
<li>更多详见 README.md</li>
</ul>
<p>ps:做着玩的，不喜勿喷。</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>人生路</title>
    <url>/2019/03/19/%E4%BA%BA%E7%94%9F%E8%B7%AF/</url>
    <content><![CDATA[<p>前段时间，wegame上出了一个新游戏叫《隐形守护者》，买来玩了玩。</p>
<p>人生何尝不是一次次选择，唯一的区别是不能重选罢了。和游戏里一样，不同的选择可能会有相同的结果，但是过程不一样啊，所以又回到了一个哲学问题，结果重要还是过程重要呢。都无所谓了，人生如戏，但不是游戏，选了就选了吧。不管结果如何，过程如何，反正不知道另一个选择的结果和过程对吧。</p>
<h6 id="木业飞舞之处，火亦生生不息。"><a href="#木业飞舞之处，火亦生生不息。" class="headerlink" title="木业飞舞之处，火亦生生不息。"></a><font color = red>木业飞舞之处，火亦生生不息。</font></h6><p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/huoying.jpg"></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>小小的总结一下</title>
    <url>/2019/03/13/%E5%B0%8F%E5%B0%8F%E7%9A%84%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B/</url>
    <content><![CDATA[<p>总结一下没有回答出来或者不熟练的问题吧。</p>
<h2 id="redis怎么备份"><a href="#redis怎么备份" class="headerlink" title="redis怎么备份"></a>redis怎么备份</h2><p>我所知道的备份就是conf文件内可以配合，它会自动定时保存一个rdb文件。<br>然鹅还有：</p>
<ul>
<li>SAVE 和 BGSAVE 两个命令都会调用 rdbSave 函数，但它们调用的方式各有不同：</li>
<li>SAVE 直接调用 rdbSave ，阻塞 Redis 主进程，直到保存完成为止。在主进程阻塞期间，服务器不能处理客户端的任何请求。</li>
<li>BGSAVE 则 fork 出一个子进程，子进程负责调用 rdbSave ，并在保存完成之后向主进程发送信号，通知保存已完成。因为 rdbSave 在子进程被调用，所以 Redis 服务器在 BGSAVE 执行期间仍然可以继续处理客户端的请求。</li>
</ul>
<h2 id="mysql除了的优化方案"><a href="#mysql除了的优化方案" class="headerlink" title="mysql除了的优化方案"></a>mysql除了的优化方案</h2><p>这个我所知道的最简单的就会加索引喽。然后就是设计表方面。我觉得设计一个合理的表结构是最重要的鸭。<br>如果非要从业务代码方面优化。<br><a href="https://coolshell.cn/articles/1846.html">https://coolshell.cn/articles/1846.html</a></p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>我依稀记得高阶函数就是以函数作为参数。<br>在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数：</p>
<ul>
<li>接受一个或多个函数作为输入</li>
<li>输出一个函数</li>
</ul>
<h2 id="访问一个网页经历了什么"><a href="#访问一个网页经历了什么" class="headerlink" title="访问一个网页经历了什么"></a>访问一个网页经历了什么</h2><p>我：</p>
<ul>
<li>访问网页应该是一个get请求</li>
<li>发送一个tcp数据包</li>
<li>三次握手连接</li>
<li>处理请求</li>
</ul>
<p>实际上：</p>
<ul>
<li>dns解析域名为ip地址</li>
<li>三次握手成功连接</li>
<li>处理请求</li>
<li>四次挥手关闭连接</li>
</ul>
<p>更详细生动的：<a href="https://www.zhihu.com/question/34873227">https://www.zhihu.com/question/34873227</a></p>
<h2 id="redis的基本数据结构"><a href="#redis的基本数据结构" class="headerlink" title="redis的基本数据结构"></a>redis的基本数据结构</h2><p>都知道就是有时叫不上来名字，因为看过python，看过其他的，关于元组，集合，列表这些有时会染半天。</p>
<ul>
<li>string 字符串</li>
<li>list  列表</li>
<li>set   无序集合</li>
<li>zset  有序集合</li>
<li>hash  哈希</li>
</ul>
<p>更多应用场景: <a href="https://yjph83.iteye.com/blog/2294001">https://yjph83.iteye.com/blog/2294001</a></p>
<p>然后我一直觉得列表和集合的功能差不多的，set其实是自动去重的。<br>zset就简单了，就是在set的基础上，加了一个属性，用来排序的。这个属性值是插入时指定的。</p>
<h2 id="剩下一些异步的设计方案"><a href="#剩下一些异步的设计方案" class="headerlink" title="剩下一些异步的设计方案"></a>剩下一些异步的设计方案</h2><p>无非就是 callback  到 promise 和 generator 再到 async/await。<br>这里的问题就非常多了，但也不是非常难，主要是一个使用经验和抉择。</p>
<p>PS:还有些没找到答案的。</p>
<p>—————————–2019年3月18日21:36:32——————————-<br>忙于找工作，好久没看书了，成都呆了这么久也没玩过几个地方。。。这几天头疼的很。。</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>发现一个有意思的变量暴露问题</title>
    <url>/2019/02/25/%E5%8F%91%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E5%8F%98%E9%87%8F%E6%9A%B4%E9%9C%B2%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>刚才撸代码调用一个变量，这个变量被暴露出去在其他文件改变了它的值，但是本文件调用时发现并没有改变，看了半天发现了一个问题。<br>新建一个a.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">foo</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">b.<span class="property">foo</span> = <span class="number">233</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>新建b.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">foo</span> = foo;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">//1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">exports</span>.<span class="property">foo</span>); <span class="comment">//233</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">foo</span>); <span class="comment">//233</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>使用<code>node a.js</code>启动，a.js先输出 1 然后b.js一秒后输出 1 ，233，233。<br>所以为什么b.js的<code>console.log(foo)</code>输出是1呢。。暂时不清楚，看下一个列子：</p>
<p>新建a.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">foo</span>.<span class="property">a</span>);</span><br><span class="line"></span><br><span class="line">b.<span class="property">foo</span>.<span class="property">a</span> = <span class="number">233</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>新建b.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">foo</span> = foo;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">a</span>); <span class="comment">//233</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">exports</span>.<span class="property">foo</span>.<span class="property">a</span>); <span class="comment">//233</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">foo</span>.<span class="property">a</span>); <span class="comment">//233</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>这里的foo是一个对象，里面有键值对<code>a:1</code>,这时猜猜b.js输出是什么，bingo，当然是233了。。。<br>这里也许知道为什么上面的变量值没有改变了。。也许传值和传引用在暴露变量也生效了。暴露一个变量 可以不用var而直接exports一个变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>所以对于传值来说，在暴露之前声明变量就没有什么意义了。反正调用的时候都要带上前面的一坨。。。</p>
<p><a href="https://github.com/ruomuc/test_demos/tree/master/exports%E6%9A%B4%E9%9C%B2%E5%8F%98%E9%87%8F">&gt;&gt;&gt;Demo github传送门</a></p>
]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>使用pm2管理node.js服务</title>
    <url>/2019/01/10/%E4%BD%BF%E7%94%A8pm2%E7%AE%A1%E7%90%86node.js%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>今天研究了一下使用pm2来管理node服务器，这样不仅可以看到每个服务占用的内存和cpu，还可以很方便的启动和重启，也可以使用<code>--watch</code>，自动重启，而且官方说<code>pm2 reload</code>来重启服务器是‘无缝’重启的。。</p>
<p><a href="http://pm2.keymetrics.io/docs/usage/quick-start/">官方快速入门文档传送门</a></p>
<p>简单的使用步骤：<br>1.下载<br><code> npm install pm2 -g</code></p>
<p>2.启动服务<br><code> pm2 start &lt; app name&gt;</code></p>
<p>3.重启服务<br><code> pm2 restart &lt; app name&gt;</code><br><code> pm2 reload &lt; app name&gt;</code></p>
<p>4.停止服务<br><code>pm2 stop &lt; app name&gt;</code></p>
<p>5.查看所有服务状态<br><code>pm2 list</code></p>
<p>6.删除服务，和stop不同的是，删除后不会存在list列表中。<br><code>pm2 delete &lt; id&gt;</code></p>
<p>7.删除所有服务<br><code>pm2 delete all</code></p>
<p>8.如果遇到稀奇古怪的问题可以使用<br><code>pm2 kill</code><br>慎用，会杀死所有服务，守护进程也会杀掉好像，和<code>delete</code>的区别不清楚。</p>
<p>9.高大上的监控界面，目前只知道用来看日志。<br><code>pm2 monit</code></p>
<p>其他用法还不清楚。<br>然后就是配置文件：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;apps&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wuwu&quot;</span><span class="punctuation">,</span>                             <span class="comment">// 项目名          </span></span><br><span class="line">        <span class="attr">&quot;script&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./bin/www&quot;</span><span class="punctuation">,</span>                      <span class="comment">// 执行文件</span></span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span>                                <span class="comment">// 根目录</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span>                                 <span class="comment">// 传递给脚本的参数</span></span><br><span class="line">        <span class="attr">&quot;interpreter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span>                          <span class="comment">// 指定的脚本解释器</span></span><br><span class="line">        <span class="attr">&quot;interpreter_args&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span>                     <span class="comment">// 传递给解释器的参数</span></span><br><span class="line">        <span class="attr">&quot;watch&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                              <span class="comment">// 是否监听文件变动然后重启</span></span><br><span class="line">        <span class="attr">&quot;ignore_watch&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>                           <span class="comment">// 不用监听的文件</span></span><br><span class="line">            <span class="string">&quot;node_modules&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;logs&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;exec_mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cluster_mode&quot;</span><span class="punctuation">,</span>                <span class="comment">// 应用启动模式，支持fork和cluster模式</span></span><br><span class="line">        <span class="attr">&quot;instances&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span>                             <span class="comment">// 应用启动实例个数，仅在cluster模式有效 默认为fork；或者 max</span></span><br><span class="line">        <span class="attr">&quot;max_memory_restart&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span>                    <span class="comment">// 最大内存限制数，超出自动重启</span></span><br><span class="line">        <span class="attr">&quot;error_file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./logs/app-err.log&quot;</span><span class="punctuation">,</span>         <span class="comment">// 错误日志文件</span></span><br><span class="line">        <span class="attr">&quot;out_file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./logs/app-out.log&quot;</span><span class="punctuation">,</span>           <span class="comment">// 正常日志文件</span></span><br><span class="line">        <span class="attr">&quot;merge_logs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                         <span class="comment">// 设置追加日志而不是新建日志</span></span><br><span class="line">        <span class="attr">&quot;log_date_format&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YYYY-MM-DD HH:mm:ss&quot;</span><span class="punctuation">,</span>   <span class="comment">// 指定日志文件的时间格式</span></span><br><span class="line">        <span class="attr">&quot;min_uptime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;60s&quot;</span><span class="punctuation">,</span>                        <span class="comment">// 应用运行少于时间被认为是异常启动</span></span><br><span class="line">        <span class="attr">&quot;max_restarts&quot;</span><span class="punctuation">:</span> <span class="number">30</span><span class="punctuation">,</span>                         <span class="comment">// 最大异常重启次数，即小于min_uptime运行时间重启次数；</span></span><br><span class="line">        <span class="attr">&quot;autorestart&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                        <span class="comment">// 默认为true, 发生异常的情况下自动重启</span></span><br><span class="line">        <span class="attr">&quot;cron_restart&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span>                         <span class="comment">// crontab时间格式重启应用，目前只支持cluster模式;</span></span><br><span class="line">        <span class="attr">&quot;restart_delay&quot;</span><span class="punctuation">:</span> <span class="string">&quot;60s&quot;</span>                      <span class="comment">// 异常重启情况下，延时重启时间</span></span><br><span class="line">        <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;NODE_ENV&quot;</span><span class="punctuation">:</span> <span class="string">&quot;production&quot;</span><span class="punctuation">,</span>                <span class="comment">// 环境参数，当前指定为生产环境 process.env.NODE_ENV</span></span><br><span class="line">           <span class="attr">&quot;REMOTE_ADDR&quot;</span><span class="punctuation">:</span> <span class="string">&quot;爱上大声地&quot;</span>               <span class="comment">// process.env.REMOTE_ADDR</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;env_dev&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;NODE_ENV&quot;</span><span class="punctuation">:</span> <span class="string">&quot;development&quot;</span><span class="punctuation">,</span>              <span class="comment">// 环境参数，当前指定为开发环境 pm2 start app.js --env_dev</span></span><br><span class="line">            <span class="attr">&quot;REMOTE_ADDR&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;env_test&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>                               <span class="comment">// 环境参数，当前指定为测试环境 pm2 start app.js --env_test</span></span><br><span class="line">            <span class="attr">&quot;NODE_ENV&quot;</span><span class="punctuation">:</span> <span class="string">&quot;test&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;REMOTE_ADDR&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>ps:我觉得最强大的是，pm2内置了 <code>cluster</code> 模块，可以指定启动进程个数，然后就是一堆服务监听一个端口，实现了集群.emm..<br>但是好像也有不好的地方。</p>
]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>pm2</tag>
      </tags>
  </entry>
  <entry>
    <title>git的使用</title>
    <url>/2019/01/04/git%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>看了几篇很好的文章，分享一下，git我都是当svn用的。就是 <code>add .  commit  push</code>.</p>
<p><a href="https://mp.weixin.qq.com/s/-TC07TQoiTNRUJIdBv46SQ">入门</a> :git新手入门，介绍Git的基本概念。</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU0OTE3MjE1Mw==&mid=2247484341&idx=1&sn=64bde82cd3459b07340c89a56e3fa473&chksm=fbb2a563ccc52c7584bffbdc21ef9fd70a45aa3223e1b584063ac8f0c67596060c574c66705b&scene=21#wechat_redirect">Git的奇技淫巧
</a>:git的常用语法。</p>
<p><a href="https://mp.weixin.qq.com/s/wH-msSi8pBkcZBux0yLhng">更优雅的使用Git</a>：更规范的使用git。</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>node的多进程</title>
    <url>/2018/12/31/node%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>现行的软件架构主要有两种：多线程单进程(如：memcached、redis、mongodb等)和单线程多进程(nginx、node)。<br>多线程单进程的主要特点：</p>
<ul>
<li>快：线程比进程轻量，它的切换开销要少很多。进程相当于函数间切换，每个函数拥有自己的变量；线程相当于一个函数内的子函数切换，它们拥有相同的全局变量。</li>
<li>灵活： 程序逻辑和控制方式简单，但是锁和全局变量同步比较麻烦。</li>
<li>稳定性不高： 由于只有一个进程，其内部任何线程出现问题都有可能造成进程挂掉，造成不可用。</li>
<li>性能天花板：线程和主程序受限2G地址空间；当线程到一定数量后，即使增加cpu也不能提升性能。</li>
</ul>
<p>单线程多进程的主要特点：</p>
<ul>
<li>高性能：没有频繁创建和切换线程的开销，可以在高并发的情况下保持低内存占用；可以根据CPU的数量增加进程数。</li>
<li>线程安全：没有必要对变量进行加锁解锁的操作</li>
<li>异步非阻塞：通过异步I/O可以让cpu在I/O等待的时间内去执行其他操作，实现程序运行的非阻塞</li>
<li>性能天花板：进程间的调度开销大、控制复杂；如果需要跨进程通信，传输数据不能太大。</li>
</ul>
<p>虽然实际上node.js也不完全是单线程，只有js代码是单线程的而已，I/O等操作都丢到了一个C实现的叫Libuv的库里，和v8一样也是node的核心。</p>
<h2 id="多进程架构"><a href="#多进程架构" class="headerlink" title="多进程架构"></a>多进程架构</h2><p>面对单进程对多核CPU利用不足的问题，就是启动多个进程即可。<br>node提供了child_process模块，通过child_process.fork()函数来进行进程的复制。<br>例如：<br>将以下代码保存为worker.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="keyword">function</span>(<span class="params">req,res</span>)&#123;</span><br><span class="line">	res.<span class="title function_">write</span>(<span class="number">200</span>,&#123;<span class="string">&#x27;Content-Type&#x27;</span>:text/plain&#125;);</span><br><span class="line">	res.<span class="title function_">end</span>(<span class="string">&#x27;Hello World\n&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="title class_">Math</span>.<span class="title function_">round</span>((<span class="number">1</span>+<span class="title class_">Math</span>.<span class="title function_">random</span>())*<span class="number">1000</span>),<span class="string">&#x27;127.0.0.1&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将以下代码保存为master.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fork = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="property">fork</span>;</span><br><span class="line"><span class="keyword">var</span> cpus = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>).<span class="title function_">cpus</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span> ; i &lt; cpus.<span class="property">length</span>;++i)&#123;</span><br><span class="line">	<span class="title function_">fork</span>(<span class="string">&#x27;./worker.js&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后node master.js 。然后以上的代码会根据当前机器的cpu数，复制出对应的node进程数量。如果在linu环境下，可以通过<code>ps -ef|grep master.js</code>来查看。</p>
<p>以下就是著名的Master-Worker 模式，（主从模式）<br><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/child_process.png"></p>
<p>fork()出来的这个进程拥有独立的v8实例。它需要至少30毫秒启动时间和至少10MB内存。fork()的代价是昂贵的，而且多进程并不能解决并发问题，只是为了充分利用CPU资源而已。node的大并发问题是通过事件驱动来解决的。</p>
<h2 id="child-process模块创建子进程"><a href="#child-process模块创建子进程" class="headerlink" title="child_process模块创建子进程"></a>child_process模块创建子进程</h2><p>node提供了四种方法来创建子进程:</p>
<ul>
<li>spawn() 启动一个子进程来执行命令</li>
<li>exec() 启动一个子进程来执行命令，与spawn() 不同的是其接口不同，它有一个回调函数来获知子进程的状况。</li>
<li>execFile() 启动一个子进程来执行可执行文件。</li>
<li>fork() 与spawn()类似，但是它创建子进程只需要指定要执行的JavaScript文件模块。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">&#x27;child_process);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">cp.spawn(&#x27;</span>node<span class="string">&#x27;,[&#x27;</span>worker.<span class="property">js</span><span class="string">&#x27;]);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">cp.exec(&#x27;</span>node worker.<span class="property">js</span><span class="string">&#x27;,function(err,stdout,stderr)&#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">cp.execFile(&#x27;</span>worker.<span class="property">js</span><span class="string">&#x27;,function(err,stdout,stderr)&#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">cp.fork(&#x27;</span>./worker.<span class="property">js</span><span class="string">&#x27;);</span></span><br></pre></td></tr></table></figure>
<p>ps:如果用execFile()的话，文件头部要加上<code>#!/usr/bin/env node</code></p>
<span id="more"></span>
<h2 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h2><p>——————-2019年1月1日14:25:45—————————————-</p>
<blockquote>
<p>19年的第一天更新，祝我技术越来越好。</p>
</blockquote>
<p>主进程和子进程进行通信是十分容易的，类似于websocket的通信模式，发送(send)和监听(.on(‘’))。</p>
<p>先看下js前端的WebWorker API,为了是UI渲染和JS执行不互相阻塞。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;worker.js&#x27;</span>) <span class="comment">//worker.js是一个需要执行的js文件</span></span><br><span class="line">worker.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line"> <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;result&#x27;</span>).<span class="property">textContent</span> = event.<span class="property">data</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>worker.js如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="attr">search</span>: <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(n);i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">continue</span> search;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="title function_">postMessage</span>(n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，使用postMessage来发送数据，使用onmessage来接受数据。</p>
<p>而node中:<br>parent.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> n = cp.<span class="title function_">fork</span>(__dirname + <span class="string">&#x27;/sub.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line">n.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>,<span class="keyword">function</span>(<span class="params">m</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;parent get message:&#x27;</span>,m);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">n.<span class="title function_">send</span>(&#123;<span class="attr">hello</span>:<span class="string">&#x27;world&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>sub.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>,<span class="keyword">function</span>(<span class="params">m</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;child get message&#x27;</span>,m);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">send</span>(&#123;<span class="attr">foo</span>:<span class="string">&#x27;bar&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>至于进程之间的通信原理，也不写那么多了，总结下来就是:</p>
<blockquote>
<p>父进程在创建子进程之前，会先创建IPC通道并监听子进程，然后再创建子进程，通过环境变量(NODE_CHILD_FD)告诉子进程这个IPC通道的文件描述符。子进程启动时，通过描述符去连接这个已存在的IPC通道，完成父子进程之间的连接。</p>
</blockquote>
<h2 id="句柄传递"><a href="#句柄传递" class="headerlink" title="句柄传递"></a>句柄传递</h2><p>什么是句柄？<br>句柄是一种可以用来表示资源的引用，它的内部包含了指向对象的文件描述符。 比如可以用来表示一个socket对象、一个UDP套接字，一个管道等。</p>
]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>所以get和post到底有区别吗？</title>
    <url>/2018/11/09/%E6%89%80%E4%BB%A5get%E5%92%8Cpost%E5%88%B0%E5%BA%95%E6%9C%89%E5%8C%BA%E5%88%AB%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="如题"><a href="#如题" class="headerlink" title="如题"></a>如题</h2><p><a href="http://www.cnblogs.com/logsharing/p/8448446.html">http://www.cnblogs.com/logsharing/p/8448446.html</a></p>
<p>说白了就是语义区别，和大家的约定，你可以不按套路来鸭。</p>
<p>ps:顺便整理几个问题</p>
<h2 id="POST-和-PUT-有什么区别"><a href="#POST-和-PUT-有什么区别" class="headerlink" title="POST 和 PUT 有什么区别?"></a>POST 和 PUT 有什么区别?</h2><p>POST 是新建 (create) 资源, 非幂等, 同一个请求如果重复 POST 会新建多个资源. PUT 是 Update/Replace, 幂等, 同一个 PUT 请求重复操作会得到同样的结果.</p>
<p>ps: 表面来看 post类似于mysql的insert，put类似于update呗？</p>
<h2 id="cookie-与-session-的区别-服务端如何清除-cookie"><a href="#cookie-与-session-的区别-服务端如何清除-cookie" class="headerlink" title="cookie 与 session 的区别? 服务端如何清除 cookie?"></a>cookie 与 session 的区别? 服务端如何清除 cookie?</h2><p>主要区别在于, session 存在服务端, cookie 存在客户端. session 比 cookie 更安全. 而且 cookie 不一定一直能用 (可能被浏览器关掉). 服务端可以通过设置 cookie 的值为空并设置一个及时的 expires 来清除存在客户端上的 cookie.</p>
<h2 id="什么是跨域请求-如何允许跨域"><a href="#什么是跨域请求-如何允许跨域" class="headerlink" title="什么是跨域请求? 如何允许跨域?"></a>什么是跨域请求? 如何允许跨域?</h2><p>出于安全考虑, 默认情况下使用 XMLHttpRequest 和 Fetch 发起 HTTP 请求必须遵守同源策略, 即只能向相同 host 请求 (host = hostname : port) 注[1]. 向不同 host 的请求被称作跨域请求 (cross-origin HTTP request)。</p>
<p>比如express的解决方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="title function_">express</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置跨域访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// all方法表示:所有请求都必须通过该中间件，参数中的“*”表示对所有路径有效</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;*&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123; <span class="comment">// 回调函数的三参数:request对象、response对象、next回调函数</span></span><br><span class="line"></span><br><span class="line">    res.<span class="title function_">header</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">    res.<span class="title function_">header</span>(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;X-Requested-With&quot;</span>);</span><br><span class="line"></span><br><span class="line">    res.<span class="title function_">header</span>(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;PUT,POST,GET,DELETE,OPTIONS&quot;</span>);</span><br><span class="line"></span><br><span class="line">    res.<span class="title function_">header</span>(<span class="string">&quot;X-Powered-By&quot;</span>, <span class="string">&#x27; 3.2.1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    res.<span class="title function_">header</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">next</span>(); <span class="comment">// 将request对象再传给下一个中间件</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="socket-hang-up"><a href="#socket-hang-up" class="headerlink" title="socket hang up"></a>socket hang up</h2><p>在 Node.js 中当你要 response 一个请求的时候, 发现该这个 socket 已经被 “挂断”, 就会就会报 socket hang up 错误.</p>
<p>ps:一次http请求只能res.send()一次。</p>
]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全之openssl</title>
    <url>/2018/11/06/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B9%8Bopenssl/</url>
    <content><![CDATA[<p>客户端和服务端的数据传输如果不加密就会被别人截取而泄露数据。对于开发者而言，加密和解密最好是放在传输层，而应用层的数据处理仍然是透明的。<br>node在网络安全提供了，tls、https、crypto三个模块。tls类似net、https是http安全版。crypto提供了SHA1、MD5等加密算法。</p>
<h2 id="TLS-SSL-结构"><a href="#TLS-SSL-结构" class="headerlink" title="TLS/SSL 结构"></a>TLS/SSL 结构</h2><p>node底层采用的是openssl实现TSL/SSL的，所以可以使用openssl生成公钥和私钥。</p>
<p>1.下载安装openssl<br>我是在<a href="http://slproweb.com/products/Win32OpenSSL.html">http://slproweb.com/products/Win32OpenSSL.html</a> 下载windows安装包。<br>然后配置环境变量。<br>然后随便在一个地方打开cmd命令提示符，输入openssl就可以进入生成秘钥操作。<br>2.生成私钥。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//生成服务器私钥</span><br><span class="line">genrsa -out server.key 1024</span><br><span class="line">//生成客户端私钥</span><br><span class="line">genrsa -out client.key 1024</span><br></pre></td></tr></table></figure>
<p>上面生成了两个1024位长的RSA私钥文件。当前操作目录下会有server.key 和 client.key<br>3.生成公钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rsa -in server.key -pubout -out server.pem</span><br><span class="line"></span><br><span class="line">rsa -in client.key -pubout -out client.pem</span><br></pre></td></tr></table></figure>
<p>公私钥还是会被窃听，窃听者通过扮演假的服务器和客户端，来伪造响应和请求。<br>所以就有了数字证书。</p>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>数字证书中包含了服务器的名称和主机名、服务器的公钥、签名颁发机构的名称、来自签名颁发机构的签名。在连接建立之前，会通过证书中的签名确认收到的公钥是来自目标服务器的，从而产生信任关系。</p>
<p>为了保证数据安全，我们引入一个第三方CA。CA的作用是为站点颁发证书，这个证书中具有CA通过自己的公钥和私钥实现的签名。</p>
<p>为了得到签名证书，服务器需要通过自己的私钥生成CSR文件，CA机构将通过这个文件颁发属于该服务器的签名证书，只要通过CA机构就能验证证书是否合法。</p>
<p>1.生成扮演CA角色需要的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">genrsa -out ca.key 1024 //生成了一个ca.key文件</span><br><span class="line"></span><br><span class="line">req -new -key ca.key -out ca.csr //输入一堆信息确认后生成一歌ca.csr文件</span><br><span class="line"></span><br><span class="line">x509 -req -in ca.csr -signkey ca.key -out ca.crt //生成一个ca.crt文件</span><br></pre></td></tr></table></figure>

<p>2.服务器向CA机构申请签名证书。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">req -new -key server.key -out server.csr</span><br></pre></td></tr></table></figure>
<p>这一步报错了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">problem creating object tsa_policy1=1.2.3.4.1</span><br><span class="line">10964:error:08064066:object identifier routines:OBJ_create:oid exists:crypto\objects\obj_dat.c:698:</span><br><span class="line">error in req</span><br></pre></td></tr></table></figure>
<p>顺便找到一个linux下的解决方案：<a href="https://www.howtoforge.com/tutorial/how-to-install-openssl-from-source-on-linux/">https://www.howtoforge.com/tutorial/how-to-install-openssl-from-source-on-linux/</a></p>
<p>有人说是openssl版本导致的，所以换个版本从新下载安装。1.0.2<br>重装之后，ojbk。<br>会在当前目录生成一个<code>server.csr</code>文件。</p>
<p>然后现在可以向自己的CA机构申请签名了，生成签名需要CA的证书和私钥，最终颁发一个带有CA签名的证书。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in server.csr -out server.crt</span><br></pre></td></tr></table></figure>
<p>生成server.crt文件。</p>
<p>客户端在发起请求回去获取服务器端的证书，并通过CA证书验证服务器证书的真伪。</p>
<h2 id="TSL服务"><a href="#TSL服务" class="headerlink" title="TSL服务"></a>TSL服务</h2><p>他喵的，怎么验证都失败，心态崩了，感觉是csr生成时信息没填好。<br>Demo github 地址：<a href="https://github.com/ruomuc/test_demos/tree/master/openssl_demo">https://github.com/ruomuc/test_demos/tree/master/openssl_demo</a></p>
<p>——————–2018年11月10日 11:32:02————————–<br>ps：https的demo也是一样的问题，我觉得就是生成csr的时候域名每填好。。。orz<br>就先了解一下吧。</p>
]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>一个很有意思面试题</title>
    <url>/2018/09/13/%E4%B8%80%E4%B8%AA%E5%BE%88%E6%9C%89%E6%84%8F%E6%80%9D%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/25407758">https://zhuanlan.zhihu.com/p/25407758</a> </p>
<p>看了下知乎上某位大佬分享的一个题，我自己分析一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面这行代码明显是直接打印出 0-4,以下为chrome控制台复制的打印结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">column.<span class="property">raven</span>.<span class="property">bcd2ad0d66eba703dd35</span>.<span class="property">js</span>:<span class="number">1</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">column.<span class="property">raven</span>.<span class="property">bcd2ad0d66eba703dd35</span>.<span class="property">js</span>:<span class="number">1</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">column.<span class="property">raven</span>.<span class="property">bcd2ad0d66eba703dd35</span>.<span class="property">js</span>:<span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">column.<span class="property">raven</span>.<span class="property">bcd2ad0d66eba703dd35</span>.<span class="property">js</span>:<span class="number">1</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">column.<span class="property">raven</span>.<span class="property">bcd2ad0d66eba703dd35</span>.<span class="property">js</span>:<span class="number">1</span> <span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="然后开始第一次进化："><a href="#然后开始第一次进化：" class="headerlink" title="然后开始第一次进化："></a>然后开始第一次进化：</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line"></span><br><span class="line">  &#125;, <span class="number">1000</span> * i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面这段代码，分析一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">i = 0 时： 延迟 0s</span><br><span class="line"></span><br><span class="line">i = 1 时： 延迟 1s</span><br><span class="line"></span><br><span class="line">i = 2 时： 延迟 2s</span><br><span class="line"></span><br><span class="line">i = 3 时： 延迟 3s</span><br><span class="line"></span><br><span class="line">i = 4 时： 延迟 4s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以会立马打印一个值，然后没过一秒打印一个值，一共输出五个值。但是这个值是什么呢？因为for循环是立即执行的，而setTimeout哪怕是延迟0s，也是会被放到任务队列后面的，参照<a href="http://ruomuc.gitee.io/blog/2019/01/02/event%20loop/">http://ruomuc.gitee.io/blog/2019/01/02/event%20loop/</a>。所以第一次执行setTimeout的回调的时候，i的值就已经是5了。</p>
<h5 id="那应该怎么改才能输出-0-到-4-呢？"><a href="#那应该怎么改才能输出-0-到-4-呢？" class="headerlink" title="那应该怎么改才能输出 0 到 4 呢？"></a>那应该怎么改才能输出 0 到 4 呢？</h5><p>一个很简单闭包就解决了，也是js的经典问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">或者不用闭包，用新语法<span class="keyword">let</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line"></span><br><span class="line">  (function(i) &#123;</span><br><span class="line"></span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line"></span><br><span class="line">      console.log(i);</span><br><span class="line"></span><br><span class="line">    &#125;, i * 1000);</span><br><span class="line"></span><br><span class="line">  &#125;)(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者不用闭包，用新语法let:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line"></span><br><span class="line">  &#125;, <span class="number">1000</span> * i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关于let和var 的区别可以去看下<a href="https://es6.ruanyifeng.com/#docs/let">阮一峰的ES6入门</a></p>
<p>以上代码输出结果都为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">column.raven.1e01f608522ae2f2785f.js:1 0</span><br><span class="line"></span><br><span class="line">column.raven.1e01f608522ae2f2785f.js:1 1</span><br><span class="line"></span><br><span class="line">column.raven.1e01f608522ae2f2785f.js:1 2</span><br><span class="line"></span><br><span class="line">column.raven.1e01f608522ae2f2785f.js:1 3</span><br><span class="line"></span><br><span class="line">column.raven.1e01f608522ae2f2785f.js:1 4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="删掉这个-i-会发生什么"><a href="#删掉这个-i-会发生什么" class="headerlink" title="删掉这个 i 会发生什么?"></a>删掉这个 i 会发生什么?</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line"></span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  &#125;)(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码虽然写了闭包，但是没有对i保持引用，所以可定还是没有用闭包之前的结果。setTimeout内部的i的值引用的还是for循环的i的值。也就是5。</p>
<h5 id="再次进化"><a href="#再次进化" class="headerlink" title="再次进化"></a>再次进化</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>((<span class="keyword">function</span>(<span class="params">i</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line"></span><br><span class="line">  &#125;)(i), i * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>setTimeout的第一个参数必须是需要编译的代码或者是一个函数方法，而如果直接传入一行可执行代码，那么抱歉，这里会立即执行，没有延迟效果。 </p>
<p>所以上述代码会立即输出 0 -4。  ps：又回到最初的起点？</p>
<h5 id="好了，面试官不耐烦了-，放大招了"><a href="#好了，面试官不耐烦了-，放大招了" class="headerlink" title="好了，面试官不耐烦了 ，放大招了~"></a>好了，面试官不耐烦了 ，放大招了~</h5><span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> <span class="title function_">executor</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;<span class="number">10000</span> ; i++ ) &#123;</span><br><span class="line"></span><br><span class="line">    i == <span class="number">9999</span> &amp;&amp; <span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码的输出顺序是什么？</p>
<p>分析一波：</p>
<p>首先，setTimeout会把回调函数放到任务队列尾部，然后往下，new Promise这个函数会立即执行，会立马输出 2 和3， then里面的东西会被放到当前tick结束执行，那接下来肯定会打印 5，然后出去会打印4，现在看看剩下两个，setTimeout在任务队列尾部，肯定是最后打印的。所以输出顺序就完了。。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>分析下来其实很简单，但是在我不知道这些细节之前，这个题完全是知其然不知其所以然。。现在看一下，其实很简单，不要慌，慢慢分析就行了。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试和Mocha</title>
    <url>/2018/09/12/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%92%8CMocha/</url>
    <content><![CDATA[<h2 id="单元测试的必要性"><a href="#单元测试的必要性" class="headerlink" title="单元测试的必要性"></a>单元测试的必要性</h2><p>比如创建 add.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//add.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a,b</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个代码有啥好测得？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; add = <span class="keyword">function</span>(<span class="params">a, b</span>)&#123;<span class="keyword">return</span> a + b&#125;</span><br><span class="line">[<span class="title class_">Function</span>: add]</span><br><span class="line">&gt; <span class="title function_">add</span>(<span class="number">4</span>)</span><br><span class="line"><span class="title class_">NaN</span></span><br></pre></td></tr></table></figure>
<p>NaN?为什么呢。因为不够严谨，只传一个参数就报错了。<br>所以正确写法应该是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//add2.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&quot;number&quot;</span> &amp;&amp; <span class="keyword">typeof</span> b === <span class="string">&quot;number&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>人在写代码的时候会有思维漏洞，但是在写测试的时候往往会考虑各种情况。这就是所谓的TDD。</p>
<h2 id="Mocha测试框架"><a href="#Mocha测试框架" class="headerlink" title="Mocha测试框架"></a>Mocha测试框架</h2><span id="more"></span>
<p>Mocha框架+assert断言库<br>编写test.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="built_in">require</span>(<span class="string">&#x27;./add.js&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(<span class="string">&quot;assert&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当2个参数均为整数时</span></span><br><span class="line"><span class="title function_">it</span>(<span class="string">&quot;should return 3&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    assert.<span class="title function_">equal</span>(sum, <span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当第2个参数为String时</span></span><br><span class="line"><span class="title function_">it</span>(<span class="string">&quot;should return undefined&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="title function_">add</span>(<span class="number">1</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">    assert.<span class="title function_">equal</span>(sum, <span class="literal">undefined</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当只有1个参数时</span></span><br><span class="line"><span class="title function_">it</span>(<span class="string">&quot;should return undefined&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line">    assert.<span class="title function_">equal</span>(sum, <span class="literal">undefined</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>测试代码中使用了Node.js自带的断言库Assert的assert.equal函数，用于判定add函数返回的结果是否正确。assert.equal成功时不会发生什么，而失败时会抛出一个AssertionErro.<br>使用mocha执行test.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mocha test.js</span><br></pre></td></tr></table></figure>
<p>下面为输出，表示测试案例全部通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">✓ should return 3</span><br><span class="line">✓ should return undefined</span><br><span class="line">✓ should return undefined</span><br><span class="line"></span><br><span class="line">3 passing</span><br></pre></td></tr></table></figure>
<p>而当我们使用test1.js测试add.js时，则后面2个测试案例失败:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">✓ should return 3</span><br><span class="line">  1) should return undefined</span><br><span class="line">  2) should return undefined</span><br><span class="line"></span><br><span class="line">  1 passing (14ms)</span><br><span class="line">  2 failing</span><br><span class="line"></span><br><span class="line">  1)  should return undefined:</span><br><span class="line">     AssertionError: &#x27;12&#x27; == undefined</span><br><span class="line">      at Context.&lt;anonymous&gt; (test/test1.js:18:12)</span><br><span class="line"></span><br><span class="line">  2)  should return undefined:</span><br><span class="line">     AssertionError: NaN == undefined</span><br><span class="line">      at Context.&lt;anonymous&gt; (test/test1.js:25:12)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Node.js自带的断言库Assert提供的函数有限，在实际工作中，Should等第三方断言库则更加强大和实用。<br>ps:关于更多的断言库，其实也没必要说了，都是搬运下来的。网上有很多。原理基本都一样。</p>
<p>另外说一个后端常用的测试HTTP的模块 SuperTest。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">&quot;supertest&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">&quot;../server.js&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(<span class="string">&quot;assert&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">it</span>(<span class="string">&quot;should return hello fundebug&quot;</span>, <span class="keyword">function</span>(<span class="params">done</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">request</span>(server)</span><br><span class="line">        .<span class="title function_">get</span>(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">        .<span class="title function_">expect</span>(<span class="number">200</span>)</span><br><span class="line">        .<span class="title function_">expect</span>(<span class="keyword">function</span>(<span class="params">res</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            assert.<span class="title function_">equal</span>(res.<span class="property">text</span>, <span class="string">&quot;Hello Fundebug&quot;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">end</span>(done);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>SuperTest封装了发送HTTP请求的接口，并且提供了简单的expect断言来判定接口返回结果。对于POST接口，使用SuperTest的优势将更加明显，因为使用Node.js的http模块发送POST请求是很麻烦的。</p>
</blockquote>
<p>原文链接：<a href="https://blog.fundebug.com/2017/03/20/nodejs-unit-test/">https://blog.fundebug.com/2017/03/20/nodejs-unit-test/</a><br>PS:看到就搬一点，记得更清楚一点。</p>
]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出node.js之网络编程</title>
    <url>/2018/09/08/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode.js%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>好久没更博客了，最近没看书了，买了辆公路车沉迷骑行无法自拔 -.-</p>
<h2 id="node-js网络模块"><a href="#node-js网络模块" class="headerlink" title="node.js网络模块"></a>node.js网络模块</h2><p> node.js提供提供了 <code>net 、 dgram 、 http 、https</code>这四个模块，分别用于处理<code>TCP 、 UDP 、 HTTP 、 HTTPS</code>适用于服务器端和客户端。</p>
<h2 id="构建TCP服务"><a href="#构建TCP服务" class="headerlink" title="构建TCP服务"></a>构建TCP服务</h2><p> TCP全名为传输控制协议，在<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E7%B3%BB%E7%BB%9F%E4%BA%92%E8%BF%9E%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B?fromtitle=OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B&fromid=9763441">OSI</a>模型中属于传输层协议,许多应用层协议如<a href="https://baike.baidu.com/item/http">HTTP</a>、<a href="https://baike.baidu.com/item/SMTP">SMTP</a>、<a href="https://baike.baidu.com/item/imap">IMAP</a>等都是基于TCP构建的。</p>
<p>TCP是面向连接的协议，其显著特征是在传输前需要<a href="https://baike.baidu.com/item/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/5111559">三次握手</a>形成会话。</p>
<p>只有在会话形成之后，服务器端和客户端之间才能互相发送数据。在创建会话的过程中，服务器端和客户端分别提供一个套接字，这两个套接字共同形成一个连接。服务器端和客户端通过套接字实现两者之间的连接操作。</p>
<p>了解原理之后，通过node.js来创建一个TCP服务器端来接受网络请求。代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = net.<span class="title function_">createServer</span>(<span class="keyword">function</span>	(<span class="params">socket</span>)&#123;</span><br><span class="line">	socket.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>,<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">		socket.<span class="title function_">write</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	socket.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>,<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;连接断开&quot;</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">	socket.<span class="title function_">write</span>(<span class="string">&quot;welcome to read &#x27;深入浅出node.js&#x27; : \n&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">3000</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server bound&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于net.createServer创建的服务器而言，他是一个EventEmitter实例，他的自定义事件有如下几种：</p>
<ul>
<li>listening:在调用server.listen()绑定端口或者Domain Socket 后触发。</li>
<li>connection:每个客户端套接字连接到服务器端时触发。</li>
<li>close:当服务器关闭时触发。</li>
<li>error：当服务器发生异常时触发。</li>
</ul>
<p>##构建UDP服务<br>UDP又称用户数据包协议，与TCP一样同属于网络传输层。但是UDP不是面向连接的，所以它的资源消耗低，处理快速且灵活，所以常常应用在那种偶尔丢一两个数据包也不会产生重大影响的场景，比如音频，视频等。 DNS就是基于UDP实现的。</p>
<p>创建UDP套接字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dgram = <span class="built_in">require</span>(<span class="string">&#x27;dgram&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> socket = dgram.<span class="title function_">createSocket</span>(<span class="string">&#x27;udp4&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>创建UDP服务端</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dgram = <span class="built_in">require</span>(<span class="string">&#x27;dgram&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server = dgram.<span class="title function_">createSocket</span>(<span class="string">&#x27;udp4&#x27;</span>);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&quot;message&quot;</span>,<span class="keyword">function</span>(<span class="params">msg,rinfo</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;server got:&quot;</span>+msg+<span class="string">&quot;from&quot;</span>+rinfo.<span class="property">address</span>+<span class="string">&quot;:&quot;</span>+rinfo.<span class="property">port</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&quot;listening&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> address = server.<span class="title function_">address</span>();</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;server listening&quot;</span> + address.<span class="property">address</span> + <span class="string">&quot;：“+address.port);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">server.bind(41234);</span></span><br></pre></td></tr></table></figure>
<p>该套接字将接受所有网卡上41234端口上的消息。在绑定完成后，将触发listening事件。<br>&lt;!-more–&gt;<br>TCP和UDP都是网络传输层协议，如果要构建高效的网络应用，就应该从传输层着手，但是对于一般的应用场景，无需从传输层协议着手，使用node.js提供的HTTP、HTTPS等模块绰绰有余。</p>
<p>简单的几行代码就可以构建一个HTTP服务器:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="keyword">function</span>(<span class="params">req,res</span>)&#123;</span><br><span class="line">res.<span class="title function_">writeHead</span>(<span class="number">200</span>,&#123;<span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;text/plain&#x27;</span>&#125;);</span><br><span class="line">res.<span class="title function_">end</span>(<span class="string">&#x27;hello world\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">1337</span>,<span class="string">&#x27;127.0.0.1&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server running at http://127.0.0.1:1337/&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>虽然几行代码就可以完成一个HTTP服务器，但是它的并发量和QPS都是不容小觑的。</p>
<p>ps:骑自行车摔了一跤，胳膊有点疼，就少打了点字。反正说是博客其实就是自己的笔记。自己看看就行了。我这么菜的 O(∩_∩)O</p>
]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx+node.js实现简单的URL分发</title>
    <url>/2018/09/03/nginx+node-js%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84URL%E5%88%86%E5%8F%91/</url>
    <content><![CDATA[<p>前段时间做了一个主页部署到了vps上面，当时遇到一个问题没有解决：关于URL分发的问题。刚好我重装了一个vps，之前那个太贵了，装了一个低配一点的，然后我的主站就要重新部署。</p>
<p>之前是node监听的是一个非80端口，但是，阿里云默认解析到80端口，为了好看不再域名后面加<code>:</code>和端口号，我就只能把主站的监听端口改成了80，但是80只有一个，后面部署其他项目怎么办呢。。</p>
<p>于是我这次准备一次解决完：</p>
<ul>
<li>第一个解决方法，好像去域名解析哪里设置什么显/隐性URL解析可以解决，因为阿里云要求解析域名和被指向域名都需要备案才行，不是实名认证，是备案哦。。别的服务商我不清楚，于是pass掉了。。</li>
<li>第二个方法：使用nginx配置来进行URL的分发。说实话搞完之后发现挺简单的，虽然nginx的具体配置意思不懂，但是先实现目的就行啦。。</li>
</ul>
<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p>安装nginx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure>
<p>如果你不能通过上述命令安装，那么更换你的云源，或者参考<a href="https://ruomuc.gitee.io/blog/2018/08/13/linux%E9%83%A8%E7%BD%B2%E7%BD%91%E7%AB%99/">linux部署网站</a>一文中的node.js安装方式(我们不做伸手党！)</p>
<p>启动nginx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure>
<p>启动之后访问你解析后的域名或者服务器ip。会有一个nginx欢迎页。。那么恭喜你安装成功。</p>
<p>接下来就要开始配置nginx.conf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -name nginx.conf</span><br></pre></td></tr></table></figure>
<p>由于我也不太确定会在哪里，就搜一下喽。。<br>使用vi 或者 xftp 修改配置文件。<br>打开nginx.conf文件，找到这样一行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include /etc/nginx/conf.d/*.conf;</span><br></pre></td></tr></table></figure>
<p>当然这个是我的目录，你在这个下面新建一个<code>*.conf</code>文件，<code>*</code>代表任意的意思，没有目录就新建一个目录，或者你修改这个路径，反正能加载到一个<code>*.conf</code>文件即可。<br>然后再新建的<code>*.conf</code>文件里面配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name home.ruomu.cc;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://66.42.74.169:81;</span><br><span class="line">        proxy_set_header Host $host:80;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header Via &quot;nginx&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是我的配置，listen是监听的端口号，server_name，是你的转发的域名，下面proxy_pass：是你的主机ip：端口号，这个端口号就是你服务监听的端口号，比如我的主站就监听在81端口。</p>
<p>如果你想访问主域名或者访问80端口时不显示那个nginx欢迎页，我就乱搞了一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        listen       [::]:80 default_server;</span><br><span class="line">        server_name  _;</span><br><span class="line">        # root         /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">        # Load configuration files for the default server block.</span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://66.42.74.169:81;</span><br><span class="line">            proxy_set_header Host $host:80;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header Via &quot;nginx&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">            location = /40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">            location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，我在nginx.conf这个配置文件里面吧root那一行注释掉，因为欢迎页好像就是这个html文件，然后下面的照着上面的配置。就成功了。<br>现在你访问主域名和80端口都会指向81，包括你新建的配置文件里所有的域名都可以分发到不同的端口，爽上天有木有！</p>
<p>修改好了之后重启一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure>
<p>然后关于二级域名应该很简单，阿里云域名解析教程里面很详细。<br>目前我解析了一个主域名和一个二级域名<br><a href="http://www.ruomu.cc/">www.ruomu.cc</a>  和  home.ruomu.cc</p>
<p>ps:我自己看自己博客的时候发现了错别字，我现在已经引入了评论系统，如果有人看到的话，可以留言的其实 -.-,虽然感觉这个博客就我一个人再看 =.=</p>
<p>—————————2018-9-4 10:04:40——————————————</p>
<span id="more"></span>
<p>更新一下</p>
<p>搜了一下nginx重定向，找到一段有用的代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"> listen 80 default_server;</span><br><span class="line"> server_name  www.lansgg.com lansgg.com;</span><br><span class="line"> access_log  logs/lansgg.access.log main;</span><br><span class="line"> error_log  logs/lansgg.error.log;</span><br><span class="line"> root   /opt/nginx/nginx/html/lansgg;</span><br><span class="line"> index index.html;</span><br><span class="line"> if ($http_host = www.lansgg.com)&#123;</span><br><span class="line"> rewrite (.*) http://www.Aries.com;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>改完之后:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name blog.ruomu.cc;</span><br><span class="line">    # access_log  logs/lansgg.access.log main;</span><br><span class="line">    # error_log  logs/lansgg.error.log;</span><br><span class="line">    # root   /opt/nginx/nginx/html/lansgg;</span><br><span class="line">    # index index.html;</span><br><span class="line">    if ($http_host = blog.ruomu.cc)&#123;</span><br><span class="line">        # rewrite (.*) https://ruomuc.gitee.io/blog/;</span><br><span class="line">        # rewrite ^/(.*)$ https://ruomuc.gitee.io/blog/ permanent;</span><br><span class="line">        # rewrite ^/(.*)$ https://ruomuc.gitee.io/blog/ break;</span><br><span class="line">        rewrite ^/(.*)$ https://ruomuc.gitee.io/blog/  last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释掉的都是我感觉没用的。。。其实无所谓，无非是打打日志，默认页面之类的。<br>关键是下面的那个rewrite，配置完之后，访问blog.ruomu.cc就可以跳转到我的博客页面了，码云的pages服务绑定域名是要收费的。。</p>
<p>不过我这样的坏处是，跳转之后显示的是博客的URL而不是你输入的，我试着设置了重定向的flag: permanent 、break 、 last 都不可以。。不知道是码云机制还是怎么回事。<br>然后我看到一个回答，我觉得应该是这个原因：</p>
<blockquote>
<p>像如<br>rewrite ^/abc$ <a href="http://www.ppp.com:8080/aaa">http://www.ppp.com:8080/aaa</a> last;<br>的这种跳转规则，作如下的解释：<br>如果rewrite指令的第二个参数（replacement）以http或者以https开头，则nginx内部会将该跳转作为临时重定向去处理，表现到http的响应就是会以302响应状态作为响应。<br>以302,301等的重定向肯定会修改地址栏的url。这个是没办法改变的。<br>如果不想改变地址栏的url，那可以考虑使用内部跳转：rewrite “/xxx” /abc last;的这种跳转形式。<br>但是这种重定向只能对站内的url进行重写。</p>
</blockquote>
<p>他说URL不变只能对内战进行重写。。当人了人家码云99RMB/Y 的羊毛说薅就薅？ 对吧，反正基本目的已经实现了，再也不用记那个gitee.io什么的URL了。</p>
]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>linux</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>关于js的几种路径写法</title>
    <url>/2018/08/30/%E5%85%B3%E4%BA%8E%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>Node.js中的文件路径大概有 __dirname, __filename, process.cwd(), ./ 或者 ../，前三个都是绝对路径。<br>关于这几个路径的意思:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__dirname：    获得当前执行文件所在目录的完整目录名</span><br><span class="line">__filename：   获得当前执行文件的带有完整绝对路径的文件名</span><br><span class="line">process.cwd()：获得当前执行node命令时候的文件夹目录名 </span><br><span class="line">./：           文件所在目录</span><br></pre></td></tr></table></figure>
<p>我在桌面的一个新建文件夹里新建了如下目录:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">新建文件夹/</span><br><span class="line"> -dir</span><br><span class="line">  -dir1</span><br><span class="line">   -path.js</span><br><span class="line">  -dir2</span><br></pre></td></tr></table></figure>
<p>path.js里有如下代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;__dirname：&#x27;</span>, __dirname)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;__filename：&#x27;</span>, __filename)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;process.cwd()：&#x27;</span>, process.<span class="title function_">cwd</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;./：&#x27;</span>, path.<span class="title function_">resolve</span>(<span class="string">&#x27;./&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过cd命令到 C:\Users\Administrator\Desktop\新建文件夹\dir\dir1 目录下,执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node path.js  或 node ./path.js</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__dirname： C:\Users\Administrator\Desktop\新建文件夹\dir\dir1</span><br><span class="line">__filename： C:\Users\Administrator\Desktop\新建文件夹\dir\dir1\path.js</span><br><span class="line">process.cwd()： C:\Users\Administrator\Desktop\新建文件夹\dir\dir1</span><br><span class="line">./： C:\Users\Administrator\Desktop\新建文件夹\dir\dir1</span><br></pre></td></tr></table></figure>
<p>根据这几个路径的含义，这个执行结果是完全正确的。<br>然后我们cd到 dir目录下执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node dir1/path.js</span><br></pre></td></tr></table></figure>
<p>结果为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__dirname： C:\Users\Administrator\Desktop\新建文件夹\dir\dir1</span><br><span class="line">__filename： C:\Users\Administrator\Desktop\新建文件夹\dir\dir1\path.js</span><br><span class="line">process.cwd()： C:\Users\Administrator\Desktop\新建文件夹\dir</span><br><span class="line">./： C:\Users\Administrator\Desktop\新建文件夹\dir</span><br></pre></td></tr></table></figure>
<p>这样看的话感觉<code>./</code>和<code>process.cwd()</code>是一样的，都指向的是运行node命令是的目录。<br><font color = red> 但是呢，如果是在require(‘./xx.js’)时，这个<code>./</code>指的就不再是node命令的执行路径了，而是以其文件的相对路径 </font><br>具体还可以查看require的引用规则：<a href="http://www.ruanyifeng.com/blog/2015/05/require.html">require源码解读（阮一峰）</a></p>
]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Koa入门(一)</title>
    <url>/2018/08/26/Koa%E5%85%A5%E9%97%A8(%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="koa的安装"><a href="#koa的安装" class="headerlink" title="koa的安装"></a>koa的安装</h2><p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm init </span><br><span class="line">npm install koa </span><br></pre></td></tr></table></figure>
<h2 id="第一个hello-world"><a href="#第一个hello-world" class="headerlink" title="第一个hello world"></a>第一个hello world</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(ctx.<span class="property">request</span>,ctx.<span class="property">response</span>);</span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">&#x27;hello world!&#x27;</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server is listen on 3000&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>控制台结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">λ node koatest2.js</span><br><span class="line">server is listen on 3000</span><br></pre></td></tr></table></figure>
<p>浏览器输入127.0.0.1:3000：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world!</span><br></pre></td></tr></table></figure>
<p>ps: <code>var Koa = require(&#39;koa&#39;);</code> 如果<code>K</code>是大写就是koa2，小写就是koa，详细差异自己百度啦。</p>
<h2 id="Koa中间件的级联"><a href="#Koa中间件的级联" class="headerlink" title="Koa中间件的级联"></a>Koa中间件的级联</h2><p>洋葱模型：</p>
<span id="more"></span>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/yangcongmoxing.png"></p>
<p>比如下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//X-response-time </span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">	<span class="comment">//（1）</span></span><br><span class="line">    <span class="keyword">var</span> start = <span class="keyword">new</span> <span class="title class_">Date</span>;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    <span class="comment">//（5）</span></span><br><span class="line">    <span class="keyword">var</span> ms = <span class="keyword">new</span> <span class="title class_">Date</span> - start;</span><br><span class="line">    ctx.<span class="title function_">set</span>(<span class="string">&#x27;X-Response-Time&#x27;</span>, <span class="number">10</span> + <span class="string">&#x27;ms&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//logger </span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">	<span class="comment">//（2）</span></span><br><span class="line">    <span class="keyword">var</span> start = <span class="keyword">new</span> <span class="title class_">Date</span>;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    <span class="comment">//（4）</span></span><br><span class="line">    <span class="keyword">var</span> ms = <span class="keyword">new</span> <span class="title class_">Date</span> - start;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;%s %s - %s&#x27;</span>, ctx.<span class="property">method</span>, ctx.<span class="property">url</span>, ms);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//response</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">	<span class="comment">//（3）</span></span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server is listen on 3000&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">λ node koatest2.js</span><br><span class="line">server is listen on 3000</span><br><span class="line">GET / - 2</span><br><span class="line">GET /favicon.ico - 1</span><br></pre></td></tr></table></figure>
<p>执行顺序如图中：(1)-&gt;(2)-&gt;(3)-&gt;(4)-&gt;(5)。</p>
<h2 id="关于async和await"><a href="#关于async和await" class="headerlink" title="关于async和await"></a>关于async和await</h2><p>不说其他的异步写法，单说这个async的写法，我的个人理解是:<br>比如有这样一段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//通过id获取信息</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getInfoById</span>(<span class="params">id,callback</span>)&#123;</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">	<span class="title function_">callback</span>(info);<span class="comment">//一系列操作返回用户信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过信息获取姓名</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUserNameByInfo</span>(<span class="params">info,callback</span>)&#123;</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">	<span class="title function_">callback</span>(name); <span class="comment">//一系列操作之后返回了一个name</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是如果我有一个id要获取name就要这么做</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUserNameById</span>(<span class="params">id</span>)&#123;</span><br><span class="line">	<span class="title function_">getInfoById</span>(id,<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(data)&#123; </span><br><span class="line">			<span class="keyword">var</span> info = data; <span class="comment">//data =&gt; info</span></span><br><span class="line">			<span class="title function_">getUserNameByInfo</span>(info,<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(data)&#123;</span><br><span class="line">					<span class="keyword">var</span> name = data; <span class="comment">// data=&gt;name</span></span><br><span class="line">					<span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">//用户姓名</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面这种就是最常规的js异步回调函数，因为下一个函数的参数依赖于上一个函数的执行结果，如果不写成回调，就会报错，说值为undefined等。<br>然后es7引入新语法，注意是es7规范。node v8以上才支持，低版本v7有其他方式支持，但是现在的新版node.js是天然支持的，很好用！！！<br>比如上面那段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过id获取信息</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getInfoById</span>(<span class="params">id,callback</span>)&#123;</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">	<span class="title function_">callback</span>(info);<span class="comment">//一系列操作返回用户信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过信息获取姓名</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUserNameByInfo</span>(<span class="params">info,callback</span>)&#123;</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">	<span class="title function_">callback</span>(name); <span class="comment">//一系列操作之后返回了一个name</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是如果我有一个id要获取name就要这么做</span></span><br><span class="line">aync <span class="keyword">function</span> <span class="title function_">getUserNameById</span>(<span class="params">id</span>)&#123; </span><br><span class="line">	<span class="keyword">let</span> info = <span class="keyword">await</span> <span class="title function_">getInfoById</span>(id);</span><br><span class="line">	<span class="keyword">let</span> name = <span class="keyword">await</span> <span class="title function_">getUserNameByInfo</span>(info);</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简直惊呆了有木有！谁他喵的还写回调地狱哦。<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/huidiaodiyu.jpg" alt="回调地狱了解一下"></p>
<p>上面那种写法要注意：</p>
<ul>
<li>async 卸载function前面代表这是一个异步函数</li>
<li>await只有在异步函数里面才可以使用，不然会报错的哦</li>
<li>暂时不知道了，想到了再补充…</li>
</ul>
<p>PS：其实koa我用别人的demo都搭了一个<a href="http://www.ruomu.cc/">主页</a>了，只不过不太好看，并且是前后端一起写的，很乱。。有时间了换一个，然后再系统的看一下这个框架，学新不学旧嘛。。况且express的话我做项目也有接触到。基数大但是总是要被迭代掉的吧。</p>
]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title>npm install</title>
    <url>/2018/08/23/npm%20install/</url>
    <content><![CDATA[<h2 id="npm的几种install的区别"><a href="#npm的几种install的区别" class="headerlink" title="npm的几种install的区别"></a>npm的几种install的区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install moduleName # 安装模块到项目目录下</span><br><span class="line"></span><br><span class="line">npm install -g moduleName # -g 的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 npm config prefix 的位置。</span><br><span class="line"></span><br><span class="line">npm install -save moduleName # -save 的意思是将模块安装到项目目录下，并在package文件的dependencies节点写入依赖。</span><br><span class="line"></span><br><span class="line">npm install -save-dev moduleName # -save-dev 的意思是将模块安装到项目目录下，并在package文件的devDependencies节点写入依赖。</span><br></pre></td></tr></table></figure>
<p>那么问题来了，在项目中我们应该使用四个命令中的哪个呢？这个就要视情况而定了。下面对这四个命令进行对比，看完后你就不再这么问了。</p>
<h2 id="npm-install-moduleName-命令"><a href="#npm-install-moduleName-命令" class="headerlink" title="npm install moduleName 命令"></a>npm install moduleName 命令</h2><ol>
<li>安装模块到项目node_modules目录下。</li>
<li>不会将模块依赖写入devDependencies或dependencies 节点。</li>
<li>运行 npm install 初始化项目时不会下载模块。</li>
</ol>
<h2 id="npm-install-g-moduleName-命令"><a href="#npm-install-g-moduleName-命令" class="headerlink" title="npm install -g moduleName 命令"></a>npm install -g moduleName 命令</h2><ol>
<li>安装模块到全局，不会在项目node_modules目录中保存模块包。</li>
<li>不会将模块依赖写入devDependencies或dependencies 节点。</li>
<li>运行 npm install 初始化项目时不会下载模块。</li>
</ol>
<h2 id="npm-install-save-moduleName-命令"><a href="#npm-install-save-moduleName-命令" class="headerlink" title="npm install -save moduleName 命令"></a>npm install -save moduleName 命令</h2><ol>
<li>安装模块到项目node_modules目录下。</li>
<li>会将模块依赖写入dependencies 节点。</li>
<li>运行 npm install 初始化项目时，会将模块下载到项目目录下。</li>
<li>运行npm install –production或者注明NODE_ENV变量值为production时，会自动下载模块到node_modules目录中。</li>
</ol>
<h2 id="npm-install-save-dev-moduleName-命令"><a href="#npm-install-save-dev-moduleName-命令" class="headerlink" title="npm install -save-dev moduleName 命令"></a>npm install -save-dev moduleName 命令</h2><ol>
<li>安装模块到项目node_modules目录下。</li>
<li>会将模块依赖写入devDependencies 节点。</li>
<li>运行 npm install 初始化项目时，会将模块下载到项目目录下。</li>
<li>运行npm install –production或者注明NODE_ENV变量值为production时，不会自动下载模块到node_modules目录中。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>devDependencies 节点下的模块是我们在开发时需要用的，比如项目中使用的 gulp ，压缩css、js的模块。这些模块在我们的项目部署后是不需要的，所以我们可以使用 -save-dev 的形式安装。像 express 这些模块是项目运行必备的，应该安装在 dependencies 节点下，所以我们应该使用 -save 的形式安装。</p>
]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用命令记录</title>
    <url>/2018/08/15/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h5 id="平常常用的linux命令，持续更新。。主要是centos6-7，有差异。"><a href="#平常常用的linux命令，持续更新。。主要是centos6-7，有差异。" class="headerlink" title="平常常用的linux命令，持续更新。。主要是centos6/7，有差异。"></a>平常常用的linux命令，持续更新。。主要是centos6/7，有差异。</h5><p>查看系统版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br><span class="line">cat /proc/version</span><br><span class="line">cat /etc/issue</span><br></pre></td></tr></table></figure>

<p>查看64位还是32位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getconf LONG_BIT</span><br><span class="line">file /bin/ls</span><br></pre></td></tr></table></figure>

<p>查看相关进程状态(node)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef | grep node</span><br></pre></td></tr></table></figure>
<p>查询端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -tulpn</span><br></pre></td></tr></table></figure>
<p>根据端口号得到其占用的进程的详细信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -tlnp|grep 80</span><br></pre></td></tr></table></figure>
<p>一次性的清除占用80端口的程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsof -i :80|grep -v &quot;PID&quot;|awk &#x27;&#123;print &quot;kill -9&quot;,$2&#125;&#x27;|sh</span><br></pre></td></tr></table></figure>
<p>手工终止进程的运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -9 PID</span><br></pre></td></tr></table></figure>
<p>开启端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br></pre></td></tr></table></figure>
<p>防火墙设置 centos 7</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start firewalld 开启防火墙</span><br><span class="line">systemctl stop firewalld 关闭防火墙</span><br><span class="line">firewall-cmd --reload #重启firewall</span><br><span class="line">systemctl stop firewalld.service #停止firewall</span><br><span class="line">systemctl disable firewalld.service #禁止firewall开机启动</span><br></pre></td></tr></table></figure>




<p>————————————分割线 2018/8/23 22:39 ————————————————————–</p>
<h2 id="svn安装"><a href="#svn安装" class="headerlink" title="svn安装"></a>svn安装</h2><h6 id="安装svn"><a href="#安装svn" class="headerlink" title="安装svn"></a>安装svn</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install subversion</span><br></pre></td></tr></table></figure>
<h6 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn checkout(co) address</span><br></pre></td></tr></table></figure>
<h6 id="解决SVN-E210007无法协商认证机制"><a href="#解决SVN-E210007无法协商认证机制" class="headerlink" title="解决SVN:E210007无法协商认证机制"></a>解决SVN:E210007无法协商认证机制</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install cyrus-sasl cyrus-sasl-plain cyrus-sasl-ldap</span><br></pre></td></tr></table></figure>
<h6 id="继续下载"><a href="#继续下载" class="headerlink" title="继续下载"></a>继续下载</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn checkout(co) address</span><br></pre></td></tr></table></figure>
<h2 id="svn-ignore"><a href="#svn-ignore" class="headerlink" title="svn ignore"></a>svn ignore</h2><h6 id="要忽略具有结尾-o的所有文件，请使用："><a href="#要忽略具有结尾-o的所有文件，请使用：" class="headerlink" title="要忽略具有结尾.o的所有文件，请使用："></a>要忽略具有结尾.o的所有文件，请使用：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn propset svn:ignore &quot;*.o&quot; .</span><br></pre></td></tr></table></figure>
<h6 id="如果你想忽略文件夹tmp"><a href="#如果你想忽略文件夹tmp" class="headerlink" title="如果你想忽略文件夹tmp"></a>如果你想忽略文件夹tmp</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn propset svn:ignore tmp .</span><br></pre></td></tr></table></figure>
<h6 id="如果你想忽略tmp，obj，bin-dirs和所有带-o-lib，-。la扩展名的文件。保存此文件"><a href="#如果你想忽略tmp，obj，bin-dirs和所有带-o-lib，-。la扩展名的文件。保存此文件" class="headerlink" title="如果你想忽略tmp，obj，bin dirs和所有带* .o * .lib，*。la扩展名的文件。保存此文件"></a>如果你想忽略tmp，obj，bin dirs和所有带* .o * .lib，*。la扩展名的文件。保存此文件</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tmp</span><br><span class="line">obj</span><br><span class="line">bin</span><br><span class="line">*.o</span><br><span class="line">*.lib</span><br><span class="line">*.la</span><br></pre></td></tr></table></figure>
<h6 id="并将其命名为svnignore-txt，以下命令将完成这项工作！"><a href="#并将其命名为svnignore-txt，以下命令将完成这项工作！" class="headerlink" title="并将其命名为svnignore.txt，以下命令将完成这项工作！"></a>并将其命名为svnignore.txt，以下命令将完成这项工作！</h6><span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn propset svn:ignore -F svnignore.txt .</span><br></pre></td></tr></table></figure>
<h6 id="通过命令行忽略多个文件-目录"><a href="#通过命令行忽略多个文件-目录" class="headerlink" title="通过命令行忽略多个文件/目录"></a>通过命令行忽略多个文件/目录</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn propedit svn:ignore .</span><br></pre></td></tr></table></figure>
<p>这将显示要忽略的文件或目录列表。</p>
<h6 id="查找不受版本控制的文件"><a href="#查找不受版本控制的文件" class="headerlink" title="查找不受版本控制的文件"></a>查找不受版本控制的文件</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">svn status | grep ^\? | awk &#x27;&#123;print $2&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="centos7-firewall"><a href="#centos7-firewall" class="headerlink" title="centos7 firewall"></a>centos7 firewall</h2><h6 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br></pre></td></tr></table></figure>
<h6 id="重启防火墙："><a href="#重启防火墙：" class="headerlink" title="重启防火墙："></a>重启防火墙：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart firewalld.service </span><br></pre></td></tr></table></figure>
<h6 id="关闭防火墙："><a href="#关闭防火墙：" class="headerlink" title="关闭防火墙："></a>关闭防火墙：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service </span><br></pre></td></tr></table></figure>
<h6 id="查看监听-Listen-的端口"><a href="#查看监听-Listen-的端口" class="headerlink" title="查看监听(Listen)的端口"></a>查看监听(Listen)的端口</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -lntp</span><br></pre></td></tr></table></figure>
<h6 id="检查端口被哪个进程占用"><a href="#检查端口被哪个进程占用" class="headerlink" title="检查端口被哪个进程占用"></a>检查端口被哪个进程占用</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -lnp|grep 8080</span><br></pre></td></tr></table></figure>
<h6 id="查看node相关的进程"><a href="#查看node相关的进程" class="headerlink" title="查看node相关的进程"></a>查看node相关的进程</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef | grep node</span><br></pre></td></tr></table></figure>
<h2 id="服务systemctl"><a href="#服务systemctl" class="headerlink" title="服务systemctl"></a>服务systemctl</h2><h6 id="查看服务状态"><a href="#查看服务状态" class="headerlink" title="查看服务状态"></a>查看服务状态</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl status *</span><br></pre></td></tr></table></figure>
<h6 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start *</span><br></pre></td></tr></table></figure>
<h6 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart *</span><br></pre></td></tr></table></figure>
<h6 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop *</span><br></pre></td></tr></table></figure>
<h6 id="重启也会生效"><a href="#重启也会生效" class="headerlink" title="重启也会生效"></a>重启也会生效</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable *</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>计算机网络与操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Buffer</title>
    <url>/2018/08/15/%E5%85%B3%E4%BA%8EBuffer/</url>
    <content><![CDATA[<h2 id="Buffer结构"><a href="#Buffer结构" class="headerlink" title="Buffer结构"></a>Buffer结构</h2><h4 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h4><p>1.一个很像Array的对象。</p>
<p>2.Buffer是典型的js和c++结合的模块，性能部分由c++实现，非性能相关由js实现。</p>
<p>3.Buffer所占用的内存不是V8分配的，属于堆外内存。并且在nodejs启动时加载，并放在global上，无需require()就可以直接使用</p>
<h4 id="Buffer对象"><a href="#Buffer对象" class="headerlink" title="Buffer对象"></a>Buffer对象</h4><p>Buffer对象类似于数组，元素为16进制的两位数，即十进制的0~255。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;深入浅出node.js&quot;;</span><br><span class="line">var buf = new Buffer(str,&#x27;utf-8&#x27;);</span><br><span class="line">console.log(buf);</span><br><span class="line">//=&gt; &lt;Buffer e6 b7 b1 e5 85 a5 e6 b5 85 e5 87 ba 6e 6f 64 65 2e 6a 73&gt;</span><br></pre></td></tr></table></figure>
<p>中文字utf-8下站三个元素，字母和半角标点符号站一个元素。<br>Buffer可以通过length来获取长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var buf = new Buffer(100);</span><br><span class="line">console.log(buf.length);</span><br><span class="line">// =&gt; 100</span><br></pre></td></tr></table></figure>
<p>以上代码初始化了一个长度为100字节的Buffer对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(buf[10]);</span><br><span class="line">// =&gt; 0</span><br></pre></td></tr></table></figure>
<p>以上代码可以打印出下标为10的元素值，但是buf对象是初始化并没有赋值，所以结果为0。这里和朴大书里说的有些出入，朴大会输出一个0~255的随机值，但是我试验过一直都是0。所以我选择相信自己。。。</p>
<p>赋值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buf[10] = 100; // =&gt; 100</span><br><span class="line">buf[10] = -100; // +256直到得到一个0~255的数  =&gt; 156</span><br><span class="line">buf[10] = 300; // -256直到得到一个0~255的数 =&gt; 44</span><br><span class="line">buf[10] = 3.14 // 去掉小数，再遵循以上规则 =&gt; 3</span><br><span class="line">console.log(buf[10])</span><br></pre></td></tr></table></figure>

<h4 id="Buffer内存分配"><a href="#Buffer内存分配" class="headerlink" title="Buffer内存分配"></a>Buffer内存分配</h4><p>Buffer对象的内存分配不是在V8的堆内存中，是在node的C++层面实现申请的。为此采用的是，在C++层面申请内存，在JavaScript中分配内存的策略。</p>
<p>Node采用<a href="https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/index.html">slab</a>分配机制，简而言之，slab就是一块申请好的固定大小的内存区域，并具有三种状态：</p>
<ul>
<li>full：完全分配状态。</li>
<li>partial：部分分配状态。</li>
<li>empty：没有被分配状态。</li>
</ul>
<p>当我们<code>new Buffer(size)</code>时：<br>Node以<strong>8KB</strong>为界限来区别Buffer是大对象还是小对象<code>Buffer.poolSize = 8 * 1024</code>。<br>这个<strong>8KB</strong>的值也就是每个slab的大小值，在JavaScript层面中，以它作为单位单元进行内存分配。</p>
<p>ps:1kb = 1024 byte = 8 bit = 1111 1111 = 255</p>
<p>申请一个新的slab单元：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pool;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">allocPool</span>(<span class="params"></span>)&#123;</span><br><span class="line">	pool = <span class="keyword">new</span> <span class="title class_">SlowBuffer</span>(<span class="title class_">Buffer</span>.<span class="property">poolSize</span>);</span><br><span class="line">	pool.<span class="property">use</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处于empty状态</span></span><br></pre></td></tr></table></figure>
<p>1.如果指定Buffer大小少于8KB：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Buffer</span>(<span class="number">1024</span>);</span><br><span class="line"><span class="comment">//检查pool对象，是否被创建。如果没有则创建一个新的slab单元指向它：</span></span><br><span class="line"><span class="keyword">if</span>(!pool || pool.<span class="property">length</span> - pool.<span class="property">used</span> &lt; <span class="variable language_">this</span>.<span class="property">length</span>)&#123;</span><br><span class="line">	<span class="title function_">allocPool</span>();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>同时：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">parent</span> = pool; <span class="comment">//当前Buffer对象的parent属性指向pool</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">offset</span> = pool.<span class="property">used</span>; <span class="comment">//记录从这个slab的哪个地方开始使用</span></span><br><span class="line">pool.<span class="property">used</span> += <span class="variable language_">this</span>.<span class="property">length</span>; <span class="comment">//记录自身被使用了多少字节</span></span><br><span class="line"><span class="keyword">if</span>（pool.<span class="property">used</span> &amp; <span class="number">7</span>)&#123;</span><br><span class="line">pool.<span class="property">used</span> = (pool.<span class="property">used</span> + <span class="number">8</span> ) &amp; ~<span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种分配方式可能导致1KB的Buffer占用了8KB的内存（1个slab）;</p>
<p>2.分配大小超过8KB的Buffer对象。<br>将会直接分配一个SlowBuffer对象作为slab单元，这个slab单元会被这个Buffer独占。这时slab的大小应该就是Buffer的大小吧。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.parent = new SlowBuffer(this.length);</span><br><span class="line">this.offset = 0;</span><br></pre></td></tr></table></figure>
<p>这个SlowBuffer类是C++中定义的，虽然引用buffer模块可以访问，但不推荐直接操作。<br>上面提到的Buffer对象都是JavaScript层面的，能被V8标记回收，但是其内部的parent属性指向的SlowBuffer对象却来自于Node自身C++中的定义，是C++层面上的Buffer对象，所以内存不在V8的堆中。</p>
<span id="more"></span>
<h4 id="Buffer转换"><a href="#Buffer转换" class="headerlink" title="Buffer转换"></a>Buffer转换</h4><p>BUffer目前支持转换的字符串编码类型:</p>
<ul>
<li>ASCII</li>
<li>UTF-8</li>
<li>UTF-16LE/UCS-2</li>
<li>Base64</li>
<li>Binary</li>
<li>Hex</li>
</ul>
<p>1.字符串转Buffer<br>encoding不传值时，默认按UTF-8编码进行转码和存储。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new Buffer(str,[encoding]);</span><br></pre></td></tr></table></figure>
<p>buf.write可以指定写入起始位置，长度和编码，所以一个Buffer中可以有多种编码类型，这样反转回字符串的时候需要谨慎处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buf.write(strig,[offset],[length],encoding);</span><br></pre></td></tr></table></figure>
<p>还可以toString();</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buf.toString([encoding,start,end]);</span><br></pre></td></tr></table></figure>
<p>2.有些Buffer不支持的编码类型<br>判断编码是否支持转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Buffer.isEncoding(encoding);</span><br></pre></td></tr></table></figure>
<p>对不支持的编码类型可以借助模块完成转换。<br>iconv和iconv-lite</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iconv = <span class="built_in">require</span>(<span class="string">&#x27;iconv-lite&#x27;</span>);</span><br><span class="line"><span class="comment">//Buffer转字符串</span></span><br><span class="line"><span class="keyword">var</span> str = iconv.<span class="title function_">decode</span>(buf,<span class="string">&#x27;win1251&#x27;</span>);</span><br><span class="line"><span class="comment">//字符串转Buffer</span></span><br><span class="line"><span class="keyword">var</span> buf = iconv.<span class="title function_">encode</span>(str,<span class="string">&#x27;win1251&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>具体可以去查阅 <a href="https://www.npmjs.com/package/iconv-lite">https://www.npmjs.com/package/iconv-lite</a><br>            <a href="https://www.npmjs.com/package/iconv">https://www.npmjs.com/package/iconv</a></p>
<h4 id="Buffer的拼接"><a href="#Buffer的拼接" class="headerlink" title="Buffer的拼接"></a>Buffer的拼接</h4><p>buffer通常是以一段一段的方式传输在内存中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;test.md&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>,<span class="keyword">function</span>(<span class="params">chunk</span>)&#123;</span><br><span class="line">	data+=chunk;</span><br><span class="line">&#125;);</span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码在国外没有宽字节编码时没有问题，但是遇到宽字节会导致乱码。<br>问题来自于这句代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data += chunk;</span><br><span class="line">等价于</span><br><span class="line">data = data.<span class="title function_">toString</span>() += chunk.<span class="title function_">toString</span>();</span><br></pre></td></tr></table></figure>

<p>复现问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;test.md&#x27;</span>,&#123;<span class="attr">highWaterMark</span>:<span class="number">11</span>&#125;);</span><br><span class="line"><span class="comment">//test.md 是李白的静夜思。。。。</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>,<span class="keyword">function</span>(<span class="params">chunk</span>)&#123;</span><br><span class="line">	data+=chunk;</span><br><span class="line">&#125;);</span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// =&gt; 床前明��光，疑���地上霜。举头��明月，���头思故乡。</span></span><br></pre></td></tr></table></figure>
<p>为什么乱码呢。。。。<br>让我们看下这首诗的原本的Buffer</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Buffer e5 ba 8a e5 89 8d e6 98 8e e6 9c 88 e5 85 89 ef bc 8c e7 96 91 e6 98 af e5 9c b0 e4 b8 8a e9 9c 9c e3 80 82 e4 b8 be e5 a4 b4 e6 9c 9b e6 98 8e e6 9c ... &gt;</span><br></pre></td></tr></table></figure>
<p>我们限定了Buffer对象的长度为11，所以<code>e5 ba 8a | e5 89 8d |e6 98 8e | e6 9c</code>,床前明三个字之后就匹配不到了，剩下两个字节就以乱码的形式显示了。</p>
<p>解决方案一:<br>setEncoding();</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;test.md&#x27;</span>,&#123;<span class="attr">highWaterMark</span>:<span class="number">11</span>&#125;);</span><br><span class="line">rs.<span class="title function_">setEncoding</span>(<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"><span class="comment">//test.md 是李白的静夜思。。。。</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>,<span class="keyword">function</span>(<span class="params">chunk</span>)&#123;</span><br><span class="line">	data+=chunk;</span><br><span class="line">&#125;);</span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// =&gt; 床前明月光，疑是地上霜。举头望明月，低头思故乡。</span></span><br></pre></td></tr></table></figure>
<p>这种方式的data收到的不再是Buffer对象，所以问题解决了，但是字节字符的问题依然存在，并且setEncoding，但是只支持 UTF-16LE/UCS-2 、 utf-8和base64三种编码。</p>
<p>解决方法二：<br>正确的Buffer拼接：<br>正确的拼接方式时，使用一个数组来存储接收到的所有buffer对象，并记录所有片段的总长度，然后调用Buffer.concat()来生成一个合并的Buffer对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> chunks = [];</span><br><span class="line"><span class="keyword">var</span> size = <span class="number">0</span>;</span><br><span class="line">res.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>,<span class="keyword">function</span>(<span class="params">chunk</span>)&#123;</span><br><span class="line">	chunks.<span class="title function_">push</span>(chunk);</span><br><span class="line">	size += chunk.<span class="property">length</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">res.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(chunks,size);</span><br><span class="line">	<span class="keyword">var</span> str = iconv.<span class="title function_">decode</span>(buf,<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>本问题复现代码github地址：<a href="https://github.com/ruomuc/practice/tree/master/other/buffer">https://github.com/ruomuc/practice/tree/master/other/buffer</a></p>
<p>Buffer.concat实现原理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Buffer.concat() = function(list, length) &#123;</span><br><span class="line">	if (!Array.isArray(list)) &#123;</span><br><span class="line">		throw new Error(&#x27;Usage: Buffer.concat(list,[length])&#x27;);</span><br><span class="line">	&#125;</span><br><span class="line">	if (list.length === 0) &#123;</span><br><span class="line">		return new Buffer(0);</span><br><span class="line">	&#125; else if (list.length === 1) &#123;</span><br><span class="line">		return list[0];</span><br><span class="line">	&#125;</span><br><span class="line">	if (typeof length !== &#x27;number&#x27;) &#123;</span><br><span class="line">		length = 0;</span><br><span class="line">		for (var i = 0; i &lt; list.length; i++) &#123;</span><br><span class="line">			var buf = list[i];</span><br><span class="line">			length += buf.length;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var buffer = new Buffer(length);</span><br><span class="line">	var pos = 0;</span><br><span class="line">	for (var i = 0; i &lt; list.length; i++) &#123;</span><br><span class="line">		var buf = list[i];</span><br><span class="line">		buf.copy(buffer, pos);</span><br><span class="line">		pos += buf.length;</span><br><span class="line">	&#125;</span><br><span class="line">	return buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>buffer</tag>
      </tags>
  </entry>
  <entry>
    <title>linux部署网站</title>
    <url>/2018/08/13/linux%E9%83%A8%E7%BD%B2%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><p>这个是真的难安，装了卸，卸了装。。。orz</p>
<p>1.cd /usr/local/src #定位到这个目录，下载的文件会在这个目录,版本号随着下载包的改变，最简单就是官网的linux安装包下载路径复制过来。不要问我为什么是user/local/src路径，因为别的路径环境变量配置不出来，搞了一下午。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://nodejs.org/dist/v6.9.4/node-v6.9.4-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>
<p>2.解压文件,版本号同理，就是刚下的安装包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar xvf node-v6.9.4-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>
<p>3.移动,别问我为什么，实验出真理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv node-v6.9.4-linux-x64 /usr/local/node</span><br></pre></td></tr></table></figure>
<p>4.重点：NODE环境配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line">#在最下面加入</span><br><span class="line">#node config </span><br><span class="line">export NODE_HOME=/usr/local/node</span><br><span class="line">export PATH=$PATH:$NODE_HOME/bin  </span><br><span class="line">export NODE_PATH=$NODE_HOME/lib/node_modules </span><br></pre></td></tr></table></figure>
<p>如果你不想用vi，那就用xftp也可以。<br>5.保存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:wq</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
<p>6.验证安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v </span><br><span class="line"></span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p>1.安装pm2管理工具<br>以下操作都是在linux环境下哦</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g pm2</span><br></pre></td></tr></table></figure>

<p>2.cd项目根目录，即app.js或index.js文件同级目录,先运行一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node app.js/index.js</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">npm start </span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">node ./bin/www</span><br></pre></td></tr></table></figure>
<p>具体哪一个自己本地做完项目心里会有数的，看你package.json里的设置。</p>
<p>3.如果这个时候服务器启动成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://ip:port</span><br></pre></td></tr></table></figure>
<p>4.如果访问不了请检车你的端口是否对外开放。<br>centos6</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -p tcp --dport 端口号 -j ACCEPT #开启</span><br><span class="line">service iptables save # 保存</span><br><span class="line">service iptables status  #查看</span><br></pre></td></tr></table></figure>
<p>centos7</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=3000/tcp --permanent #开启</span><br><span class="line">firewall-cmd --reload #重启</span><br><span class="line">firewall-cmd --list-all #查看</span><br></pre></td></tr></table></figure>
<p>你可以去找个端口扫描网站扫描一下。<br>5.上面都成功了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pm2 start ./bin/www</span><br></pre></td></tr></table></figure>
<p>这是我的项目启动命令，具体看配置，和你用啥脚手架生成的。<br>pm2详细操作命令请百度。</p>
<p>6.附上个人<a href="http://www.ruomu.cc/">主页</a>，目前是没有啥子交互，一个主页来跳转，毕竟域名太贵了。</p>
<h2 id="还有个域名解析端口的问题"><a href="#还有个域名解析端口的问题" class="headerlink" title="还有个域名解析端口的问题"></a>还有个域名解析端口的问题</h2><p>域名访问的好像默认是80端口，我的网站用的是3000端口，所以要个域名后面带带上：port，是在是太丑了，于是我只好改成了80，但是80端口只有一个，一个服务器不能就放一个网站吧，看了一下有什么url转发，反向代理什么的，下次在研究吧。。</p>
<br>
<hr>

<p>————————————-2018年11月9日 20:35:44—————————————————————</p>
<hr>

<p>更新一下mysql的安装，上面那个域名和端口的问题已经在另一篇博文解决了，见<a href="https://ruomuc.gitee.io/blog/2018/09/03/nginx+node-js%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84URL%E5%88%86%E5%8F%91/">nginx+node.js实现简单的URL分发</a>。</p>
<span id="more"></span>
<h2 id="linux安装mysql"><a href="#linux安装mysql" class="headerlink" title="linux安装mysql"></a>linux安装mysql</h2><p>1.找到mysql官网的mysql yum 存储库。<br><code>mysql80-community-release-el7-1.noarch.rpm</code>,就是这样一个东西。<br>2.连接上服务器，输入<br><code>wget -i -c http://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpm</code><br>3.然后可以使用yum安装<br><code>yum -y install mysql80-community-release-el7-1.noarch.rpm</code><br>4.安装mysql 服务器<br><code>yum -y install mysql-community-server</code></p>
<p>##mysql数据库配置<br>1.启动mysql<br><code>systemctl start  mysqld.service</code><br>2.查看mysql启动状态<br><code>systemctl status mysqld.service</code><br>如果看到一个绿色的active(running)就说明mysql启动成功。<br>3.找到mysql.log文件<br><code>cd /var/log/mysql.log</code><br>打开找到下面这一行：<br><code>A temporary password is generated for root@localhost: xxxxx</code>,<br>xxxxx就是密码。<br>4.登录<br><code>mysql -uroot -p</code></p>
<p>如果上述安装失败，你可以直接安，如果你有云源的话:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#yum install mysql</span><br><span class="line">#yum install mysql-server</span><br><span class="line">#yum install mysql-devel</span><br></pre></td></tr></table></figure>

<p>可能是我这个服务器有毒，<br>结合下面的资料：<a href="https://www.linuxidc.com/Linux/2018-08/153468.htm">https://www.linuxidc.com/Linux/2018-08/153468.htm</a><br><a href="https://blog.csdn.net/m0_37949684/article/details/77962377">https://blog.csdn.net/m0_37949684/article/details/77962377</a><br>才安好，折腾几个小时，orz。</p>
<p>然后还有个navicat无法连接远程数据库。<br><a href="https://blog.csdn.net/langyu1021/article/details/78900689">https://blog.csdn.net/langyu1021/article/details/78900689</a></p>
<p>因为查的资料太多了，有点复杂。学会用百度google安装这种东西慢慢踩坑，而且每次遇到的问题还不一样 。=.=！，中间rm -rf 搞错了删了一个系统文件夹，赶紧恢复快照重装，脑壳疼。</p>
<p>反正最后大功告成，吓得我赶紧保存个快照。</p>
<p>最后又遇到一个服务器会莫名其妙关闭我刚刚打开的端口号：<br>永久开启端口号：<br><code>firewall-cmd --permanent --zone=public --add-port=2888/tcp</code><br><code>firewall-cmd --reload  #重新载入服务</code></p>
]]></content>
      <categories>
        <category>计算机网络与操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>V8的垃圾回收机制和内存限制</title>
    <url>/2018/07/31/V8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6/</url>
    <content><![CDATA[<h2 id="内存限制"><a href="#内存限制" class="headerlink" title="内存限制"></a>内存限制</h2><p>在一般的后端开发语言，在基本的内存使用上是没有限制的。</p>
<p>主要是因为 Node 基于 V8构建，所以在 Node 中使用的 JavaScript 对象基本是通过 V8 自己的方式来分配和管理的。</p>
<p>V8 的内存管理机制在浏览器上使用是完全足够的，但是对服务端来讲，限制了开发者随心所欲使用内存的想法。</p>
<p>尽管我们很少的场景会使用到很大的内存，比如大文件的读取我们都可以通过 Stream 来完成，但 Node 还是提供了方法打开这个限制。</p>
<span id="more"></span>
<p><strong>默认内存大小</strong></p>
<ul>
<li>64位系统下，约为 1.4 GB</li>
<li>32位系统下，约为 0.7 GB</li>
</ul>
<p><strong>查询内存信息</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; memoryUsage &#125; <span class="keyword">from</span> <span class="string">&#x27;process&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">memoryUsage</span>())</span><br><span class="line"><span class="comment">// 打印:</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//  rss: 4935680,</span></span><br><span class="line"><span class="comment">//  heapTotal: 1826816,</span></span><br><span class="line"><span class="comment">//  heapUsed: 650472,</span></span><br><span class="line"><span class="comment">//  external: 49879,</span></span><br><span class="line"><span class="comment">//  arrayBuffers: 9386</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>heapTotal</code> 和 <code>heapUsed</code> 指的是 V8 的内存使用量。</li>
<li><code>external</code> 指的是绑定到 V8 管理的 JavaScript 对象的 C++ 对象的内存使用量。</li>
<li><code>rss</code>，常驻集大小，是进程在主内存设备（即总分配内存的子集）中占用的空间量，包括所有 C++ 和 JavaScript 对象和代码。</li>
<li><code>arrayBuffers</code> 是指为 <code>ArrayBuffer</code> 和 <code>SharedArrayBuffer</code> 分配的内存，包括所有 Node.js <a href="http://nodejs.cn/api/buffer.html"><code>Buffer</code></a>。 这也包含在 <code>external</code> 值中。 当 Node.js 被用作嵌入式库时，此值可能为 <code>0</code>，因为在这种情况下可能不会跟踪 <code>ArrayBuffer</code> 的分配。</li>
</ul>
<p><strong>修改内存限制</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">node  --max-old-space-size=<span class="number">1700</span> test.<span class="property">js</span> <span class="comment">// 单位是MB</span></span><br><span class="line">node  --max-<span class="keyword">new</span>-space-size=<span class="number">1024</span> test.<span class="property">js</span> <span class="comment">// 单位是KB</span></span><br></pre></td></tr></table></figure>

<p>修改新生代空间的参数好像改成了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">node --max-semi-space-size=<span class="number">1025</span> test.<span class="property">js</span></span><br></pre></td></tr></table></figure>

<p>可以使用：<code>node --v8-options | greap max</code> 来查看</p>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>V8 使用了内存分代的方式来管理内存。</p>
<p>新生代中的对象为存活时间较短的对象；而老生代中的对象为存活时间较长或常驻内存的对象。</p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/V8%E5%88%86%E4%BB%A3%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<h3 id="新生代空间"><a href="#新生代空间" class="headerlink" title="新生代空间"></a>新生代空间</h3><p>新生代空间主要使用 Scavenge  算法进行垃圾回收。在 Scavenge 的实现上 主要使用 Cheney 算法。</p>
<p>Scavenge 是一种复制算法，新生代空间会被一分为二划分成两个相等大小的 from-space 和 to-space。</p>
<p>它的工作方式是将 from space 中存活的对象复制出来，然后移动它们到 to space 中或者被提升到老生代空间中，对于 from space 中没有存活的对象将会被释放。完成这些复制后在将 from space 和 to space 进行互换。</p>
<p>缺点：</p>
<ul>
<li>只能使用堆内存的一半</li>
</ul>
<p>优点：</p>
<ul>
<li>由于新生代空间，大部分都是存活时间短的对象，所以只复制存活对象，效率比较高。</li>
</ul>
<h4 id="晋升"><a href="#晋升" class="headerlink" title="晋升"></a>晋升</h4><p>对象从新生代空间移动到老生代空间的过程称为<strong>晋升</strong>。</p>
<p>主要晋升条件有两个：</p>
<ul>
<li>对象是否经历过 Scavenge 回收</li>
<li>To 空间的内存占用比是否超过 25%</li>
</ul>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/新生代空间对象晋升流程.png"  />

<h3 id="老生代空间"><a href="#老生代空间" class="headerlink" title="老生代空间"></a>老生代空间</h3><p>老生代空间的对象，由于存活时间比较长，存活对象占较大比重。</p>
<p>所以无法采用Scavenge算法：</p>
<ul>
<li>存活对象多导致复制效率低</li>
<li>浪费一半内存，对于存活对象较多的老生代空间是无法接受的</li>
</ul>
<p>所以在老生代空间使用 Mark-Sweep 和 Mark-compact 相结合的方式进行垃圾回收</p>
<h4 id="Mark-Sweep"><a href="#Mark-Sweep" class="headerlink" title="Mark-Sweep"></a>Mark-Sweep</h4><p>标记清除算法分为标记和清除两个阶段。</p>
<p>Mark-Sweep在标记阶段遍历堆中所有对象，并标记或者的对象，在随后的清除阶段，只清除没有标记的对象。</p>
<p>该算法最大的问题是，在清除后，内存空间会出现不连续的状态，如果后续有一个大对象，那么这些碎片空间都无法完成这次分配，导致提前触发垃圾回收。</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/mark-sweep.png"  />

<h4 id="Mark-compact"><a href="#Mark-compact" class="headerlink" title="Mark-compact"></a>Mark-compact</h4><p>和Mark-Sweep的差别是，Mark-compact标记完成后，在整理过程中会将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/mark-compact.png"/>

<h3 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h3><p>stop-the-world，垃圾回收的三种基本算法，都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为全停顿（stop-the-world）</p>
<p>V8通过引入增量标记，来减少全停顿的时间</p>
<h2 id="垃圾回收机制性能优化"><a href="#垃圾回收机制性能优化" class="headerlink" title="垃圾回收机制性能优化"></a>垃圾回收机制性能优化</h2><h3 id="增量标记"><a href="#增量标记" class="headerlink" title="增量标记"></a>增量标记</h3><p>Incremental marking</p>
<p>为了降低全堆垃圾回收的停顿时间，增量标记将原本的标记全堆对象拆分为一个一个任务，让其穿插在JavaScript应用逻辑之间执行，它允许堆的标记时的5~10ms的停顿。</p>
<p>增量标记在堆的大小达到一定的阈值时启用，启用之后每当一定量的内存分配后，脚本的执行就会停顿并进行一次增量标记。</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/增量标记.png"/>

<h3 id="懒性清理"><a href="#懒性清理" class="headerlink" title="懒性清理"></a>懒性清理</h3><p>Lazy sweeping</p>
<p>增量标记只是对活动对象和非活动对象进行标记，惰性清理用来真正的清理释放内存。</p>
<p>当增量标记完成后，假如当前的可用内存足以让我们快速的执行代码，其实我们是没必要立即清理内存的，可以将清理的过程延迟一下，让JavaScript逻辑代码先执行，也无需一次性清理完所有非活动对象内存，垃圾回收器会按需逐一进行清理，直到所有的页都清理完毕。</p>
<p>增量标记与惰性清理的出现，使得主线程的<strong>最大停顿时间</strong>减少了80%</p>
<p><strong>缺点：</strong></p>
<ul>
<li>并没有减少主线程的总暂停的时间，甚至会略微增加</li>
<li>由于写屏障（Write-barrier）机制的成本，增量标记可能会降低应用程序的吞吐量</li>
</ul>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>Concurrent</p>
<p>并发式GC允许在在垃圾回收的同时不需要将主线程挂起，两者可以同时进行，只有在个别时候需要短暂停下来让垃圾回收器做一些特殊的操作。</p>
<p>但是这种方式也要面对增量回收的问题，就是在垃圾回收过程中，由于JavaScript代码在执行，堆中的对象的引用关系随时可能会变化，所以也要进行写屏障操作。</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/v8-gc-并发.png"/>

<h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>Parallel</p>
<p>并行式GC允许主线程和辅助线程同时执行同样的GC工作，这样可以让辅助线程来分担主线程的GC工作，使得垃圾回收所耗费的时间等于总时间除以参与的线程数量（加上一些同步开销）。</p>
<img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/v8-gc-并行.png"/>]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>异步控制之 Bagpipe</title>
    <url>/2018/07/30/%E5%BC%82%E6%AD%A5%E6%8E%A7%E5%88%B6%E4%B9%8B-Bagpipe/</url>
    <content><![CDATA[<h2 id="Bagpipe"><a href="#Bagpipe" class="headerlink" title="Bagpipe"></a>Bagpipe</h2><p>朴大的bagpipe感觉是比async的解决方案好用一些。<br>基本思路：</p>
<ul>
<li>通过队列来控制并发量。</li>
<li>如果当前队列活跃（调用发起但未执行回调）的异步调用量小于限定值，从队列中取出执行。</li>
<li>如果活跃调用达到限定值，调用暂时存放在队列中。</li>
<li>每个异步调用结束时，从队列中取出新的异步调用执行。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> <span class="title class_">Bagpipei</span> = <span class="built_in">require</span>(<span class="string">&#x27;bagpipe&#x27;</span>);</span><br><span class="line">	<span class="comment">//设置最大并发数为 10</span></span><br><span class="line">	<span class="keyword">var</span> bagpipe = <span class="keyword">new</span> <span class="title class_">Bagpipe</span>(<span class="number">10</span>,&#123;</span><br><span class="line">		<span class="attr">refuse</span>:<span class="literal">true</span>; <span class="comment">//拒绝模式</span></span><br><span class="line">		<span class="attr">timeout</span>:<span class="number">3000</span>; <span class="comment">//超时控制 超时时间为3000ms</span></span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="number">100</span>; ++i)&#123;</span><br><span class="line">		bagpipe.<span class="title function_">push</span>(<span class="keyword">async</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="string">``</span><span class="string">``</span></span><br><span class="line">- 拒绝模式下：如果等待的调用队列也满了之后，新来的调用就直接返回给它一个队列太忙的拒绝异常。</span><br><span class="line">- 超时模式下：异步操作没有在规定时间内完成，先返回给用户一个超时异常。</span><br><span class="line"></span><br><span class="line">&lt;hr&gt;</span><br><span class="line"></span><br><span class="line">当队列长度大于<span class="number">1</span>时，<span class="title class_">Bagpipe</span>对象将触发其full事件，该事件传递队列长度值。该值有助于评估业务绩效。</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">bagpipe.on(&#x27;full&#x27;,function(length)&#123;</span></span><br><span class="line"><span class="string">	console.log(&#x27;Button system cannot deal on time, queue jam, current queue length is:’+ length);</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2>不多说。。。</li>
</ul>
]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>异步编程之async、step。。</title>
    <url>/2018/07/30/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B9%8Basync%E3%80%81step%E3%80%82%E3%80%82/</url>
    <content><![CDATA[<p>异步的解决方案，主要了解一下async、step加上一个比较奇葩的wind应该足够了。实在不行还可以写恶魔金字塔嘛。</p>
<h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>安装引用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">&#x27;async&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>1.series()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.<span class="title function_">series</span>([</span><br><span class="line">	<span class="keyword">function</span>(<span class="params">callback</span>)&#123;</span><br><span class="line">		fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file1.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,callback);</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="keyword">function</span>(<span class="params">callback</span>)&#123;</span><br><span class="line">		fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file2.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,callback);</span><br><span class="line">	&#125;,</span><br><span class="line">],<span class="keyword">function</span>(<span class="params">err,results</span>)&#123;</span><br><span class="line">	<span class="comment">//results =&gt; [file1.txt,file2.txt]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码等价于</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file1.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,content</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(err)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">callback</span>(err);</span><br><span class="line">	&#125;</span><br><span class="line">	fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file2.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,data</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(err)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="title function_">callback</span>(err);	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="title function_">callback</span>(<span class="literal">null</span>,[content,data]);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>每个callback()执行时会将结果保存起来，然后执行下一个调用，直到结束所有调用，最终的回调函数执行时，队列里异步调用的结果会以数组的形式传入。<br>异常处理规则为，一旦发生异常，就结束所有调用，并将异常传递给最终回调函数的第一个参数。</p>
<hr>

<p>2.异步的并行执行 async.parallel()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.<span class="title function_">parallel</span>([</span><br><span class="line">	<span class="keyword">function</span>(<span class="params">callback</span>)&#123;</span><br><span class="line">		fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file1.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,callback);</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="keyword">function</span>(<span class="params">callback</span>)&#123;</span><br><span class="line">		fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file2.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,callback);</span><br><span class="line">	&#125;</span><br><span class="line">],<span class="keyword">function</span>(<span class="params">err,results</span>)&#123;</span><br><span class="line">	<span class="comment">//results =&gt; [file1.txt,file2.txt]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>parallel中，一旦产生异常，就会将异常作为第一个参数传入给最终的回调参数，只有所有异步调用都正常完成时，才会将结果以数组的方式传入。</p>
<hr>

<p>3.async.waterfall()<br>series()内的调用时不存在依赖关系的，当前一个的结果是后一个的输入时。要使用waterfall()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.<span class="title function_">waterfall</span>([</span><br><span class="line">	<span class="keyword">function</span>(<span class="params">callback</span>)&#123;</span><br><span class="line">		fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file1.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,content</span>)&#123;</span><br><span class="line">			<span class="title function_">callback</span>(err,content);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="keyword">function</span>(<span class="params">arg1,callback</span>)&#123;</span><br><span class="line">	    <span class="comment">//arg1 =&gt; file2.txt</span></span><br><span class="line">		fs.<span class="title function_">readFile</span>(arg1,<span class="string">&#x27;utf-8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,content</span>)&#123;</span><br><span class="line">			<span class="title function_">callback</span>(err,content);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="keyword">function</span>(<span class="params">arg1,callback</span>)&#123;</span><br><span class="line">		<span class="comment">//arg1 =&gt; file3.txt</span></span><br><span class="line">		fs.<span class="title function_">readFile</span>(arg1,<span class="string">&#x27;utf-8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,content</span>)&#123;</span><br><span class="line">			<span class="title function_">callback</span>(err,content);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">],<span class="keyword">function</span>(<span class="params">err,result</span>)&#123;</span><br><span class="line">	<span class="comment">//result =&gt; file4.txt</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
    
    
<p>4.async.auto()<br>自动依赖处理这里就不说了。。。</p>
<h2 id="Step"><a href="#Step" class="headerlink" title="Step"></a>Step</h2><p>它比async更加轻量，只有一个step接口</p>
<p>1.step(task1,task2,task3)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Step</span>(</span><br><span class="line">	funtion <span class="title function_">readFile1</span>(<span class="params"></span>)&#123;</span><br><span class="line">		fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file1.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="variable language_">this</span>);</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">readFile2</span>(<span class="params">err,content</span>)&#123;</span><br><span class="line">		fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file2.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="variable language_">this</span>);</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">done</span>(<span class="params">err,content</span>)&#123;</span><br><span class="line">		consolt.<span class="title function_">log</span>(content);</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>Step用到了this关键字，事实上，它是内部的一个next()方法，将异步调用的结果传递给下一个任务作为参数，并调用执行。当然传进来的参数可以不用，这样就是不依赖执行。</p>
<hr>

<p>2.Step的并行：this.parallel()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Step</span>(</span><br><span class="line">	funtion <span class="title function_">readFile1</span>(<span class="params"></span>)&#123;</span><br><span class="line">		fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file1.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="variable language_">this</span>.<span class="title function_">parallel</span>());</span><br><span class="line">		fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file2.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="variable language_">this</span>.<span class="title function_">parallel</span>());</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">done</span>(<span class="params">err,content1,content2</span>)&#123;</span><br><span class="line">		<span class="comment">//content1	=&gt; file1.txt</span></span><br><span class="line">		<span class="comment">//content2 =&gt; file2.txt</span></span><br><span class="line">	&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果异步方法结果传回的是多个参数，step将只会取前两个参数。好吧分组什么的就不收了，感觉还是promise和async好点。</p>
<h2 id="wind"><a href="#wind" class="headerlink" title="wind"></a>wind</h2><p>比较奇葩，不说了。</p>
]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>理解promise</title>
    <url>/2018/07/30/%E7%90%86%E8%A7%A3promise/</url>
    <content><![CDATA[<h2 id="promise的基本理解"><a href="#promise的基本理解" class="headerlink" title="promise的基本理解"></a>promise的基本理解</h2><ul>
<li>es6原生支持Promise对象</li>
<li>Promise 是一个容器，里面保存着某个未来才会结束的事件</li>
<li>Promise 对象不受外界影响，它代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）、rejected（已失败）。只有异步操作的结果能是状态发生改变。并且状态一旦改变就不能不能在变化。状态的改变只有两种可能：从pending——&gt;fulfilled/rejected。</li>
</ul>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  // ... some code</span><br><span class="line"></span><br><span class="line">  if (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h6 id="Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由-JavaScript-引擎提供，不用自己部署。"><a href="#Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由-JavaScript-引擎提供，不用自己部署。" class="headerlink" title="Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。"></a>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</h6><h6 id="resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从-pending-变为-resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从-pending-变为-rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。"><a href="#resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从-pending-变为-resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从-pending-变为-rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。" class="headerlink" title="resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。"></a>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</h6><h5 id="promise-then"><a href="#promise-then" class="headerlink" title="promise.then"></a>promise.then</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promise.then(function(value) &#123;</span><br><span class="line">  // success</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">  // failure</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>####### then有两个参数，第一个参数是成功时resolved调用，第二个参数是失败时rejected调用，第二个参数可选，他们的参数都是promise对象传出的值。</p>
<h5 id="一个promise-实现-ajax-的操作"><a href="#一个promise-实现-ajax-的操作" class="headerlink" title="一个promise 实现 ajax 的操作"></a>一个promise 实现 ajax 的操作</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="keyword">function</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    client.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url);</span><br><span class="line">    client.<span class="property">onreadystatechange</span> = handler;</span><br><span class="line">    client.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    client.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    client.<span class="title function_">send</span>();</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/posts.json&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">json</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Contents: &#x27;</span> + json);</span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;出错了&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="如果一个promise-实例的resolve返回是另一个promise-实例，那他的状态不取决与自己-而取决于返回的promise实例的状态"><a href="#如果一个promise-实例的resolve返回是另一个promise-实例，那他的状态不取决与自己-而取决于返回的promise实例的状态" class="headerlink" title="如果一个promise 实例的resolve返回是另一个promise 实例，那他的状态不取决与自己 而取决于返回的promise实例的状态"></a>如果一个promise 实例的resolve返回是另一个promise 实例，那他的状态不取决与自己 而取决于返回的promise实例的状态</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">resolve</span>(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;fail&#x27;</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(error))</span><br><span class="line"><span class="comment">// Error: fail</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="Promise-prototype"><a href="#Promise-prototype" class="headerlink" title="Promise.prototype"></a>Promise.prototype</h2><h6 id="实例具有then方法，也就是说，then方法是定义在原型对象"><a href="#实例具有then方法，也就是说，then方法是定义在原型对象" class="headerlink" title="实例具有then方法，也就是说，then方法是定义在原型对象"></a>实例具有then方法，也就是说，then方法是定义在原型对象</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span> &#123;<span class="attr">constructor</span>: ƒ, <span class="attr">then</span>: ƒ, <span class="attr">catch</span>: ƒ, <span class="attr">finally</span>: ƒ, <span class="title class_">Symbol</span>(<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>): <span class="string">&quot;Promise&quot;</span>&#125;</span><br><span class="line"><span class="attr">catch</span>:ƒ <span class="keyword">catch</span>()</span><br><span class="line"><span class="attr">constructor</span>:ƒ <span class="title class_">Promise</span>()</span><br><span class="line"><span class="attr">all</span>:ƒ <span class="title function_">all</span>()</span><br><span class="line"><span class="attr">arguments</span>:(...)</span><br><span class="line"><span class="attr">caller</span>:(...)</span><br><span class="line"><span class="attr">length</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">name</span>:<span class="string">&quot;all&quot;</span></span><br><span class="line"><span class="attr">__proto__</span>:ƒ ()</span><br><span class="line">[[<span class="title class_">Scopes</span>]]:<span class="title class_">Scopes</span>[<span class="number">0</span>]</span><br><span class="line"><span class="attr">arguments</span>:(...)</span><br><span class="line"><span class="attr">caller</span>:(...)</span><br><span class="line"><span class="attr">length</span>:<span class="number">1</span></span><br><span class="line"><span class="attr">name</span>:<span class="string">&quot;Promise&quot;</span></span><br><span class="line"><span class="attr">prototype</span>:<span class="title class_">Promise</span> &#123;<span class="attr">constructor</span>: ƒ, <span class="attr">then</span>: ƒ, <span class="attr">catch</span>: ƒ, <span class="attr">finally</span>: ƒ, <span class="title class_">Symbol</span>(<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>): <span class="string">&quot;Promise&quot;</span>&#125;</span><br><span class="line"><span class="attr">race</span>:ƒ <span class="title function_">race</span>()</span><br><span class="line"><span class="attr">reject</span>:ƒ <span class="title function_">reject</span>()</span><br><span class="line"><span class="attr">resolve</span>:ƒ <span class="title function_">resolve</span>()</span><br><span class="line"><span class="title class_">Symbol</span>(<span class="title class_">Symbol</span>.<span class="property">species</span>):(...)</span><br><span class="line"><span class="keyword">get</span> <span class="title function_">Symbol</span>(<span class="params"><span class="built_in">Symbol</span>.species</span>):ƒ [<span class="title class_">Symbol</span>.<span class="property">species</span>]()</span><br><span class="line"><span class="attr">__proto__</span>:ƒ ()</span><br><span class="line">[[<span class="title class_">Scopes</span>]]:<span class="title class_">Scopes</span>[<span class="number">0</span>]</span><br><span class="line"><span class="attr">finally</span>:ƒ <span class="title function_">finally</span>()</span><br><span class="line"><span class="attr">then</span>:ƒ <span class="title function_">then</span>()</span><br><span class="line"><span class="title class_">Symbol</span>(<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>):<span class="string">&quot;Promise&quot;</span></span><br><span class="line"><span class="attr">__proto__</span>:<span class="title class_">Object</span></span><br></pre></td></tr></table></figure>
<ul>
<li>promise.prototype.then(arg1,arg2):<br>then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</li>
<li>Promise.prototype.catch:<br>######Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。<br>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&#x27;/post/1.json&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">comments</span>) &#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。</li>
<li>Promise.prototype.finally()：<br>finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。finally方法的回调函数不接受任何参数，这意味着没有办法知道前面的promise状态是什么。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;···&#125;);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">server.<span class="title function_">listen</span>(port)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">finally</span>(server.<span class="property">stop</span>);</span><br></pre></td></tr></table></figure></li>
<li>———–2018年8月26日22:28:01 —————————————————-</li>
</ul>
<p>更新了，看到一个超级大佬写的关于promise，是在看的是一知半解，不敢搬，就贴个链接吧：<br><a href="https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html">We have a problem with promises</a>。 我是用google翻译勉强看完的，纯英文的，我英文不好qaq。。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>promise中的reject和catch处理上的区别</title>
    <url>/2018/07/17/promise%E4%B8%AD%E7%9A%84reject%E5%92%8Ccatch%E5%A4%84%E7%90%86%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="reject-和-catch-的处理上"><a href="#reject-和-catch-的处理上" class="headerlink" title="reject 和 catch 的处理上"></a>reject 和 catch 的处理上</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">auto.<span class="title function_">getData</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">results</span>) &#123;</span><br><span class="line">     res.<span class="title function_">send</span>(results);</span><br><span class="line">&#125;, next);</span><br><span class="line">auto.<span class="title function_">getData</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">results</span>) &#123;</span><br><span class="line">     res.<span class="title function_">send</span>(results);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(next);</span><br></pre></td></tr></table></figure>
<h6 id="第一种写法，next函数只会处理getData中的reject时的异常情况。"><a href="#第一种写法，next函数只会处理getData中的reject时的异常情况。" class="headerlink" title="第一种写法，next函数只会处理getData中的reject时的异常情况。"></a>第一种写法，next函数只会处理getData中的reject时的异常情况。</h6><p><img src="https://dn-cnode.qbox.me/FobQa2vcQxJQo_1kbvF3K71YXyDK"><br><br/></p>
<h6 id="第二种写法，catch会捕捉到在它之前的promise链上的代码抛出的异常，不仅仅是getData，还有then-里面的异常。"><a href="#第二种写法，catch会捕捉到在它之前的promise链上的代码抛出的异常，不仅仅是getData，还有then-里面的异常。" class="headerlink" title="第二种写法，catch会捕捉到在它之前的promise链上的代码抛出的异常，不仅仅是getData，还有then()里面的异常。"></a>第二种写法，catch会捕捉到在它之前的promise链上的代码抛出的异常，不仅仅是getData，还有then()里面的异常。</h6><p><img src="https://dn-cnode.qbox.me/Fm56oEjn1Sjfn7lV1wx-dOFvwdTX"></p>
</br>
---

<p>好吧看到了就整理搬运过来了，免得到时候找不到了 orz</p>
]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>require的实现原理</title>
    <url>/2018/07/03/require%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h5 id="几乎所有Node-js开发人员都可以告诉你这个require-函数的作用，但是我们中有多少人真的知道它是如何工作的？我们每天都使用它来加载库和模块，但它的行为却是一个谜。好奇，我挖掘了Node核心，了解幕后发生了什么。但是，我没有找到单一功能，而是成为Node模块系统的核心：module-js。该文件包含一个令人惊讶的功能但相对未知的核心模块，它控制所使用的每个文件的加载，编译和缓存。require-事实证明，这只是冰山一角。"><a href="#几乎所有Node-js开发人员都可以告诉你这个require-函数的作用，但是我们中有多少人真的知道它是如何工作的？我们每天都使用它来加载库和模块，但它的行为却是一个谜。好奇，我挖掘了Node核心，了解幕后发生了什么。但是，我没有找到单一功能，而是成为Node模块系统的核心：module-js。该文件包含一个令人惊讶的功能但相对未知的核心模块，它控制所使用的每个文件的加载，编译和缓存。require-事实证明，这只是冰山一角。" class="headerlink" title="几乎所有Node.js开发人员都可以告诉你这个require()函数的作用，但是我们中有多少人真的知道它是如何工作的？我们每天都使用它来加载库和模块，但它的行为却是一个谜。好奇，我挖掘了Node核心，了解幕后发生了什么。但是，我没有找到单一功能，而是成为Node模块系统的核心：module.js。该文件包含一个令人惊讶的功能但相对未知的核心模块，它控制所使用的每个文件的加载，编译和缓存。require()事实证明，这只是冰山一角。"></a><font color = grat>几乎所有Node.js开发人员都可以告诉你这个require()函数的作用，但是我们中有多少人真的知道它是如何工作的？我们每天都使用它来加载库和模块，但它的行为却是一个谜。</br>好奇，我挖掘了Node核心，了解幕后发生了什么。但是，我没有找到单一功能，而是成为Node模块系统的核心：module.js。该文件包含一个令人惊讶的功能但相对未知的核心模块，它控制所使用的每个文件的加载，编译和缓存。require()事实证明，这只是冰山一角。</font></h5><h2 id="MODULE-JS"><a href="#MODULE-JS" class="headerlink" title="MODULE.JS"></a>MODULE.JS</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Module</span>(<span class="params">id, parent</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">id</span> = id;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">exports</span> = &#123;&#125;;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">parent</span> = parent;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h6 id="找到的Module类型在module-jsNode-js-中有两个主要角色。首先，它为所有Node-js模块的构建提供了基础。每个文件在加载时都会获得此基本模块的新实例，即使在文件运行后也会持续存在。这就是为什么我们可以module-exports根据需要附加属性并在以后返回它们。"><a href="#找到的Module类型在module-jsNode-js-中有两个主要角色。首先，它为所有Node-js模块的构建提供了基础。每个文件在加载时都会获得此基本模块的新实例，即使在文件运行后也会持续存在。这就是为什么我们可以module-exports根据需要附加属性并在以后返回它们。" class="headerlink" title="找到的Module类型在module.jsNode.js 中有两个主要角色。首先，它为所有Node.js模块的构建提供了基础。每个文件在加载时都会获得此基本模块的新实例，即使在文件运行后也会持续存在。这就是为什么我们可以module.exports根据需要附加属性并在以后返回它们。"></a>找到的Module类型在module.jsNode.js 中有两个主要角色。首先，它为所有Node.js模块的构建提供了基础。每个文件在加载时都会获得此基本模块的新实例，即使在文件运行后也会持续存在。这就是为什么我们可以module.exports根据需要附加属性并在以后返回它们。</h6><h6 id="该模块的第二项重要工作是处理Node的模块加载机制。require我们使用的独立函数实际上是一个抽象module-require，它本身只是一个简单的包装器Module-load。这种加载方法处理每个文件的实际加载，是我们开始旅程的地方。"><a href="#该模块的第二项重要工作是处理Node的模块加载机制。require我们使用的独立函数实际上是一个抽象module-require，它本身只是一个简单的包装器Module-load。这种加载方法处理每个文件的实际加载，是我们开始旅程的地方。" class="headerlink" title="该模块的第二项重要工作是处理Node的模块加载机制。require我们使用的独立函数实际上是一个抽象module.require，它本身只是一个简单的包装器Module._load。这种加载方法处理每个文件的实际加载，是我们开始旅程的地方。"></a>该模块的第二项重要工作是处理Node的模块加载机制。require我们使用的独立函数实际上是一个抽象module.require，它本身只是一个简单的包装器Module._load。这种加载方法处理每个文件的实际加载，是我们开始旅程的地方。</h6><h4 id="Module-load"><a href="#Module-load" class="headerlink" title="Module._load"></a>Module._load</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Module</span>.<span class="property">_load</span> = <span class="keyword">function</span>(<span class="params">request, parent, isMain</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. Check Module._cache for the cached module.</span></span><br><span class="line">  <span class="comment">// 2. Create a new Module instance if cache is empty.</span></span><br><span class="line">  <span class="comment">// 3. Save it to the cache.</span></span><br><span class="line">  <span class="comment">// 4. Call module.load() with your the given filename.</span></span><br><span class="line">  <span class="comment">//    This will call module.compile() after reading the file contents.</span></span><br><span class="line">  <span class="comment">// 5. If there was an error loading/parsing the file,</span></span><br><span class="line">  <span class="comment">//    delete the bad module from the cache</span></span><br><span class="line">  <span class="comment">// 6. return module.exports</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="Module-load负责加载新模块和管理模块缓存。在加载时缓存每个模块可减少冗余文件读取的数量，并可显着加快应用程序的速度。此外，共享模块实例允许类似单一模块，可以在项目中保持状态。"><a href="#Module-load负责加载新模块和管理模块缓存。在加载时缓存每个模块可减少冗余文件读取的数量，并可显着加快应用程序的速度。此外，共享模块实例允许类似单一模块，可以在项目中保持状态。" class="headerlink" title="Module._load负责加载新模块和管理模块缓存。在加载时缓存每个模块可减少冗余文件读取的数量，并可显着加快应用程序的速度。此外，共享模块实例允许类似单一模块，可以在项目中保持状态。"></a>Module._load负责加载新模块和管理模块缓存。在加载时缓存每个模块可减少冗余文件读取的数量，并可显着加快应用程序的速度。此外，共享模块实例允许类似单一模块，可以在项目中保持状态。</h6><h6 id="如果缓存中不存在模块，Module-load则将为该文件创建新的基本模块。然后它会告诉模块在发送新文件之前读入新文件的内容module-compile。"><a href="#如果缓存中不存在模块，Module-load则将为该文件创建新的基本模块。然后它会告诉模块在发送新文件之前读入新文件的内容module-compile。" class="headerlink" title="如果缓存中不存在模块，Module._load则将为该文件创建新的基本模块。然后它会告诉模块在发送新文件之前读入新文件的内容module._compile。"></a>如果缓存中不存在模块，Module._load则将为该文件创建新的基本模块。然后它会告诉模块在发送新文件之前读入新文件的内容module._compile。</h6><h6 id="如果您注意到上面的步骤＃6，您将看到module-exports返回给用户。这就是你使用exports和module-exports定义公共接口的原因，因为那正是Module-load然后require会返回的。令我感到惊讶的是，这里没有更多的魔法，但如果有什么更好的话。"><a href="#如果您注意到上面的步骤＃6，您将看到module-exports返回给用户。这就是你使用exports和module-exports定义公共接口的原因，因为那正是Module-load然后require会返回的。令我感到惊讶的是，这里没有更多的魔法，但如果有什么更好的话。" class="headerlink" title="如果您注意到上面的步骤＃6，您将看到module.exports返回给用户。这就是你使用exports和module.exports定义公共接口的原因，因为那正是Module._load然后require会返回的。令我感到惊讶的是，这里没有更多的魔法，但如果有什么更好的话。"></a>如果您注意到上面的步骤＃6，您将看到module.exports返回给用户。这就是你使用exports和module.exports定义公共接口的原因，因为那正是Module._load然后require会返回的。令我感到惊讶的是，这里没有更多的魔法，但如果有什么更好的话。</h6><h4 id="module-compile"><a href="#module-compile" class="headerlink" title="module._compile"></a>module._compile</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Module</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_compile</span> = <span class="keyword">function</span>(<span class="params">content, filename</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. Create the standalone require function that calls module.require.</span></span><br><span class="line">  <span class="comment">// 1.创建调用module.require的独立需求函数。</span></span><br><span class="line">  <span class="comment">// 2. Attach other helper methods to require.</span></span><br><span class="line">  <span class="comment">// 2.将其他辅助方法附加到require。</span></span><br><span class="line">  <span class="comment">// 3. Wraps the JS code in a function that provides our require,</span></span><br><span class="line">  <span class="comment">//    module, etc. variables locally to the module scope.</span></span><br><span class="line">  <span class="comment">// 3.在提供我们需求的函数中包装JS代码，模块等变量本地到模块范围。</span></span><br><span class="line">  <span class="comment">// 4. Run that function</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="这是真正的魔法发生的地方。首先，require为该模块创建一个特殊的独立功能。这是我们都熟悉的必需功能。虽然函数本身只是一个包装器Module-require，但它还包含一些鲜为人知的帮助器属性和方法供我们使用："><a href="#这是真正的魔法发生的地方。首先，require为该模块创建一个特殊的独立功能。这是我们都熟悉的必需功能。虽然函数本身只是一个包装器Module-require，但它还包含一些鲜为人知的帮助器属性和方法供我们使用：" class="headerlink" title="这是真正的魔法发生的地方。首先，require为该模块创建一个特殊的独立功能。这是我们都熟悉的必需功能。虽然函数本身只是一个包装器Module.require，但它还包含一些鲜为人知的帮助器属性和方法供我们使用："></a>这是真正的魔法发生的地方。首先，require为该模块创建一个特殊的独立功能。这是我们都熟悉的必需功能。虽然函数本身只是一个包装器Module.require，但它还包含一些鲜为人知的帮助器属性和方法供我们使用：</h6><ul>
<li>require()：加载外部模块</li>
<li>require.resolve()：将模块名称解析为其绝对路径</li>
<li>require.main：主要模块</li>
<li>require.cache：所有缓存的模块</li>
<li>require.extensions：每种有效文件类型的可用编译方法，基于其扩展名</li>
</ul>
<h6 id="一旦require准备好，整个装载的源代码被包裹在一个新的功能，这需要在-require，module，exports，和所有其他暴露变量作为自变量。这为该模块创建了一个新的功能范围，因此不会污染Node-js的其余环境。"><a href="#一旦require准备好，整个装载的源代码被包裹在一个新的功能，这需要在-require，module，exports，和所有其他暴露变量作为自变量。这为该模块创建了一个新的功能范围，因此不会污染Node-js的其余环境。" class="headerlink" title="一旦require准备好，整个装载的源代码被包裹在一个新的功能，这需要在 require，module，exports，和所有其他暴露变量作为自变量。这为该模块创建了一个新的功能范围，因此不会污染Node.js的其余环境。"></a>一旦require准备好，整个装载的源代码被包裹在一个新的功能，这需要在 require，module，exports，和所有其他暴露变量作为自变量。这为该模块创建了一个新的功能范围，因此不会污染Node.js的其余环境。</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, <span class="built_in">require</span>, <span class="variable language_">module</span>, __filename, __dirname</span>) &#123;</span><br><span class="line">  <span class="comment">// YOUR CODE INJECTED HERE!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h6 id="最后，运行包装模块的功能。整个Module-compile方法是同步执行的，因此原始调用Module-load只是在完成并返回module-exports给用户之前等待此代码运行。"><a href="#最后，运行包装模块的功能。整个Module-compile方法是同步执行的，因此原始调用Module-load只是在完成并返回module-exports给用户之前等待此代码运行。" class="headerlink" title="最后，运行包装模块的功能。整个Module._compile方法是同步执行的，因此原始调用Module._load只是在完成并返回module.exports给用户之前等待此代码运行。"></a>最后，运行包装模块的功能。整个Module._compile方法是同步执行的，因此原始调用Module._load只是在完成并返回module.exports给用户之前等待此代码运行。</h6><p>####结论</p>
<h6 id="因此，我们已经到达了需求代码路径的末尾，并且通过创建require我们首先开始调查的函数，这样做已经完全循环。"><a href="#因此，我们已经到达了需求代码路径的末尾，并且通过创建require我们首先开始调查的函数，这样做已经完全循环。" class="headerlink" title="因此，我们已经到达了需求代码路径的末尾，并且通过创建require我们首先开始调查的函数，这样做已经完全循环。"></a>因此，我们已经到达了需求代码路径的末尾，并且通过创建require我们首先开始调查的函数，这样做已经完全循环。</h6><h6 id="如果你已经完成了这一切，那么你已经准备好了最后的秘密：require-‘module’-。没错，模块系统本身可以通过模块系统加载。盗梦空间。这可能听起来很奇怪，但它允许userland模块与加载系统交互而无需深入Node-js核心。像嘲弄和重新布线这样的流行模块都是基于此构建的。"><a href="#如果你已经完成了这一切，那么你已经准备好了最后的秘密：require-‘module’-。没错，模块系统本身可以通过模块系统加载。盗梦空间。这可能听起来很奇怪，但它允许userland模块与加载系统交互而无需深入Node-js核心。像嘲弄和重新布线这样的流行模块都是基于此构建的。" class="headerlink" title="如果你已经完成了这一切，那么你已经准备好了最后的秘密：require(‘module’)。没错，模块系统本身可以通过模块系统加载。盗梦空间。这可能听起来很奇怪，但它允许userland模块与加载系统交互而无需深入Node.js核心。像嘲弄和重新布线这样的流行模块都是基于此构建的。"></a>如果你已经完成了这一切，那么你已经准备好了最后的秘密：require(‘module’)。没错，模块系统本身可以通过模块系统加载。盗梦空间。这可能听起来很奇怪，但它允许userland模块与加载系统交互而无需深入Node.js核心。像嘲弄和重新布线这样的流行模块都是基于此构建的。</h6>]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>毕业了，致终将逝去的青春</title>
    <url>/2018/06/26/%E6%AF%95%E4%B8%9A%E4%BA%86%EF%BC%8C%E8%87%B4%E7%BB%88%E5%B0%86%E9%80%9D%E5%8E%BB%E7%9A%84%E9%9D%92%E6%98%A5/</url>
    <content><![CDATA[<h2 id="好不容易休一天假-旧的博客还没迁移完。休息之余，传一波照片。-皮一下"><a href="#好不容易休一天假-旧的博客还没迁移完。休息之余，传一波照片。-皮一下" class="headerlink" title="好不容易休一天假,旧的博客还没迁移完。休息之余，传一波照片。(皮一下 =.=)"></a><font color = red>好</font><font color = orange>不</font><font color = Yellow>容易</font><font color = grenn>休</font><font color = blue>一天</font><font color = purple>假</font><font color = red>,</font><font color = orange>旧</font><font color = Yellow>的</font><font color = grenn>博客</font><font color = blue>还没</font><font color = purple>迁移</font><font color = red>完</font><font color = orange>。</font><font color = Yellow>休息</font><font color = grenn>之余</font><font color = blue>，</font><font color = purple>传</font><font color = red>一波</font><font color = orange>照片</font><font color = Yellow>。</font><font size = 1>(皮一下 =.=)</font></h2><p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/IMG_20180620_191951.jpg"></p>
<span id="more"></span>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/IMG_20180619_143107.jpg"></p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/IMG_20180619_185605.jpg"></p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/IMG_20180619_185548.jpg"></p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/IMG_20180621_161905.jpg"></p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/IMG_20180621_161936.jpg"></p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/IMG_20180622_093118.jpg"></p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/IMG_20180622_093154.jpg"></p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/IMG_20180622_093208.jpg"></p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/IMG_20180622_093222.jpg"></p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/IMG_20180622_093236.jpg"></p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/IMG_20180622_093240.jpg"></p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/IMG_20180622_093306.jpg"></p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/IMG_20180622_093442.jpg"></p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/IMG_20180622_093828.jpg"></p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/IMG_20180624_223512.jpg"></p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/IMG_20180624_223524.jpg"></p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/IMG_20180624_223539.jpg"></p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/IMG_20180626_202249.jpg"></p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/IMG_20180704_202403.jpg"></p>
]]></content>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>关于闭包</title>
    <url>/2018/06/26/%E5%85%B3%E4%BA%8E%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>这篇文章是2018-06-26号创建的，那个时候我接触到了闭包，然后写下了自己的理解。2019年的时候我编辑过一次。因为自己对闭包有了新的理解。。</p>
<p>现在我看了《你不知道的JavaScript》这本书的上卷后，删除了之前编辑的内容。准备重新分享我对闭包的理解。</p>
<h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>词法作用域，又叫静态作用域。</p>
<p>说道词法作用域就要提一下编译的三个阶段：</p>
<ul>
<li>词法分析</li>
<li>语法分析</li>
<li>代码生成</li>
</ul>
<p>而词法作用域就是在词法分析阶段确定的，换句话说就是你在写代码时将变量放在哪个代码块里来决定。</p>
<p>看这样一段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<p>稍微有点JavaScript基础的同学都知道，输出为什么是20。</p>
<p>作用域发生嵌套时，引擎会从当前作用域往外层逐层查找，就和前端的click事件冒泡一样。</p>
<span id="more"></span>
<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>我印象里的关于闭包的定义有很多：</p>
<ul>
<li>一个函数和对其周围状态（<strong>lexical environment，词法环境</strong>）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是<strong>闭包</strong>（<strong>closure</strong>）。  —— MDN WEB Docs</li>
<li>闭包就是能够读取其他函数内部变量的函数。 —— 阮一峰的网络日志</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baz = <span class="title function_">foo</span>()</span><br><span class="line"><span class="title function_">baz</span>() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这段代码中，bar() 仍然持有对foo函数的作用域的引用，这个引用就叫做闭包。 —— 《你不知道的JavaScript》</li>
</ul>
<p>这三种说法都没有问题，正常的词法作用域查找规则都是闭包的一部分，所以说，闭包无处不在。</p>
<h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><h4 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h4><p>IIFE 全称是 立即调用函数表达式（immediately-invoked function expression）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">IIFE</span>(<span class="params"></span>)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>首先IIFE确实创建了闭包，但是<code>a</code>是通过普通的词法作用域查找而非闭包被发现的。</p>
<p>所以，这里我也迷糊了。我暂时认知为，它创建了闭包，但是没有使用闭包！</p>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>在块作用域没出来之前，当循环里面有异步操作时，如何保证循环变量的值对应的是每一次循环时的值？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;,i*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大部分同学一眼都能看出来，这段代码会以每秒一次的频率输出五个 6</p>
<p>那么如何按照我们的预期，每个一秒依次输出1~5呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span> () &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">    &#125;, i * <span class="number">1000</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们封闭settimeout的上级作用域，使<code>i</code>的查找的不再是<code>var i</code> ，而是 <code>(function(i)&#123;&#125;)(i) </code>这个<code>IIFE</code>传递进来的，每一次循环的<code>i</code>值，会被保存下来，不会随着循环而改变。</p>
<p>可以参考以前搬运的一片文章：<a href="http://ruomuc.gitee.io/blog/2018/09/13/%E4%B8%80%E4%B8%AA%E5%BE%88%E6%9C%89%E6%84%8F%E6%80%9D%E9%9D%A2%E8%AF%95%E9%A2%98/">一道有意思的面试题</a></p>
<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>回想一下，根据上面对闭包的定义，JavaScript上所有使用了回调函数的地方都使用了闭包！</p>
<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>node.js的模块加载参照的是<a href="https://javascript.ruanyifeng.com/nodejs/module.html#toc11">CommonJS规范</a>，每个 <code>.js</code> 能独立一个环境只是因为 <code>node</code> 帮你在外层包了一个自执行函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, <span class="built_in">require</span>, <span class="variable language_">module</span>, __filename, __dirname</span>) &#123;</span><br><span class="line">  t = <span class="number">111</span>;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>这样的话。a.js引用b.js，并且使用其暴露出去变量和方法不就是在使用闭包吗？</p>
<p>最后，我也不知道我又没有表达清楚，但我对闭包确实有了更深的理解。</p>
<p>参考链接：</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html</a></li>
<li><a href="https://javascript.ruanyifeng.com/nodejs/module.html#toc5">https://javascript.ruanyifeng.com/nodejs/module.html#toc5</a></li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝和浅拷贝</title>
    <url>/2018/06/26/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h2 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h2><h6 id="stack为自动分配的内存空间，它由系统自动释放；而heap则是动态分配的内存，大小不定也不会自动释放。"><a href="#stack为自动分配的内存空间，它由系统自动释放；而heap则是动态分配的内存，大小不定也不会自动释放。" class="headerlink" title="stack为自动分配的内存空间，它由系统自动释放；而heap则是动态分配的内存，大小不定也不会自动释放。"></a>stack为自动分配的内存空间，它由系统自动释放；而heap则是动态分配的内存，大小不定也不会自动释放。</h6><h2 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h2><ul>
<li>基本类型：存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配。5种基本数据类型有Undefined、Null、Boolean、Number 和 String，它们是直接按值存放的，所以可以直接访问。</li>
<li>引用类型：存放在堆内存中的对象，变量实际保存的是一个指针，这个指针指向另一个位置。每个空间大小不一样，要根据情况开进行特定的分配。当我们需要访问引用类型（如对象，数组，函数等）的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。</li>
</ul>
<h2 id="传值与传址"><a href="#传值与传址" class="headerlink" title="传值与传址"></a>传值与传址</h2><h6 id="前面之所以要说明什么是内存中的堆、栈以及变量类型，实际上是为下文服务的，就是为了更好的理解什么是“浅拷贝”和“深拷贝”。基本类型与引用类型最大的区别实际就是传值与传址的区别。测试用例："><a href="#前面之所以要说明什么是内存中的堆、栈以及变量类型，实际上是为下文服务的，就是为了更好的理解什么是“浅拷贝”和“深拷贝”。基本类型与引用类型最大的区别实际就是传值与传址的区别。测试用例：" class="headerlink" title="前面之所以要说明什么是内存中的堆、栈以及变量类型，实际上是为下文服务的，就是为了更好的理解什么是“浅拷贝”和“深拷贝”。基本类型与引用类型最大的区别实际就是传值与传址的区别。测试用例："></a>前面之所以要说明什么是内存中的堆、栈以及变量类型，实际上是为下文服务的，就是为了更好的理解什么是“浅拷贝”和“深拷贝”。基本类型与引用类型最大的区别实际就是传值与传址的区别。测试用例：</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">   <span class="keyword">var</span> b = a;</span><br><span class="line">   <span class="keyword">var</span> c = a[<span class="number">0</span>];</span><br><span class="line">   <span class="title function_">alert</span>(b);<span class="comment">//1,2,3,4,5</span></span><br><span class="line">   <span class="title function_">alert</span>(c);<span class="comment">//1</span></span><br><span class="line">   <span class="comment">//改变数值</span></span><br><span class="line">   b[<span class="number">4</span>] = <span class="number">6</span>;</span><br><span class="line">   c = <span class="number">7</span>;</span><br><span class="line">   <span class="title function_">alert</span>(a[<span class="number">4</span>]);<span class="comment">//6</span></span><br><span class="line">   <span class="title function_">alert</span>(a[<span class="number">0</span>]);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<h6 id="从上面我们可以得知，当我改变b中的数据时，a中数据也发生了变化；但是当我改变c的数据值时，a却没有发生改变。"><a href="#从上面我们可以得知，当我改变b中的数据时，a中数据也发生了变化；但是当我改变c的数据值时，a却没有发生改变。" class="headerlink" title="从上面我们可以得知，当我改变b中的数据时，a中数据也发生了变化；但是当我改变c的数据值时，a却没有发生改变。"></a>从上面我们可以得知，当我改变b中的数据时，a中数据也发生了变化；但是当我改变c的数据值时，a却没有发生改变。</h6><h6 id="这就是传值与传址的区别。因为a是数组，属于引用类型，所以它赋予给b的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象。而c仅仅是从a堆内存中获取的一个数据值，并保存在栈中。所以b修改的时候，会根据地址回到a堆中修改，c则直接在栈中修改，并且不能指向a堆内存中。"><a href="#这就是传值与传址的区别。因为a是数组，属于引用类型，所以它赋予给b的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象。而c仅仅是从a堆内存中获取的一个数据值，并保存在栈中。所以b修改的时候，会根据地址回到a堆中修改，c则直接在栈中修改，并且不能指向a堆内存中。" class="headerlink" title="这就是传值与传址的区别。因为a是数组，属于引用类型，所以它赋予给b的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象。而c仅仅是从a堆内存中获取的一个数据值，并保存在栈中。所以b修改的时候，会根据地址回到a堆中修改，c则直接在栈中修改，并且不能指向a堆内存中。"></a>这就是传值与传址的区别。因为a是数组，属于引用类型，所以它赋予给b的时候传的是栈中的地址（相当于新建了一个不同名“指针”），而不是堆内存中的对象。而c仅仅是从a堆内存中获取的一个数据值，并保存在栈中。所以b修改的时候，会根据地址回到a堆中修改，c则直接在栈中修改，并且不能指向a堆内存中。</h6><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><h6 id="在定义一个对象或数组时，变量存放的往往只是一个地址。当我们使用对象拷贝时，如果属性是对象或数组时，这时候我们传递的也只是一个地址。因此子对象在访问该属性时，会根据地址回溯到父对象指向的堆内存中，即父子对象发生了关联，两者的属性值会指向同一内存空间。"><a href="#在定义一个对象或数组时，变量存放的往往只是一个地址。当我们使用对象拷贝时，如果属性是对象或数组时，这时候我们传递的也只是一个地址。因此子对象在访问该属性时，会根据地址回溯到父对象指向的堆内存中，即父子对象发生了关联，两者的属性值会指向同一内存空间。" class="headerlink" title="在定义一个对象或数组时，变量存放的往往只是一个地址。当我们使用对象拷贝时，如果属性是对象或数组时，这时候我们传递的也只是一个地址。因此子对象在访问该属性时，会根据地址回溯到父对象指向的堆内存中，即父子对象发生了关联，两者的属性值会指向同一内存空间。"></a>在定义一个对象或数组时，变量存放的往往只是一个地址。当我们使用对象拷贝时，如果属性是对象或数组时，这时候我们传递的也只是一个地址。因此子对象在访问该属性时，会根据地址回溯到父对象指向的堆内存中，即父子对象发生了关联，两者的属性值会指向同一内存空间。</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">        <span class="attr">key1</span>:<span class="string">&quot;11111&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">Copy</span>(<span class="params">p</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> c = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123; </span><br><span class="line">        　　c[i] = p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">　　&#125;</span><br><span class="line">    a.<span class="property">key2</span> = [<span class="string">&#x27;小辉&#x27;</span>,<span class="string">&#x27;小辉&#x27;</span>];</span><br><span class="line">    <span class="keyword">var</span> b = <span class="title class_">Copy</span>(a);</span><br><span class="line">	b.<span class="property">key3</span> = <span class="string">&#x27;33333&#x27;</span>;</span><br><span class="line">    <span class="title function_">alert</span>(b.<span class="property">key1</span>);     <span class="comment">//1111111</span></span><br><span class="line">    <span class="title function_">alert</span>(b.<span class="property">key3</span>);    <span class="comment">//33333</span></span><br><span class="line">    <span class="title function_">alert</span>(a.<span class="property">key3</span>);    <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<h6 id="a对象中key1属性是字符串，key2属性是数组。a拷贝到b，12属性均顺利拷贝。给b对象新增一个字符串类型的属性key3时，b能正常修改，而a中无定义。说明子对象的key3（基本类型）并没有关联到父对象中，所以undefined。"><a href="#a对象中key1属性是字符串，key2属性是数组。a拷贝到b，12属性均顺利拷贝。给b对象新增一个字符串类型的属性key3时，b能正常修改，而a中无定义。说明子对象的key3（基本类型）并没有关联到父对象中，所以undefined。" class="headerlink" title="a对象中key1属性是字符串，key2属性是数组。a拷贝到b，12属性均顺利拷贝。给b对象新增一个字符串类型的属性key3时，b能正常修改，而a中无定义。说明子对象的key3（基本类型）并没有关联到父对象中，所以undefined。"></a>a对象中key1属性是字符串，key2属性是数组。a拷贝到b，12属性均顺利拷贝。给b对象新增一个字符串类型的属性key3时，b能正常修改，而a中无定义。说明子对象的key3（基本类型）并没有关联到父对象中，所以undefined。</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> b.<span class="property">key2</span>.<span class="title function_">push</span>(<span class="string">&quot;大辉&quot;</span>);</span><br><span class="line"><span class="number">2</span> <span class="title function_">alert</span>(b.<span class="property">key2</span>);    <span class="comment">//小辉，小辉，大辉</span></span><br><span class="line"><span class="number">3</span> <span class="title function_">alert</span>(a.<span class="property">key2</span>);    <span class="comment">//小辉，小辉，大辉</span></span><br></pre></td></tr></table></figure>
<h6 id="但是，若修改的属性变为对象或数组时，那么父子对象之间就会发生关联。从以上弹出结果可知，我对b对象进行修改，a、b的key2属性值（数组）均发生了改变。其在内存的状态"><a href="#但是，若修改的属性变为对象或数组时，那么父子对象之间就会发生关联。从以上弹出结果可知，我对b对象进行修改，a、b的key2属性值（数组）均发生了改变。其在内存的状态" class="headerlink" title="但是，若修改的属性变为对象或数组时，那么父子对象之间就会发生关联。从以上弹出结果可知，我对b对象进行修改，a、b的key2属性值（数组）均发生了改变。其在内存的状态."></a>但是，若修改的属性变为对象或数组时，那么父子对象之间就会发生关联。从以上弹出结果可知，我对b对象进行修改，a、b的key2属性值（数组）均发生了改变。其在内存的状态.</h6><p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/blog_stackandflow2.png"></p>
<h6 id="原因是key1的值属于基本类型，所以拷贝的时候传递的就是该数据段；但是key2的值是堆内存中的对象，所以key2在拷贝的时候传递的是指向key2对象的地址，无论复制多少个key2，其值始终是指向父对象的key2对象的内存空间。"><a href="#原因是key1的值属于基本类型，所以拷贝的时候传递的就是该数据段；但是key2的值是堆内存中的对象，所以key2在拷贝的时候传递的是指向key2对象的地址，无论复制多少个key2，其值始终是指向父对象的key2对象的内存空间。" class="headerlink" title="原因是key1的值属于基本类型，所以拷贝的时候传递的就是该数据段；但是key2的值是堆内存中的对象，所以key2在拷贝的时候传递的是指向key2对象的地址，无论复制多少个key2，其值始终是指向父对象的key2对象的内存空间。"></a>原因是key1的值属于基本类型，所以拷贝的时候传递的就是该数据段；但是key2的值是堆内存中的对象，所以key2在拷贝的时候传递的是指向key2对象的地址，无论复制多少个key2，其值始终是指向父对象的key2对象的内存空间。</h6><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h6 id="或许以上并不是我们在实际编码中想要的结果，我们不希望父子对象之间产生关联，那么这时候可以用到深拷贝。既然属性值类型是数组和或象时只会传址，那么我们就用递归来解决这个问题，把父对象中所有属于对象的属性类型都遍历赋给子对象即可。测试代码如下："><a href="#或许以上并不是我们在实际编码中想要的结果，我们不希望父子对象之间产生关联，那么这时候可以用到深拷贝。既然属性值类型是数组和或象时只会传址，那么我们就用递归来解决这个问题，把父对象中所有属于对象的属性类型都遍历赋给子对象即可。测试代码如下：" class="headerlink" title="或许以上并不是我们在实际编码中想要的结果，我们不希望父子对象之间产生关联，那么这时候可以用到深拷贝。既然属性值类型是数组和或象时只会传址，那么我们就用递归来解决这个问题，把父对象中所有属于对象的属性类型都遍历赋给子对象即可。测试代码如下："></a>或许以上并不是我们在实际编码中想要的结果，我们不希望父子对象之间产生关联，那么这时候可以用到深拷贝。既然属性值类型是数组和或象时只会传址，那么我们就用递归来解决这个问题，把父对象中所有属于对象的属性类型都遍历赋给子对象即可。测试代码如下：</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Copy</span>(<span class="params">p, c</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> c = c || &#123;&#125;; <span class="comment">//如果c存在则赋值，否则初始化为&#123;&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123; <span class="comment">//遍历p</span></span><br><span class="line">        　　<span class="keyword">if</span> (<span class="keyword">typeof</span> p[i] === <span class="string">&#x27;object&#x27;</span>) &#123;  <span class="comment">//如果 是 对象 </span></span><br><span class="line">        　　　　　c[i] = (p[i].<span class="property">constructor</span> === <span class="title class_">Array</span>) ? [] : &#123;&#125;; <span class="comment">//constructor方法返回一个对象的属性，如果是array则复制[] 否则 复制 &#123;&#125;</span></span><br><span class="line">        　　　　　<span class="title class_">Copy</span>(p[i], c[i]); <span class="comment">//递归 把p[i]放进c[i]的 []或&#123;&#125;中。</span></span><br><span class="line">        　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        　　　　　c[i] = p[i]; <span class="comment">// 直接赋值</span></span><br><span class="line">        　　&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">　　&#125;    </span><br><span class="line">    a.<span class="property">key2</span> = [<span class="string">&#x27;小辉&#x27;</span>,<span class="string">&#x27;小辉&#x27;</span>];</span><br><span class="line">    <span class="keyword">var</span> b=&#123;&#125;;</span><br><span class="line">    b = <span class="title class_">Copy</span>(a,b);        </span><br><span class="line">    b.<span class="property">key2</span>.<span class="title function_">push</span>(<span class="string">&quot;大辉&quot;</span>);</span><br><span class="line">    <span class="title function_">alert</span>(b.<span class="property">key2</span>);    <span class="comment">//小辉，小辉，大辉</span></span><br><span class="line">    <span class="title function_">alert</span>(a.<span class="property">key2</span>);    <span class="comment">//小辉，小辉</span></span><br></pre></td></tr></table></figure>
<p>由上可知，修改b的key2数组时，没有使a父对象中的key2数组新增一个值，即子对象没有影响到父对象a中的key2。其存储模式大致如下：<br><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/blog_stackandflow.png"></p>
<span id="more"></span>
<h2 id="深拷贝的几中方法："><a href="#深拷贝的几中方法：" class="headerlink" title="深拷贝的几中方法："></a>深拷贝的几中方法：</h2><ul>
<li><p>方法一:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">           <span class="keyword">var</span> o;</span><br><span class="line">           <span class="keyword">switch</span>(<span class="keyword">typeof</span> obj)&#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">&#x27;undefined&#x27;</span>: <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>   : o = obj + <span class="string">&#x27;&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>   : o = obj - <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">&#x27;boolean&#x27;</span>  : o = obj;<span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">&#x27;object&#x27;</span>   :</span><br><span class="line">               <span class="keyword">if</span>(obj === <span class="literal">null</span>)&#123;</span><br><span class="line">                   o = <span class="literal">null</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="title class_">Array</span>)&#123;</span><br><span class="line">                       o = [];</span><br><span class="line">                       <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = obj.<span class="property">length</span>; i &lt; len; i++)&#123;</span><br><span class="line">                           o.<span class="title function_">push</span>(<span class="title function_">deepCopy</span>(obj[i]));</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       o = &#123;&#125;;</span><br><span class="line">                       <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj)&#123;</span><br><span class="line">                           o[k] = <span class="title function_">deepCopy</span>(obj[k]);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="attr">default</span>:</span><br><span class="line">               o = obj;<span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> o;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法二：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法三：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">           <span class="keyword">var</span> newobj, obj;</span><br><span class="line">           <span class="keyword">if</span> (obj.<span class="property">constructor</span> == <span class="title class_">Object</span>)&#123;</span><br><span class="line">               newobj = <span class="keyword">new</span> obj.<span class="title function_">constructor</span>(<span class="params"></span>);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               newobj = <span class="keyword">new</span> obj.<span class="title function_">constructor</span>(<span class="params">obj.valueOf()</span>);<span class="comment">//valueOf()方法返回 Array 对象的原始值</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">               <span class="keyword">if</span> ( newobj[key] != obj[key] )&#123;</span><br><span class="line">                   <span class="keyword">if</span> ( <span class="title function_">typeof</span>(obj[key]) == <span class="string">&#x27;object&#x27;</span> )&#123;</span><br><span class="line">                       newobj[key] = <span class="title function_">deepCopy</span>(obj[key]);</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       newobj[key] = obj[key];</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           newobj.<span class="property">toString</span> = obj.<span class="property">toString</span>;</span><br><span class="line">           newobj.<span class="property">valueOf</span> = obj.<span class="property">valueOf</span>;</span><br><span class="line">           <span class="keyword">return</span> newobj;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法四：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cloneObj = <span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> str, newobj = obj.<span class="property">constructor</span> === <span class="title class_">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">JSON</span>)&#123;</span><br><span class="line">        str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj), <span class="comment">//系列化对象</span></span><br><span class="line">        newobj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(str); <span class="comment">//还原</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            newobj[i] = <span class="keyword">typeof</span> obj[i] === <span class="string">&#x27;object&#x27;</span> ? </span><br><span class="line">            <span class="title function_">cloneObj</span>(obj[i]) : obj[i]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>方法五：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">p,c</span>)&#123;</span><br><span class="line">       c = c || &#123;&#125;;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p)&#123;</span><br><span class="line">           <span class="keyword">if</span>(p.<span class="title function_">hasOwnProperty</span>(i))&#123;</span><br><span class="line">               <span class="keyword">if</span>(<span class="keyword">typeof</span> p[i] === <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">                   c[i] = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(p[i]) ? [] : &#123;&#125;;</span><br><span class="line">                   <span class="title function_">deepCopy</span>(p[i],c[i]);</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   c[i] = p[i];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> c;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>转自：<a href="http://www.cnblogs.com/chengguanhui/p/4737413.html">http://www.cnblogs.com/chengguanhui/p/4737413.html</a></p>
<p>   <a href="https://blog.csdn.net/flyingpig2016/article/details/52895620">https://blog.csdn.net/flyingpig2016/article/details/52895620</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>javaScript基础问题</title>
    <url>/2018/06/26/javaScript%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h6 id="ps-在社区找了个某大型互联网公司面试题，对比着知识点顺便把原来的服务器上的博客迁移过来"><a href="#ps-在社区找了个某大型互联网公司面试题，对比着知识点顺便把原来的服务器上的博客迁移过来" class="headerlink" title="ps:在社区找了个某大型互联网公司面试题，对比着知识点顺便把原来的服务器上的博客迁移过来  =.=!"></a>ps:在社区找了个某大型互联网公司面试题，对比着知识点顺便把原来的服务器上的博客迁移过来 <font color = pink size = 6> =.=!</font></h6><h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><p>区分 js 中的undefined ，null ，“” ， 0 和 false等….根据大佬推荐 其实应该去阅读<a href="https://github.com/lodash/lodash">loadsh</a>的源码。小白表示暂时不看，以后再看。  </p>
<p>凭自己理解分析一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(!<span class="number">0</span>); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(!<span class="literal">false</span>); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(!<span class="literal">undefined</span>); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(!<span class="literal">null</span>); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(!<span class="string">&#x27;&#x27;</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>######首先，通过上面的代码可以知道 ， 在if..else 循环中， 0、false、undefined、null、’’ 都是会进入else块的，也就是说:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Boolean</span>(<span class="number">0</span>)</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="literal">false</span>)</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="literal">undefined</span>)</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>如上代码所示，它们的Boolean都是false.那它们的类型分别是什么呢?</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">typeof</span>(<span class="literal">undefined</span>) == <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line"><span class="title function_">typeof</span>(<span class="literal">null</span>) == <span class="string">&#x27;object&#x27;</span></span><br><span class="line"><span class="title function_">typeof</span>(<span class="string">&quot;&quot;</span>) == <span class="string">&#x27;string&#x27;</span></span><br><span class="line"><span class="title function_">typeof</span>(<span class="number">0</span>) == <span class="string">&#x27;number&#x27;</span></span><br><span class="line"><span class="title function_">typeof</span>(<span class="literal">false</span>) == <span class="string">&#x27;boolean&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="喔。它们的类型各不相同。那么问题来了-，那他们进行-‘-’-和-‘-’-呢。毕竟"><a href="#喔。它们的类型各不相同。那么问题来了-，那他们进行-‘-’-和-‘-’-呢。毕竟" class="headerlink" title="喔。它们的类型各不相同。那么问题来了 ，那他们进行 ‘= =’ 和 ‘===’ 呢。毕竟:"></a>喔。它们的类型各不相同。那么问题来了 ，那他们进行 ‘= =’ 和 ‘===’ 呢。毕竟:</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="number">0</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">null</span> == <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">null</span> ==<span class="number">0</span> </span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="number">0</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h6 id="感觉有点晕，这样下去-’-‘-岂不是更加复杂-那可能要了解一下-“-”和-“-”-的区别了。"><a href="#感觉有点晕，这样下去-’-‘-岂不是更加复杂-那可能要了解一下-“-”和-“-”-的区别了。" class="headerlink" title="感觉有点晕，这样下去 ’===‘ 岂不是更加复杂.那可能要了解一下 “= =”和 “===” 的区别了。"></a>感觉有点晕，这样下去 ’===‘ 岂不是更加复杂.那可能要了解一下 “= =”和 “===” 的区别了。</h6><h5 id="相等和全等"><a href="#相等和全等" class="headerlink" title="相等和全等"></a>相等和全等</h5><h6 id="比较过程"><a href="#比较过程" class="headerlink" title="比较过程"></a>比较过程</h6><ul>
<li>双等号：</li>
<li>（1）如果两个值类型相同，再进行三个等号(===)的比较。</li>
<li> （2）如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换在比较：</li>
<li>如果一个是null，一个是undefined，那么相等。 <font color = red>mmp 我说为什么 null == undefined 原来是规定 orz =.=！。</font></li>
<li>如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较。</li>
<li>三等号:<ul>
<li>如果类型不同，就一定不相等。</li>
<li>如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是NaN，那么不相等。（判断一个值是否是NaN，只能使用isNaN( ) 来判断）<font color =red> isNAN</font></li>
<li>如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等。</li>
<li>如果两个值都是true，或是false，那么相等</li>
<li>如果两个值都引用同一个对象或是函数，那么相等，否则不相等。  <font color = red>涉及到值和引用的问题</font></li>
<li>如果两个值都是null，或是undefined，那么相等<span id="more"></span> 
<h6 id="举两个栗子："><a href="#举两个栗子：" class="headerlink" title="举两个栗子："></a>举两个栗子：</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span></span><br><span class="line"><span class="literal">true</span>   <span class="comment">//这个是规定</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="number">0</span></span><br><span class="line"><span class="literal">true</span>   <span class="comment">//数字和字符串进行双等号比较时，虽然类型吧不同，但是会把字符串转为数字，空字串会转为0，非空字符串会转为数字，如果字符串内不是纯数字就会返回NaN。</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>] == [<span class="number">1</span>]</span><br><span class="line"><span class="literal">false</span> <span class="comment">// 关于这个就比较复杂，看起来是双等号判断，但是因为他们的都是对象，所以进行了全等判断，全等判断中，JavaScript会比较其内部引用，当且仅当他们的引用指向内存中的相同对象（区域）时才相等，即他们在栈内存中的引用地址相同。其实[1] 和 [1] 根本就是两个不用的对象，他们在栈中分配了不同的地址。</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="number">0</span>  <span class="comment">//null 表示&quot;没有对象&quot;，即该处不应该有值。</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">undefined</span>)</span><br><span class="line"><span class="title class_">NaN</span>  <span class="comment">//undefined 表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。</span></span><br></pre></td></tr></table></figure>
附：<br><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/compare.png"></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span>(<span class="literal">undefined</span>) -&gt; <span class="string">&quot;undefined&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">null</span>) -&gt; <span class="string">&quot;null&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="string">&quot;&quot;</span>) -&gt; <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="number">0</span>) -&gt; <span class="string">&quot;0&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">false</span>) -&gt; <span class="string">&quot;false&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ul>
<li><p>你不懂JS：作用域与闭包 第一章：什么是作用域？</p>
<ul>
<li>作用域是一组规则，它决定了在哪里和如何查找一个变量（标识符）。这种查询也许是为了向这个变量赋值，这时变量是一个LHS引用，或者是为取得它的值，这时变量是一个RHS引用。</li>
<li>LHS引用得自赋值操作。作用域 相关的赋值可以通过 = 操作符发生，也可以通过向函数参数传递（赋予）参数值发生</li>
<li>JavaScript引擎在执行代码之前首先会编译它，这样做，它将 var a = 2; 这样的语句分割为两个分离的步骤：<ul>
<li>首先，var a 在当前 作用域 中声明。这是在最开始，代码执行之前实施的。</li>
<li>稍后，a = 2 查找这个变量（LHS引用），并且如果找到就向它赋值。</li>
</ul>
</li>
<li>如果RHS查询在嵌套的作用域的任何地方都找不到一个值，这会导致引擎抛出一个 ReferenceError；如果LHS查询在嵌套的作用域的任何地方都找不到一个值，而且如果程序没有运行在 Strict 模式下，那么全局作用域中会创建一个变量并将它交给引擎。如果是在 Strict 模式下，则也会抛出 ReferenceEroor。</li>
<li>如果RHS查询的值被找到了，但是你试着去做一些它做不到的事情，比如引用 null 或者 undefined 的属性，那么引擎会抛出错误 TypeError。</br></li>
</ul>
</li>
<li><p>你不懂JS：作用域与闭包 第二章：词法作用域</p>
<ul>
<li>词法作用域意味着作用域是由编写时函数被声明的位置的决策定义的。编译器的词法分析阶段实质上可以知道所有的标识符是在哪里和如何声明的，并如此在执行期间预测它们将如何被查询。</li>
<li>在JavaScript中有两种机制可以“欺骗”词法作用域：eval(..) 和 with 。前者可以通过对一个拥有一个或多个声明的“代码”字符串进行求值，来（在运行时）修改现存的词法作用域。后者实质上是通过将一个对象引用看作一个“作用域”，并将这个对象的属性看作作用域中的标识符，（同样，也是在运行时）创建一个全新的词法作用域。</li>
<li>这些机制的缺点是，它压制了引擎在作用域查询上进行编译期优化的能力，因为引擎不得不悲观地假定这样的优化是不合法的。这两种特性的结果就是代码将会运行的更慢。不要使用它们。</br></li>
</ul>
</li>
<li><p>你不懂JS：作用域与闭包 第三章：函数与块儿作用域</p>
<ul>
<li>在JavaScript中函数是最常见的作用域单位。在另一个函数内部声明的变量和函数，实质上对任何外围“作用域”都是“隐藏的”，这是优秀软件的一个有意的设计原则。</li>
<li>但是函数绝不是唯一的作用域单位。块儿作用域指的是这样一种想法：变量和函数可以属于任意代码块儿（一般来说，就是任意的 { .. } ），而不是仅属于外围的函数。</li>
<li>从ES3开始，try/catch 结构在 catch 子句上拥有块儿作用域。</li>
<li>在ES6中，引入了 let 关键字（ var 关键字的表兄弟）允许在任意代码块中声明变量。if (..) { let a = 2; }将会声明变量a，而它实质上劫持了 if 的 { .. } 块儿的作用域，并将自己附着在这里。</li>
<li>虽然有些人对此深信不疑，但是块儿作用域不应当被认为是 var 函数作用域的一个彻头彻尾的替代品。两种机能是共存的，而且开发者们可以并且应当同时使用函数作用域和块儿作用域技术 —— 在它们各自可以产生更好，更易读/易维护代码的地方。</li>
</ul>
</li>
</ul>
<p>ps: mmp好晕</p>
<h2 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h2><h6 id="js-中什么类型是引用传递-什么类型是值传递-如何将值类型的变量以引用的方式传递"><a href="#js-中什么类型是引用传递-什么类型是值传递-如何将值类型的变量以引用的方式传递" class="headerlink" title="js 中什么类型是引用传递, 什么类型是值传递? 如何将值类型的变量以引用的方式传递?"></a>js 中什么类型是引用传递, 什么类型是值传递? 如何将值类型的变量以引用的方式传递?</h6><ul>
<li>基本类型：存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配。<br>5种基本数据类型有Undefined、Null、Boolean、Number 和 String，它们是直接按值存放的，所以可以直接访问。</li>
<li>引用类型：存放在堆内存中的对象，变量实际保存的是一个指针，这个指针指向另一个位置。每个空间大小不一样，要根据情况开进行特定的分配。<br>当我们需要访问引用类型（如对象，数组，函数等）的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。<br><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/20180322141202_19288.png"><br>另外设计到深度拷贝和浅拷贝，到时候重写一篇。</li>
</ul>
<h2 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h2><h6 id="JavaScript-中不同类型以及不同环境下变量的内存都是何时释放"><a href="#JavaScript-中不同类型以及不同环境下变量的内存都是何时释放" class="headerlink" title="JavaScript 中不同类型以及不同环境下变量的内存都是何时释放?"></a>JavaScript 中不同类型以及不同环境下变量的内存都是何时释放?</h6><p>引用类型是在没有引用之后, 通过 v8 的 GC 自动回收, 值类型如果是处于闭包的情况下, 要等闭包没有引用才会被 GC 回收, 非闭包的情况下等待 v8 的新生代 (new space) 切换的时候回收.</p>
<p>与前端 Js 不同, 2年以上经验的 Node.js 一定要开始注意内存了, 不说对 v8 的 GC 有多了解, 基础的内存释放一定有概念了, 并且要开始注意内存泄漏的问题了.</p>
<p>你需要了解哪些操作一定会导致内存泄漏, 或者可以崩掉内存. 比如如下代码能否爆掉 V8 的内存?</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  arr.<span class="title function_">push</span>(<span class="number">1</span>);</span><br><span class="line">然后上述代码与下方的情况有什么区别?</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  arr.<span class="title function_">push</span>();</span><br><span class="line">如果 push 的是 <span class="title class_">Buffer</span> 情况又会有什么区别?</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  arr.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Buffer</span>(<span class="number">1000</span>));</span><br><span class="line">思考完之后可以尝试找找别的情况如何爆掉 <span class="variable constant_">V8</span> 的内存. 以及来聊聊内存泄漏?</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">out</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> bigData = <span class="keyword">new</span> <span class="title class_">Buffer</span>(<span class="number">100</span>);</span><br><span class="line">  inner = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">void</span> bigData;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于内存释放问题，入行尚欠，学到再补充。</p>
<h2 id="ES6-新特性"><a href="#ES6-新特性" class="headerlink" title="ES6 新特性"></a>ES6 新特性</h2><h6 id="const-定义的-Array-中间元素能否被修改-如果可以-那-const-修饰对象有什么意义"><a href="#const-定义的-Array-中间元素能否被修改-如果可以-那-const-修饰对象有什么意义" class="headerlink" title="const 定义的 Array 中间元素能否被修改? 如果可以, 那 const 修饰对象有什么意义?"></a>const 定义的 Array 中间元素能否被修改? 如果可以, 那 const 修饰对象有什么意义?</h6><ul>
<li>const 定义的 Array 中间元素能被修改，const 定义的变量只是持有 Array 的地址，这个变量只是本身不能修改，而对于存在于堆内存中的 Array 本身是可以修改的。</li>
<li>对于 const 声明，只是它的赋值操作被冻结了，而值不会因为 const 而不变。主要是预防在coding过程中的coder因为疏忽对变量的意外修改。</li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>路漫漫其修远兮，吾将上下而求索！</title>
    <url>/2018/06/26/%E8%B7%AF%E6%BC%AB%E6%BC%AB%E5%85%B6%E4%BF%AE%E8%BF%9C%E5%85%AE%EF%BC%8C%E5%90%BE%E5%B0%86%E4%B8%8A%E4%B8%8B%E8%80%8C%E6%B1%82%E7%B4%A2%EF%BC%81/</url>
    <content><![CDATA[<h2 id="如题"><a href="#如题" class="headerlink" title="如题"></a>如题</h2><h6 id="无人与我立黄昏，无人问我粥可温。"><a href="#无人与我立黄昏，无人问我粥可温。" class="headerlink" title="无人与我立黄昏，无人问我粥可温。"></a>无人与我立黄昏，无人问我粥可温。</h6><h6 id="无人与我捻熄灯，无人共我书半生。"><a href="#无人与我捻熄灯，无人共我书半生。" class="headerlink" title="无人与我捻熄灯，无人共我书半生。"></a>无人与我捻熄灯，无人共我书半生。</h6><h6 id="无人陪我夜已深，无人与我把酒分。"><a href="#无人陪我夜已深，无人与我把酒分。" class="headerlink" title="无人陪我夜已深，无人与我把酒分。"></a>无人陪我夜已深，无人与我把酒分。</h6><h6 id="无人拭我相思泪，无人梦我与前尘。"><a href="#无人拭我相思泪，无人梦我与前尘。" class="headerlink" title="无人拭我相思泪，无人梦我与前尘。"></a>无人拭我相思泪，无人梦我与前尘。</h6><h6 id="无人陪我顾星辰，无人醒我茶已冷。"><a href="#无人陪我顾星辰，无人醒我茶已冷。" class="headerlink" title="无人陪我顾星辰，无人醒我茶已冷。"></a>无人陪我顾星辰，无人醒我茶已冷。</h6><h6 id="无人听我述衷肠，无人解我心头梦。"><a href="#无人听我述衷肠，无人解我心头梦。" class="headerlink" title="无人听我述衷肠，无人解我心头梦。"></a>无人听我述衷肠，无人解我心头梦。</h6><h6 id="无人拘我言中泪，无人愁我独行路。"><a href="#无人拘我言中泪，无人愁我独行路。" class="headerlink" title="无人拘我言中泪，无人愁我独行路。"></a>无人拘我言中泪，无人愁我独行路。</h6><h6 id="回首向来萧瑟处，无人等在灯火阑珊处。"><a href="#回首向来萧瑟处，无人等在灯火阑珊处。" class="headerlink" title="回首向来萧瑟处，无人等在灯火阑珊处。"></a>回首向来萧瑟处，无人等在灯火阑珊处。</h6><h6 id="愿与执手立黄昏，愿与品茗粥尚温。"><a href="#愿与执手立黄昏，愿与品茗粥尚温。" class="headerlink" title="愿与执手立黄昏，愿与品茗粥尚温。"></a>愿与执手立黄昏，愿与品茗粥尚温。</h6><h6 id="愿与添香捻熄灯，愿与捧卷书半生。"><a href="#愿与添香捻熄灯，愿与捧卷书半生。" class="headerlink" title="愿与添香捻熄灯，愿与捧卷书半生。"></a>愿与添香捻熄灯，愿与捧卷书半生。</h6><h6 id="愿与剪烛夜已深，愿与对弈把酒分。"><a href="#愿与剪烛夜已深，愿与对弈把酒分。" class="headerlink" title="愿与剪烛夜已深，愿与对弈把酒分。"></a>愿与剪烛夜已深，愿与对弈把酒分。</h6><h6 id="愿与叠袖相拭泪，愿与入梦共前尘。"><a href="#愿与叠袖相拭泪，愿与入梦共前尘。" class="headerlink" title="愿与叠袖相拭泪，愿与入梦共前尘。"></a>愿与叠袖相拭泪，愿与入梦共前尘。</h6><h6 id="愿与赏月顾星辰，愿与烹茶清未冷。"><a href="#愿与赏月顾星辰，愿与烹茶清未冷。" class="headerlink" title="愿与赏月顾星辰，愿与烹茶清未冷。"></a>愿与赏月顾星辰，愿与烹茶清未冷。</h6><h6 id="愿与静听诉衷肠，愿与话君心头梦。"><a href="#愿与静听诉衷肠，愿与话君心头梦。" class="headerlink" title="愿与静听诉衷肠，愿与话君心头梦。"></a>愿与静听诉衷肠，愿与话君心头梦。</h6><h6 id="愿与解语心中泪，愿与共行天下路。"><a href="#愿与解语心中泪，愿与共行天下路。" class="headerlink" title="愿与解语心中泪，愿与共行天下路。"></a>愿与解语心中泪，愿与共行天下路。</h6><h6 id="回首灯火阑珊处，那人一如初见立中宵。"><a href="#回首灯火阑珊处，那人一如初见立中宵。" class="headerlink" title="回首灯火阑珊处，那人一如初见立中宵。"></a>回首灯火阑珊处，那人一如初见立中宵。</h6></br>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
</search>
