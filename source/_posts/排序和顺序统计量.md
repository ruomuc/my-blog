---
title: 排序和顺序统计量
categories:
  - 数据结构与算法
tags:
  - 算法
date: 2019-01-27 16:44:17
updated: 2019-01-27 16:44:17
cover: https://proxy.qnoss.seeln.com/images/wp4202366-aconcagua-wallpapers.jpg
---

如果输入数组中仅有常数个元素需要在排序过程中存储在数组之外，则称排序算法是**原址的**。
插入排序是一种非常快的原址排序算法。
归并排序有更好的渐进运行时间，但它的MERGE（合并）过程并不是原址的。

这里将介绍两种新的排序算法，它们可以排序任意的实数。
- 堆排序： 是一种O（nlgn）的原址排序算法，使用了一种被称为堆的重要数据结构，堆还可以用来实现优化队列。
- 快速排序：也是一种原址排序算法，实际应用中比堆排序快，与插入排序类似，快速排序的代码也很紧凑，因此运行时间中隐含的常数系数小。所以快速排序是排序大数组的常用方法。

## 堆排序
堆排序与归并排序具有相同的时间复杂度 O（nlgn）。堆排序和插入排序同样具有空间原址性：任何时候都只需要常数个额外的元素空间存储临时数据。因此，堆排序是集合了我们目前已经讨论的两种排序算法优点的一种排序算法。

##### 堆(二叉堆)
如下图，(二叉)堆是一个数组，它可以被看成一个近似的完全二叉树。树上每一个节点对应数组中的一个元素。除了最底层的外，该树是完全充满的，而且是从左向右填充。
表示堆的数组A包括两个属性：A.length(通常表示数组元素个数) A.heap-size 表示有多少个堆元素存储在该数组中。
给定一个节点下标 i,我们很容易计算得到它的父节点、左孩子和右孩子的下标：

![二叉堆](https://proxy.qnoss.seeln.com/images/erchadui.png)

二叉堆分为两种形式：最大堆和最小堆。
- 最大堆：除了根节点以外的所有节点 i 都要满足 A[PARENT(i)] >= A[i]
- 最小堆：和最大堆刚好相反。除了根节点以外的所有节点 i 都要满足 A[PARENT(i)] <= A[i]
- 在堆排序算法中，我们使用的是最大堆，最小堆通常用于构造优先队列。

##### 堆排序算法

HEAPSORT(A)
```
BUILD-MAX-HEAP(A)  //建立一个最大堆(最大堆只是根节点的元素值最大，不论非根节点的元素值大小顺序)
for i = A.length downto 2  //从堆数组的最后一个元素开始 直到第二个元素停止
	exchange A[1] with A[i]  // 这个是把堆的根节点和最后一个节点
	A.heap-size = A.heap-size -1 // 堆的有效元素个数 - 1，也就是删除刚刚交换过来的最大元素（之前的根节点元素值）
	MAX-HEAPIFY(A,1) // 维护一个新的最大堆（递归），这里每次传1进去的话，每次都会从根节点开始往下找，找到最大的为止。
```

BUILD-MAX-HEAP(A)
```
A.heap-size = A.length //这里就是 有效元素个数等于输的节点个数 是一个充满的树
for i = [A.length/2] downto 1 //这里当A.length为奇数时怎么办呢，结合上面求父节点和左右子节点的函数来看貌似是向下取整。 由于 叶节点 的个数 = A([n/2]+1..n),也就是没有子节点的节点，可以看做是一个只包含一个元素的堆。BUILD过程其实就是对除了叶节点之外的其他节点进行一次 MAX-HEAPPIFY。 
	MAX-HEAPIFY(A,i)
```
ps:上述过程其实就是，从下向上，从右向左（非叶节点）。 A。length/2其实就是下标最大的非叶节点，然后依次递减向1。

MAX-HEAPIFY(A,i)
```
l = LEFT(i) //这个函数 传参 A 和 i ，所以这里就是取上层传进来 i ，也就是非叶节点。 拿出左 子节点的下标。
r = RIGHT(i) //这里 RIGHT函数前面有说过，拿出右边子节点的下标

if l <= A.heap-size and A[l] > A[i] //如果 左子节点小标小于 A的有效元素个数，并且 左子节点处的元素值大于 下标为i处节点的元素值(即它的父节点的元素值)。
	largest = l         //那么把左子节点的下标给largest变量
else
	largest = i         //否则 把父节点的左边给 largest变量

if r <= A.heap-size and A[r] > A[largest] // 同左子节点判断方式
	largest = l
else
	largest = i
	
if largest != i	     	//这里如果发现 largest不是i ，也就是说 如果左右子节点有一个比它们的父节点元素值大的话，交换父节点 和 largest记录的那个子节点(l或r)的元素值。
	exchange A[i] with A[largest]
	MAX-HEAPIFY(A,largest)  //这里递归调用，i值变为了largest。
```

##### 优先队列

**优先队列**是一种用来维护由一组元素构成的集合S的数据结构。其中的每一个元素都有一个相关的值，称为关键字。一个**最大优先队列**支持以下操作：
- INSERT(S,x): 把元素x插入集合S中。S=S∪{x}
- MAXIMUM(S): 返回S中具有最大关键字的元素。 return A[1]
- EXTRACT-MAX(S): 去掉并返回S中具有最大关键字的元素。
- INCREASE-KEY(S,x,k): 将元素x的关键字值增加到k, 这里假设k值不小于x 的原关键字。

HEAP-EXTRACT-MAX(S) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;去掉并返回S中具有最大关键字的元素。
```
if A.heap-size < 1                    //如果有效元素值数量小于1 就说明出错
	error "heap underflow"
max = A[1]                   //因为是这里是最大堆，  把根元素的元素值 赋值给 max
A[1] = A[A.heap-size]      //把 最后一个元素值赋值给 根元素
A.heap-size = A.heap-size -1 //把 有效元素值个数 -1 。相当于把最后一个元素值赋值给根元素后删除它。
MAX-HEAPIFY(A,1)  //这里同 前文堆排序，维护一个最大堆，从 1 就是根节点开始往下。
return max 返回之前的根节点元素 ，最大值。
```

HEAP-INCREASE-KEY(A,i,key)  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将元素i的关键字值增加到k，假设k值不小于x 的原关键字
```
if key < A[i]  //因为假定的是 i的值不能大于 k的值
	error "new key is smaller than current key"
A[i] = key  //把key的值赋值给 元素i的值，相当于增加 元素i的值
while i > 1 and A[PARENT(i)] < A[i]  //如果i不是根元素  并且  i的父节点值 小于 i元素的值
	exchange A[i] with A[PARENT(i)] //交换 i和它的父节点的值
    i = PARENT(i) //更新 新的i等于 原来i的父节点下标 ，因为是while循环，所以继续循环上述步骤
```

最小优先队列和最大优先队列相反。有时间补充。

## 快速排序


未完待更。。
