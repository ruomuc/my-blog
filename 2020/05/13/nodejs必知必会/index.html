<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>nodejs必知必会 | ruomu</title><meta name="keywords" content="node.js,面试题"><meta name="author" content="ruomu"><meta name="copyright" content="ruomu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言​    怎么说呢，很多东西其实之前都整理过，但那是一个学习的过程，很多东西不够准确、严谨。突然就想把看过学过的零散知识重新整理一遍。 JavaScript基础问题类型类型判断typeof操作符一般数据类型12345678 typeof undefined; &#x2F;&#x2F; undefined typeof []; &#x2F;&#x2F; object typeof &amp;#x27;123&amp;#x27;; &#x2F;&#x2F; stringt">
<meta property="og:type" content="article">
<meta property="og:title" content="nodejs必知必会">
<meta property="og:url" content="https://ruomuc.github.io/blog/2020/05/13/nodejs%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/index.html">
<meta property="og:site_name" content="ruomu">
<meta property="og:description" content="前言​    怎么说呢，很多东西其实之前都整理过，但那是一个学习的过程，很多东西不够准确、严谨。突然就想把看过学过的零散知识重新整理一遍。 JavaScript基础问题类型类型判断typeof操作符一般数据类型12345678 typeof undefined; &#x2F;&#x2F; undefined typeof []; &#x2F;&#x2F; object typeof &amp;#x27;123&amp;#x27;; &#x2F;&#x2F; stringt">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/forestroad.jpg">
<meta property="article:published_time" content="2020-05-13T05:10:48.000Z">
<meta property="article:modified_time" content="2020-05-13T05:10:48.000Z">
<meta property="article:author" content="ruomu">
<meta property="article:tag" content="node.js">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/forestroad.jpg"><link rel="shortcut icon" href="/img/favicon2.jpg"><link rel="canonical" href="https://ruomuc.github.io/blog/2020/05/13/nodejs%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.1.1/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'nodejs必知必会',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-05-13 13:10:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="ruomu" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fa-fw fas fa-comment"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://blog-1301153828.cos.ap-shanghai.myqcloud.com/forestroad.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ruomu</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fa-fw fas fa-comment"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">nodejs必知必会</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-05-13T05:10:48.000Z" title="发表于 2020-05-13 13:10:48">2020-05-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-05-13T05:10:48.000Z" title="更新于 2020-05-13 13:10:48">2020-05-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/node-js/">node.js</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="nodejs必知必会"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    怎么说呢，很多东西其实之前都整理过，但那是一个学习的过程，很多东西不够准确、严谨。突然就想把看过学过的零散知识重新整理一遍。</p>
<h2 id="JavaScript基础问题"><a href="#JavaScript基础问题" class="headerlink" title="JavaScript基础问题"></a>JavaScript基础问题</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><h5 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h5><h6 id="一般数据类型"><a href="#一般数据类型" class="headerlink" title="一般数据类型"></a>一般数据类型</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// undefined</span></span><br><span class="line"> <span class="keyword">typeof</span> []; <span class="comment">// object</span></span><br><span class="line"> <span class="keyword">typeof</span> <span class="string">&#x27;123&#x27;</span>; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>; <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span>; <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;; <span class="string">&quot;function&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// &quot;object&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="特殊的数据类型"><a href="#特殊的数据类型" class="headerlink" title="特殊的数据类型"></a>特殊的数据类型</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// object 因为null是一个空对象</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>; <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>(<span class="string">&quot;a&quot;</span>); <span class="comment">// &quot;symbol&quot;</span></span><br></pre></td></tr></table></figure>



<h5 id="instanceof操作符"><a href="#instanceof操作符" class="headerlink" title="instanceof操作符"></a>instanceof操作符</h5><blockquote>
<p>instanceof操作符主要用来<strong>检查构造函数的原型是否在对象的原型链上</strong>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s <span class="keyword">instanceof</span> <span class="title class_">String</span>; <span class="comment">// true</span></span><br><span class="line">s <span class="keyword">instanceof</span> <span class="title class_">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>接下来让我们搞点事情：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="property">__proto__</span> = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// 这是把s变量的原型链指向，Object的原型链。</span></span><br><span class="line"></span><br><span class="line">s <span class="keyword">instanceof</span> <span class="title class_">String</span>; <span class="comment">// false</span></span><br><span class="line">s <span class="keyword">instanceof</span> <span class="title class_">Object</span>; <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>利用instanceof操作符，我们可以对自定义的对象进行判断：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span> (name) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fizz = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;fizz&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fizz <span class="keyword">instanceof</span> <span class="title class_">Animal</span> <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h5><blockquote>
<p>实际上我们也可以通过constructor属性来达到类型判断的效果：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fizz <span class="keyword">instanceof</span> <span class="title class_">Animal</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h5 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h5><p>利用toString方法基本上可以解决所有内置对象类型的判断：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">type</span> (obj) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>, obj, []).<span class="title function_">replace</span>(<span class="regexp">/^\[object\s(\w+)\]$/</span>, <span class="string">&#x27;$1&#x27;</span>).<span class="title function_">toLowerCase</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">type</span>(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;123&#x27;</span>)) <span class="comment">// string</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="类型比较"><a href="#类型比较" class="headerlink" title="类型比较"></a>类型比较</h4><h5 id="全等"><a href="#全等" class="headerlink" title="全等==="></a>全等<code>===</code></h5><ul>
<li>全等不会进行类型转换，类型不相等就是false。</li>
<li>类型相等之后会再去比较数值。<ul>
<li>基本数据类型 <code>number、string、boolean</code>会直接比较值。</li>
<li>引用数据类型 <code>Object、Array、Function</code>会比较地址。</li>
</ul>
</li>
<li><code>+0</code>和<code>-0</code>是全等的，<code>NaN</code>和<code>NaN</code>是不全等的。</li>
</ul>
<h5 id="相等"><a href="#相等" class="headerlink" title="相等=="></a>相等<code>==</code></h5><p>被比较值A \ 被比较值B | undefined | null | Number |   String   |  Boolean    | Object     |<br>| :——————-: | :——-: | :–: | :—-: | —- | :— | —- |<br>| <strong>undefined</strong>         | true | true | false | false | false | IsFalsy(B) |<br>| <strong>null</strong>              | true | true | false | false | false | IsFalsy(B) |<br>| <strong>Number</strong>            | false | false | A === B | A === ToNumber(B) | A === ToNumber(B) | A== ToPrimitive(B) |<br>| <strong>String</strong>            | false | false | ToNumber(A)===B | A === B | ToNumber(A)===ToNumber(B) | A== ToPrimitive(B) |<br>| <strong>Boolean</strong>           | false | false | ToNumber(A)===B | ToNumber(A)===ToNumber(B) | A === B | ToNumber(A) == ToPrimitive(B) |<br>| <strong>Object</strong>            | false | false | ToPrimitive(A) == B | ToPrimitive(A) == B | ToPrimitive(A) == ToNumber(B) | A === B |</p>
<ul>
<li><p>相等的比较规则是：<code>先检查类型是否相同，类型相同直接进行全等比较，类型不同根据上表中规则进行类型转化，在进行全等比较。</code></p>
</li>
<li><p>但不是所有的类型都满足上述规则。</p>
<ul>
<li>Object类型转为原始值之后，使用的相等和其他值进行比较。就是说要再比较类型，转换类型，再进行全等比较。</li>
<li>undefined和null是相等的。并且一般情况下，他们不和其他任何类型的数据相等。但是当有类似于<code>document.all</code>这种效仿<code>undefined</code>对象时，他们相等。</li>
</ul>
</li>
<li><p>转换规则：</p>
<ul>
<li><code>ToNumber(A)</code> 尝试在比较前将参数 A 转换为数字。</li>
<li><code>ToPrimitive(A)</code>通过尝试调用 A 的<code>A.toString()</code> 和 <code>A.valueOf()</code> 方法，将参数 A 转换为原始值。</li>
</ul>
</li>
</ul>
<h5 id="Object-is-value1-value2"><a href="#Object-is-value1-value2" class="headerlink" title="Object.is(value1,value2)"></a>Object.is(value1,value2)</h5><blockquote>
<p><strong><code>Object.is()</code> 判断两个值是否<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness">相同</a>。如果下列任何一项成立，则两个值相同:</strong></p>
</blockquote>
<ul>
<li>两个值都是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a></li>
<li>两个值都是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a></li>
<li>两个值都是 <code>true</code> 或者都是 <code>false</code></li>
<li>两个值是由相同个数的字符按照相同的顺序组成的字符串</li>
<li>两个值指向同一个对象</li>
<li>两个值都是数字并且<ul>
<li>都是正零 <code>+0</code></li>
<li>都是负零 <code>-0</code></li>
<li>都是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a></li>
<li>都是除零和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a> 外的其它同一个数字</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>与相等（==）和全等（===）不同点</strong>s</p>
</blockquote>
<ul>
<li>与普通<code>==</code>不同的是，<code>Object.is()</code>不会对数据进行数据类型转换。</li>
<li>与全等<code>===</code>不同的是，<code>Object.is(NaN,NaN) </code>结果是<code>true</code>，而<code>Object.is(-0,+0) </code>结果是<code>false</code>。这与<code>全等（===）</code>刚好相反。</li>
</ul>
<hr>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>关于作用域的问题<a target="_blank" rel="noopener" href="https://book.douban.com/subject/26351021/">《你不知道的 JavaScript》</a> 讲的很好, 推荐细读。这里只说一下简单围绕<code>var</code>、<code>let</code>、<code>const</code>说一下。</p>
<h5 id="var和let的区别"><a href="#var和let的区别" class="headerlink" title="var和let的区别"></a>var和let的区别</h5><p>详情请看<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/let">阮一峰老师的es6教程</a>，这里大概说几个常用的区别。</p>
<ol>
<li>let声明的变量只在当前块有效。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// let变量只在块中生效</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>let不存在变量提升。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量提升</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有变量提升会报错</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo2)</span><br><span class="line"><span class="keyword">let</span> foo2 = <span class="number">11</span>; <span class="comment">// foo2 is not defined</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>let声明变量有暂时性死区。let声明变量后，这个变量就和当前块绑定，不受外部影响。一般只要遵循先声明后使用的规范，就不会有这种问题。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">	tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// tmp is not defined</span></span><br><span class="line">	<span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>let变量不允许重复声明。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a1 = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a1 = <span class="number">1</span>; <span class="comment">// Identifier &#x27;a1&#x27; has already been declared</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func3</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a2 = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> a2 = <span class="number">1</span>; <span class="comment">// Identifier &#x27;a2&#x27; has already been declared</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func1</span>();</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> arg; <span class="comment">// Identifier &#x27;arg&#x27; has already been declared。 因为形参其实也是一个变量。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的写法都不会有问题</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> arg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg); <span class="comment">// 10</span></span><br><span class="line">  <span class="keyword">var</span> arg = <span class="number">100</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg); <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>大多数情况下，强烈建议，在函数中，尤其是for循环中使用let。因为var很容易造成一些不必要的bug。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// undefined 这里我们的本意是输出new Date()，但是由于var的变量提升，导致输出了undefined</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="number">5</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 5</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>(); <span class="comment">// 可以发现let声明的变量，如果本块内没有赋值，它回去外层作用域找值，如果有赋值，只要在本快内，都不会受到其它地方赋值的影响。</span></span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 5  这里的i本来只是for循环中用来计数的一个变量，但是循环完成后，i泄露为了全局变量。</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>let可以代替匿名自执行函数的写法，当你在for循环中调用一个异步方法时，它使用的总是循环变量的最终值。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 输出10个10</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果改写成这样</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    (<span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 输出0-9</span></span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用let声明变量更加简单</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 输出0-9，因为let声明的变量是块级变量，所以不需要使用函数调用的方式来隔离</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="const"><a href="#const" class="headerlink" title="const"></a>const</h5><ol>
<li><strong>const</strong>声明一个只读变量一旦声明，常量的值就不能变，如果再次声明会报错。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">a = <span class="number">2</span>; <span class="comment">// Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>const</strong>变量声明时，必须初始化，不能留到后面赋值</p>
</li>
<li><p><strong>const</strong>和<strong>let</strong>一样，只在块级作用域生效，不存在变量提升，存在暂时性死区</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 10</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line">        <span class="keyword">const</span> a = <span class="number">5</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>()</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>const</strong> 变量声明变量不可变的本质。</li>
</ol>
<p>基本数据类型，值存在栈中，const声明时，变量值不可改变。</p>
<p>引用数据类型，值在堆中，栈中只是一个指向这个值在堆中的一个地址，不可改变的是这个地址，而不是堆中的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.<span class="title function_">push</span>(<span class="string">&#x27;Hello&#x27;</span>); <span class="comment">// 可执行</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, a.<span class="property">length</span>) <span class="comment">// [ &#x27;Hello&#x27; ] 1</span></span><br><span class="line">a.<span class="property">length</span> = <span class="number">0</span>;    <span class="comment">// 可执行 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, a.<span class="property">length</span>) <span class="comment">// [] 0</span></span><br><span class="line">a = [<span class="string">&#x27;Dave&#x27;</span>];    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>如果要彻底冻结一个对象，使用<code>Object.freeze</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line">foo.<span class="property">prop</span> = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个冻结对象函数，递归冻结。</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">constantize</span> = (<span class="params">obj</span>) =&gt; &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj);</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>( <span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span> ) &#123;</span><br><span class="line">      <span class="title function_">constantize</span>( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><p>详情见 <a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">阮一峰老师的闭包讲解</a></p>
<ul>
<li><p>通俗来讲，就是函数外部是无法访问函数内部的变量，但是通过闭包处理，就可以在函数外部访问函数内部的变量。</p>
</li>
<li><p>引用轮子哥的话： 闭包不是私有，闭的意思不是“封闭内部状态”，而是”封闭外部状态“。</p>
</li>
<li><p>举个列子，栗子中的<code>f2</code>函数就是闭包：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">f2</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="title function_">f1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 999</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n) <span class="comment">// ReferenceError: n is not defined</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="值传递和引用传递？"><a href="#值传递和引用传递？" class="headerlink" title="值传递和引用传递？"></a>值传递和引用传递？</h3><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>​    先来看一张图</p>
<p><img src="https://blog-1301153828.cos.ap-shanghai.myqcloud.com/20180322141202_19288.png"></p>
<ul>
<li>由图可知，非基本类型，栈内存储的是实际值在堆中的一个地址，通过这个地址找到实际的值。</li>
<li>关于引用传递和传引用，js到有没有传引用，移步<a href="%5Bhttps://ruomuc.gitee.io/blog/2019/05/22/js%E4%B9%8B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/%5D(https://ruomuc.gitee.io/blog/2019/05/22/js%E4%B9%8B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/)">js之你不知道的引用传递</a></li>
</ul>
<h5 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h5><ul>
<li><p>深拷贝和浅拷贝是对JavaScript “引用传递” 的一种应用。</p>
</li>
<li><p>假设你要将一个对象复制给另一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zm&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = obj;</span><br><span class="line"></span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&#x27;ruomu&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123; name: &#x27;ruomu&#x27; &#125; 为什么我修改obj2的值，但是obj也变了呢。。因为其实他们存储了相同的地址值，指向了堆内同一对象。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zm&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: obj.<span class="property">name</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&#x27;ruomu&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123; name: &#x27;zm&#x27; &#125; 可以看到这里就不会被修改了，因为基础类型存储在栈中，修改就是直接修改栈中的值。</span></span><br></pre></td></tr></table></figure></li>
<li><p>所以使用对象赋值时要非常小心，因为node是异步的，不知道在哪里就修改了那个对象，会引起很多bug。所以通常我们想copy一个对象时，需要一些特殊的处理来达到目的。<a href="%5Bhttps://ruomuc.gitee.io/blog/2018/06/26/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/%5D(https://ruomuc.gitee.io/blog/2018/06/26/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/)">深拷贝和浅拷贝</a></p>
<ul>
<li>上面的连接有几种写好的深度拷贝方法，就不重复造轮子了。当然最简单的当然是<code>JSON.parse(JSON.stringify(obj))</code> 。</li>
</ul>
</li>
</ul>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h5 id="v8内存的大小"><a href="#v8内存的大小" class="headerlink" title="v8内存的大小"></a>v8内存的大小</h5><ul>
<li>64位下新生代的空间为64MB，老生代为1400MB。</li>
<li>32为下新生代的空间为16MB，老生代为700MB。</li>
<li>修改新生代和老生代内存的方式<ul>
<li>**<code>--max_semi_space_size=xxxx</code>**。修改新生代内存，单位为KB</li>
<li>**<code>--max-old-space-size=xxxx</code>**。修改老生代内存，单位为MB</li>
</ul>
</li>
</ul>
<h5 id="v8内存清理机制"><a href="#v8内存清理机制" class="headerlink" title="v8内存清理机制"></a>v8内存清理机制</h5><ul>
<li><a href="%5Bhttps://ruomuc.gitee.io/blog/2018/07/31/V8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6/%5D(https://ruomuc.gitee.io/blog/2018/07/31/V8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6/)">V8的垃圾回收机制和内存限制</a></li>
<li>新生代，牺牲空间换时间，只能使用新生代一半的内存。<ul>
<li>最开始的变量放在新生代的from空间</li>
<li>执行垃圾回收时，将存活的对象从新生代的from空间放到to空间，非存活对象会被释放。</li>
<li>完成从from到to空间的复制后，from空间和to空间会发生角色互换。</li>
</ul>
</li>
<li>对象晋升<ul>
<li>对象晋升发生的时间是在，将新生代from空间中存活的对象复制到to空间的时候。</li>
<li>对象晋升的条件是：<ul>
<li>新生代to空间的占用率达到25%以上，对象直接被放入老生代空间中。</li>
<li>对象已经经历过一次新生代空间（Scavenge）的回收。</li>
</ul>
</li>
</ul>
</li>
<li>老生代空间<ul>
<li>老生代空间的对象一般都是存活时间比较久的对象，所以如果采用新生代空间的<code>Scavenge</code>算法，复制对象效率会很低，而且空间会浪费一半。所以v8老生代空间主要采用了<code>Mark-Sweep</code>和<code>Mark-Compact</code>相结合的方式进行垃圾回收。</li>
<li>Mark-Sweep是标记清除的意思，它分为标记阶段和清除阶段。它最大的问题是，清理完成后，内存空间会不连续。<ul>
<li>标记阶段。遍历堆中所有的对象，并标记活着的对象。</li>
<li>清除阶段。清除没有被标记的对象。</li>
</ul>
</li>
<li>Mark-Compact是标记整理的意思，它分为标记，整理，清除三步。它的问题是速度比较慢，但是内存空间是连续的。<ul>
<li>标记和Mark-Sweep一样</li>
<li>整理。将活着的对象往一端移动。</li>
<li>清除。活着的对象移动完成后，清除掉边界外的内存。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="如何高效的使用内存"><a href="#如何高效的使用内存" class="headerlink" title="如何高效的使用内存"></a>如何高效的使用内存</h5><blockquote>
<p>内存被释放条件是，该对象没有被引用。</p>
</blockquote>
<ul>
<li><p>全部变量的释放条件是进程退出。所以全部变量会长时间存在于老生代内存中，所以尽量少定义全局变量，并及时对全局变量进行释放。</p>
<ul>
<li><code>global.foo = undefined</code>或者<code>delete global.foo</code></li>
<li>上面两种方式并不会释放掉原本<code>global.foo</code>指向的对象，而是取消对其的引用，在下一次gc的时候，如果没有其他指向其的引用，那么就会被释放。</li>
</ul>
</li>
<li><p>闭包可以实现外部作用域访问内部作用域中的变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">f2</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="title function_">f1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>引用上面闭包用到的一段代码。正常情况下，f1执行完成后，函数作用域内的变量都会随着作用域的销毁而被回收。但是这里的<code>b</code>保持对f2的引用，而f2访问了变量n，所以这里的函数和变量都不会被释放。</p>
</li>
<li><p>滥用闭包是内存泄露的重要原因之一。</p>
</li>
</ul>
</li>
</ul>
<h5 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h5><blockquote>
<p>内存泄露的排查还是比较复杂，需要配合日志和性能监控工具排查，这里只简单说几种情况。</p>
</blockquote>
<ul>
<li>缓存。（请使用redis或者buffer）</li>
<li>消费队列。（同上）</li>
<li>作用域未释放。（闭包）</li>
<li>cnode上面一个大佬写的<a target="_blank" rel="noopener" href="https://cnodejs.org/topic/58eb5d378cda07442731569f"><strong>轻松排查线上Node内存泄漏问题</strong></a></li>
</ul>
<h5 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h5><p>​    看了下，网上关于node内存监控的东西很少，但最后试了下还是alinode最方便，对代码没有侵入。<a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/60338.html?spm=a2c4g.11174283.3.1.119930b1FamJTU">5分钟入门alinode</a></p>
<ul>
<li>安全问题。alinode好像没有开源，但是部署在本机上给alinode上传数据的agenthub是开源了的，可以自己抓包或者查看源代码，检查其是否上传敏感数据。</li>
<li>付费。目前alinode好像完全免费的，至于以后会不会收费，不知道。</li>
</ul>
<h3 id="es6基本语法"><a href="#es6基本语法" class="headerlink" title="es6基本语法"></a>es6基本语法</h3><p><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/">阮一峰老师的es入门教程</a></p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ul>
<li><p><a href="%5Bhttps://ruomuc.gitee.io/blog/2018/07/03/node-js%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/%5D(https://ruomuc.gitee.io/blog/2018/07/03/node-js%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/)">模块机制整理</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://nodejs.cn/api/modules.html#modules_modules">官方模块文档</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://cnodejs.org/topic/5734017ac3e4ef7657ab1215">exports和module.exports的区别</a></p>
<ul>
<li>总结一下就是，一直用module.exports总不会错的。</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="http://nodejs.cn/api/modules.html#modules_the_module_wrapper">模块封装器</a></p>
<ul>
<li>所以说通过<code>var let const </code>的作用范围是当前模块，而不加修饰的变量定义会造成全局污染，因为模块的作用域其实是函数作用域。</li>
</ul>
</li>
<li><p>为什么包装在全局的时候，项目中使用的时候会找不到。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000019198107">https://segmentfault.com/a/1190000019198107</a></li>
<li>node扫描包的顺序是，<strong>从当前层向外层依次找node_modules文件夹</strong>，全局包的安装路径不符合这个规则的，所以找不到。</li>
</ul>
</li>
</ul>
<h2 id="事件-异步"><a href="#事件-异步" class="headerlink" title="事件/异步"></a>事件/异步</h2><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>​    详情可以看<a target="_blank" rel="noopener" href="https://javascript.ruanyifeng.com/advanced/promise.html#toc9">阮一峰老师写的Promise对象</a></p>
<ul>
<li><p>Promise 的设计思想就是，所有异步任务都返回一个Promise实例。</p>
</li>
<li><p>Promise对象的状态：</p>
<ul>
<li>异步操作未完成（pending）</li>
<li>异步操作成功（fulfilled）</li>
<li>异步操作失败（rejected）</li>
</ul>
</li>
<li><p>Promise的状态变化的特点：</p>
<ul>
<li>只能从未完成（pending） ——&gt; 操作成功（fulfilled）/ 操作失败（rejected）。</li>
<li>状态一旦发生变化就不会再次改变。</li>
</ul>
</li>
<li><p>JavaScript提供原生的构造函数，用来生成Promise实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 异步操作失败 */</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>resolve的作用是把promise实例的状态从未完成（pending） ——&gt; 操作成功（fulfilled）</li>
<li>rejected的作用是把promise实例的状态从未完成（pending） ——&gt;操作失败（rejected）</li>
</ul>
</li>
<li><p>异常捕获</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auto.<span class="title function_">getData</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">results</span>) &#123;</span><br><span class="line">     res.<span class="title function_">send</span>(results);</span><br><span class="line">&#125;, next);</span><br><span class="line">auto.<span class="title function_">getData</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">results</span>) &#123;</span><br><span class="line">     res.<span class="title function_">send</span>(results);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(next);</span><br></pre></td></tr></table></figure>

<ul>
<li>上述两种写法，第一种写法，只能捕获getData()产生的错误，而第二种写法，可以捕获到整个Promise调用链中的错误。</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/58428287">Promise的实现原理</a></p>
</li>
</ul>
<h3 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h3><ul>
<li><code>Events</code>是node.js一个非常重要的 core 模块，比如 <code>Stream</code> 是基于 <code>Events</code> 实现的, 而 <code>fs</code>, <code>net</code>, <code>http</code> 等模块都依赖 <code>Stream</code></li>
<li>另外可以注意一下的是, 有些同学喜欢用 emitter 来监控某些类的状态, 但是在这些类释放的时候可能会忘记释放 emitter, 而这些类的内部可能持有该 emitter 的 listener 的引用从而导致内存泄漏</li>
</ul>
<h3 id="阻塞-异步"><a href="#阻塞-异步" class="headerlink" title="阻塞/异步"></a>阻塞/异步</h3><ul>
<li><p>如何判断接口是否异步? 是否只要有回调函数就是异步?</p>
<ul>
<li>看文档</li>
<li>console.log 打印看看</li>
<li>看是否有 IO 操作</li>
</ul>
</li>
<li><p>阻塞/非阻塞？异步同步？</p>
<ul>
<li>之前面试被问到过，我的理解如下：</li>
<li>假设面试完之后，HR给你打电话，告诉你你被录用了。如果你直接告诉了HR你同意或是拒绝，这就是**<code>同步</code><strong>，如果你说，我现在没时间，过两天再给你答复，这样就是</strong><code>异步</code><strong>；HR在听到你说过两天给他答复时，她继续去给下一个求职者打电话，这样就是</strong><code>非阻塞</code><strong>，如果HR什么都不敢，一直等着你的回复，这就是</strong><code>阻塞</code>**。</li>
<li>我不知道理解的有没有问题。。。知乎上搜了很多，大概也是这么个意思。</li>
</ul>
</li>
<li><p>死循环对js的项目会有什么影响？</p>
<ul>
<li>Node.js 中执行 js 代码的过程是单线程的. 只有当前代码都执行完, 才会切入事件循环, 然后从事件队列中 pop 出下一个回调函数开始执行代码。</li>
<li>所以死循环就会让服务器停止所有响应，如果死循环里面有其他操作可能就会栈溢出或者内存溢出直接挂掉。</li>
</ul>
</li>
<li><p>一个简单的sleep函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>(), expire = start + ms;</span><br><span class="line">  <span class="keyword">while</span> (<span class="title class_">Date</span>.<span class="title function_">now</span>() &lt; expire) ;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>如何实现一个异步的 reduce?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">getPromise</span> = (<span class="params">key</span>) =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reduce item:&#x27;</span>, key ** <span class="number">2</span>)</span><br><span class="line">            <span class="title function_">resolve</span>(key ** <span class="number">2</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reduce start&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reduce result:&#x27;</span>, <span class="keyword">await</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="title function_">reduce</span>(<span class="function">(<span class="params">result, cursor</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> <span class="title function_">result</span>() + <span class="keyword">await</span> <span class="title function_">getPromise</span>(cursor)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">async</span> () =&gt; <span class="number">0</span>)())</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reduce end&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event-loop"></a>Event-loop</h3><p>​    <a target="_blank" rel="noopener" href="https://cnodejs.org/topic/5a9108d78d6e16e56bb80882"><strong>不要混淆nodejs和浏览器中的event loop</strong></a>是我在cnode论坛上看到的一篇有关时间循环的文章。而且这个东西只要你搞清楚下面那几个异步调用的执行顺序，更深的东西也没必要花时间去研究，意义不大。。</p>
<ul>
<li><p>timers：执行<code>setTimeout()</code> 和 <code>setInterval()</code>中到期的callback。</p>
</li>
<li><p>I/O callbacks：上一轮循环中有少数的I/Ocallback会被延迟到这一轮的这一阶段执行</p>
</li>
<li><p>idle, prepare：仅内部使用</p>
</li>
<li><p>poll：最为重要的阶段，执行I/O callback，在适当的条件下会阻塞在这个阶段</p>
</li>
<li><p>check：执行<code>setImmediate</code>的callback</p>
</li>
<li><p>close callbacks：执行close事件的callback，例如<code>socket.on(&quot;close&quot;,func)</code></p>
</li>
<li><p><strong>补充说明：<code>process.nextTick()</code>在每个阶段结束都会执行。如果你仅仅是想产生一个异步调用，建议使用<code>setImmediate。</code></strong> </p>
</li>
</ul>
<blockquote>
<p>看懂下面这段的输出就大概知道执行顺序了，另外<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25407758">知乎的这篇文章也可以帮你理解</a>。</p>
<p>我们分析一下：</p>
<ol>
<li>setTimeout 和 setInterval  是回调执行是在  Timers阶段，setImmediate 回调执行是在 check 阶段，并且他们都会被放到下一轮执行，所以肯定是后三个输出，并且 setImmediate 在最后。</li>
<li>Promise.then 和 process.nextTick，点击上面那个《不要混淆nodejs和浏览器中的event loop》，根据大佬分析可知， process.nextTick是在每一个阶段结尾都会执行，并且在结尾调用了<code>      runMicrotasks();//microtasks将会在此时执行，例如Promise</code> ，所以Promise.then是在process.nextTick后面一丢丢执行。</li>
<li>setTimeout 和 setInterval 执行顺序取决于谁先被放进回调队列。这样输出结果就完全解释的通了。</li>
</ol>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;interval&#x27;</span>)</span><br><span class="line">	<span class="built_in">clearInterval</span>(interval)</span><br><span class="line">&#125;, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;immediate&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick&#x27;</span>) &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promiseFun = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="title function_">resolve</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promiseFun</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise&#x27;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入顺序如下</span></span><br><span class="line">nextTick</span><br><span class="line">promise</span><br><span class="line">timeout</span><br><span class="line">interval</span><br><span class="line">immediate</span><br></pre></td></tr></table></figure>



<h3 id="并行-并发"><a href="#并行-并发" class="headerlink" title="并行/并发"></a>并行/并发</h3><p>​    转一张图，其实这里大部分东西都是根据eleme那个大佬发的内容整理的，最后我会把引用的文章或帖子尽量都贴出来。</p>
<p><img src="https://camo.githubusercontent.com/a986e69f6ef3236fda5fb7e0e0e9b5cb1133f6ba/687474703a2f2f6a6f6561726d732e6769746875622e696f2f696d616765732f636f6e5f616e645f7061722e6a7067"></p>
<ul>
<li><p>什么是并发： 两个人用一个咖啡机。</p>
</li>
<li><p>什么是并行：两队人用两个咖啡机。</p>
</li>
<li><p>node中的并发： </p>
<ul>
<li>Node.js 通过事件循环来挨个抽取事件队列中的一个个 Task 执行, 从而避免了传统的多线程情况下 <code>2个队列对应 1个咖啡机</code> 的时候上下文切换以及资源争抢/同步的问题。</li>
<li>node的大并发只是拿到请求就扔进队列而已，并不是自己处理能力有多厉害，所以说适合I/O密集型业务，CPU密集型业务的话需要一定的优化(算法，c++扩展)并且没有那么擅长把。。</li>
</ul>
</li>
<li><p>node的并行： 通过 <code>cluster</code> 来添加一个咖啡机。</p>
</li>
</ul>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><blockquote>
<p>了解进程前，先看看<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIyNDU2NTc5Mw==&mid=2247483699&idx=1&sn=a64b349baa8662c27ac211de130eb28b&chksm=e80c4e7ddf7bc76b7869f74605588a6bd3f6a960d9cb19b1a9c4e3518156092c9fc25bf74d54&scene=21#wechat_redirect">进程和线程的区别</a></p>
</blockquote>
<h3 id="process"><a href="#process" class="headerlink" title="process"></a><a target="_blank" rel="noopener" href="http://nodejs.cn/api/process.html#process_process">process</a></h3><ul>
<li><p>前文提到的process.nextTick也是process的一个方法，那么递归调用呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick&#x27;</span>);</span><br><span class="line">  process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="title function_">test</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会不停的输出nextTick,因为这样永远跳不出本轮循环。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">test</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也会不停的输出timeout，但是不会阻塞其它异步回调，因为总是插入到下一次循环。</span></span><br></pre></td></tr></table></figure></li>
<li><p>进程的当前工作目录是什么? 有什么作用?</p>
<ul>
<li>当前进程启动的目录, 通过<code>process.cwd()</code>获取当前工作目录 (current working directory), 通常是命令行启动的时候所在的目录 (也可以在启动时指定), 文件操作等使用相对路径的时候会相对当前工作目录来获取文件.</li>
</ul>
</li>
</ul>
<h3 id="标准流"><a href="#标准流" class="headerlink" title="标准流"></a>标准流</h3><p>​    <code>process.stderr</code>, <code>process.stdout</code> 以及 <code>process.stdin</code> 三个标准流</p>
<ul>
<li><p><code>console.log</code> 是同步还是异步? </p>
<ul>
<li><code>console.log</code>同步还是异步要取决于操作系统。详见<a target="_blank" rel="noopener" href="http://nodejs.cn/api/process.html#process_a_note_on_process_i_o">进程 I/O 的注意事项</a></li>
</ul>
</li>
<li><p>如何实现一个 console.log?可以参见<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/79562970">Console 模块解读及简单实现</a></p>
<ul>
<li>其实核心的话就是这句<code>    process.stdout.**write**(params);</code>。。</li>
</ul>
</li>
</ul>
<h3 id="Child-Process"><a href="#Child-Process" class="headerlink" title="Child Process"></a>Child Process</h3><ul>
<li><p>spawn() 启动一个子进程来执行命令</p>
<ul>
<li>options.detached 父进程死后是否允许子进程存活</li>
<li>options.stdio 指定子进程的三个标准流</li>
</ul>
</li>
<li><p>spawnSync() 同步版的 spawn, 可指定超时, 返回的对象可获得子进程的情况</p>
</li>
<li><p>exec() 启动一个子进程来执行命令, 带回调参数获知子进程的情况, 可指定进程运行的超时时间</p>
</li>
<li><p>execSync() 同步版的 exec(), 可指定超时, 返回子进程的输出 (stdout)</p>
</li>
<li><p>execFile() 启动一个子进程来执行一个可执行文件, 可指定进程运行的超时时间</p>
</li>
<li><p>execFileSync() 同步版的 execFile(), 返回子进程的输出, 如何超时或者 exit code 不为 0, 会直接 throw Error</p>
</li>
<li><p>fork() 加强版的 spawn(), 返回值是 ChildProcess 对象可以与子进程交互</p>
</li>
<li><p>child_process.fork 与 POSIX 的 fork 有什么区别?</p>
<ul>
<li>Node.js 的 <code>child_process.fork()</code> 在 Unix 上的实现最终调用了 POSIX <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/fork.2.html">fork(2)</a>, 而 POSIX 的 fork 需要手动管理子进程的资源释放 (waitpid), child_process.fork 则不用关心这个问题, Node.js 会自动释放, 并且可以在 option 中选择父进程死后是否允许子进程存活。</li>
</ul>
</li>
<li><p><code>child.kill</code> 与 <code>child.send</code> 的区别?</p>
<ul>
<li>前者基于信号系统，后者基于IPC通道。</li>
</ul>
</li>
<li><p>父进程或子进程的死亡是否会影响对方? 什么是孤儿进程?</p>
<ul>
<li>子进程死亡不会影响父进程, 不过子进程死亡时（线程组的最后一个线程，通常是“领头”线程死亡时），会向它的父进程发送死亡信号. 反之父进程死亡, 一般情况下子进程也会随之死亡, 但如果此时子进程处于可运行态、僵死状态等等的话, 子进程将被<code>进程1</code>（init 进程）收养，从而成为孤儿进程. 另外, 子进程死亡的时候（处于“终止状态”），父进程没有及时调用 <code>wait()</code> 或 <code>waitpid()</code> 来返回死亡进程的相关信息，此时子进程还有一个 <code>PCB</code> 残留在进程表中，被称作僵尸进程。</li>
</ul>
</li>
</ul>
<h3 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a><a target="_blank" rel="noopener" href="http://nodejs.cn/api/cluster.html#cluster_cluster">Cluster</a></h3><ul>
<li>worker 进程是由 child_process.fork() 方法创建的, 所以可以通过 IPC 在主进程和子进程之间相互传递服务器句柄。</li>
<li>cluster 模块提供了两种分发连接的方式。<ul>
<li>第一种方式 (默认方式, 不适用于 windows), 通过时间片轮转法（round-robin）分发连接. 主进程监听端口, 接收到新连接之后, 通过时间片轮转法来决定将接收到的客户端的 socket 句柄传递给指定的 worker 处理. 至于每个连接由哪个 worker 来处理, 完全由内置的循环算法决定</li>
<li>第二种方式是由主进程创建 socket 监听端口后, 将 socket 句柄直接分发给相应的 worker, 然后当连接进来时, 就直接由相应的 worker 来接收连接并处理</li>
<li>使用第二种方式时理论上性能应该较高, 然后时间上存在负载不均衡的问题, 比如通常 70% 的连接仅被 8 个进程中的 2 个处理, 而其他进程比较清闲</li>
</ul>
</li>
</ul>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>​    IPC (Inter-process communication) 进程间通信技术. 常见的进程间通信技术列表如下:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>无连接</th>
<th>可靠</th>
<th>流控制</th>
<th>优先级</th>
</tr>
</thead>
<tbody><tr>
<td>普通PIPE</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>命名PIPE</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>消息队列</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>信号量</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>共享存储</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>UNIX流SOCKET</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>UNIX数据包SOCKET</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
</tbody></table>
<blockquote>
<p>在 IPC 通道建立之前, 父进程与子进程是怎么通信的? 如果没有通信, 那 IPC 是怎么建立的?</p>
</blockquote>
<p>​    在通过 child_process 建立子进程的时候, 是可以指定子进程的 env (环境变量) 的. 所以 Node.js 在启动子进程的时候, 主进程先建立 IPC 频道, 然后将 IPC 频道的 fd (文件描述符) 通过环境变量 (<code>NODE_CHANNEL_FD</code>) 的方式传递给子进程, 然后子进程通过 fd 连上 IPC 与父进程建立连接</p>
<blockquote>
<p>什么是 IPC 通信，如何建立 IPC 通信？什么场景下需要用到 IPC 通信？</p>
</blockquote>
<p>​    IPC (Inter-process communication) ，即进程间通信技术，由于每个进程创建之后都有自己的独立地址空间，实现 IPC 的目的就是为了进程之间资源共享访问。实现 IPC 的方式有多种：管道、消息队列、信号量、Domain Socket，Node.js 通过 pipe 来实现。</p>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><blockquote>
<p>什么是守护进程？</p>
</blockquote>
<p>​    简单说就是不会因为用户退出终端而停止运行的进程。</p>
<blockquote>
<p>pm2就是一个以守护进程启动nodejs应用的工具，<a target="_blank" rel="noopener" href="https://cnodejs.org/topic/57adfadf476898b472247eac">如何编写一个守护进程?</a></p>
</blockquote>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><h4 id="什么是Buffer"><a href="#什么是Buffer" class="headerlink" title="什么是Buffer?"></a>什么是Buffer?</h4><ul>
<li>Buffer 是 Node.js 中用于处理二进制数据的类。</li>
<li>Buffer类的实例非常类似整数数组，但Buffer实例创建之后其<code>大小是固定不变的</code>。</li>
</ul>
<h4 id="Buffer支持的字符编码？"><a href="#Buffer支持的字符编码？" class="headerlink" title="Buffer支持的字符编码？"></a>Buffer支持的字符编码？</h4><ul>
<li><strong>ascii</strong> - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。</li>
<li><strong>utf8</strong> - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。</li>
<li><strong>utf16le</strong> - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。</li>
<li><strong>ucs2</strong> - <strong>utf16le</strong> 的别名。</li>
<li><strong>base64</strong> - Base64 编码。</li>
<li><strong>latin1</strong> - 一种把 <strong>Buffer</strong> 编码成一字节编码的字符串的方式。</li>
<li><strong>binary</strong> - <strong>latin1</strong> 的别名。</li>
<li><strong>hex</strong> - 将每个字节编码为两个十六进制字符。</li>
</ul>
<h4 id="创建Buffer实例的方法？"><a href="#创建Buffer实例的方法？" class="headerlink" title="创建Buffer实例的方法？"></a>创建Buffer实例的方法？</h4><ul>
<li><p><strong>Buffer.alloc(size[, fill[, encoding]])：</strong> 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0</p>
</li>
<li><p><strong>Buffer.allocUnsafe(size)：</strong> 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据</p>
</li>
<li><p><strong>Buffer.allocUnsafeSlow(size)</strong></p>
</li>
<li><p><strong>Buffer.from(array)：</strong> 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）</p>
</li>
<li><p><strong>Buffer.from(arrayBuffer[, byteOffset[, length]])：</strong> 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。</p>
</li>
<li><p><strong>Buffer.from(buffer)：</strong> 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例</p>
</li>
<li><p><strong>Buffer.from(string[, encoding])：</strong> 返回一个被 string 的值初始化的新的 Buffer 实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf1 = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">10</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf1); <span class="comment">// &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</span></span><br><span class="line"><span class="keyword">const</span> buf2 = <span class="title class_">Buffer</span>.<span class="title function_">allocUnsafe</span>(<span class="number">10</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf2) <span class="comment">// &lt;Buffer 4c 46 80 05 01 00 00 00 4c 46&gt;</span></span><br><span class="line"><span class="keyword">const</span> buf3 = <span class="title class_">Buffer</span>.<span class="title function_">allocUnsafe</span>(<span class="number">10</span>).<span class="title function_">fill</span>(<span class="number">0</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf3); <span class="comment">// &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Buffer常用操作？"><a href="#Buffer常用操作？" class="headerlink" title="Buffer常用操作？"></a><a target="_blank" rel="noopener" href="https://www.runoob.com/nodejs/nodejs-buffer.html">Buffer常用操作</a>？</h4><ul>
<li><p>写入缓冲区<code>buf.write(string[, offset[, length]][, encoding])</code></p>
</li>
<li><p>从缓冲区读取数据 <code>buf.toString([encoding[, start[, end]]])</code></p>
</li>
<li><p>将 Buffer 转换为 JSON 对象 <code>buf.toJSON()</code></p>
</li>
<li><p>缓冲区合并 <code>Buffer.concat(list[, totalLength])</code></p>
</li>
<li><p>缓冲区比较 <code>buf.compare(otherBuffer);</code></p>
<ul>
<li>返回值小于 0 。<code>buf</code>在<code>otherBuffer</code>之前</li>
<li>返回值等于 0 。<code>buf</code>和<code>otherBuffer</code>相同</li>
<li>返回值大于 0 。<code>buf</code>在<code>otherBuffer</code>之后</li>
</ul>
</li>
<li><p>拷贝缓冲区<code>buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</code></p>
<ul>
<li>把 buf9插入到buf10的第三位。  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf9 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;zmaaaassss&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> buf10 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;ruomu&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf9) <span class="comment">// &lt;Buffer 7a 6d 61 61 61 61 73 73 73 73&gt;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf10) <span class="comment">// &lt;Buffer 72 75 6f 6d 75&gt;</span></span><br><span class="line">buf9.<span class="title function_">copy</span>(buf10,<span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf10); <span class="comment">// &lt;Buffer 72 75 6f 7a 6d&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="String-Decoder"><a href="#String-Decoder" class="headerlink" title="String Decoder"></a><a target="_blank" rel="noopener" href="http://nodejs.cn/api/string_decoder.html#string_decoder_string_decoder">String Decoder</a></h3><p>​    字符串解码器 (String Decoder) 是一个用于将 Buffer 拿来 decode 到 string 的模块, 是作为 Buffer.toString 的一个补充, 它支持多字节 UTF-8 和 UTF-16 字符。</p>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a><a target="_blank" rel="noopener" href="http://nodejs.cn/api/stream.html#stream_stream">Stream</a></h3><h4 id="流的类型"><a href="#流的类型" class="headerlink" title="流的类型"></a>流的类型</h4><ul>
<li><a target="_blank" rel="noopener" href="http://nodejs.cn/s/9JUnJ8"><code>Writable</code></a> - 可写入数据的流（例如 <a target="_blank" rel="noopener" href="http://nodejs.cn/s/VdSJQa"><code>fs.createWriteStream()</code></a>）。</li>
<li><a target="_blank" rel="noopener" href="http://nodejs.cn/s/YuDKX1"><code>Readable</code></a> - 可读取数据的流（例如 <a target="_blank" rel="noopener" href="http://nodejs.cn/s/wiVPXD"><code>fs.createReadStream()</code></a>）。</li>
<li><a target="_blank" rel="noopener" href="http://nodejs.cn/s/2iRabr"><code>Duplex</code></a> - 可读又可写的流（例如 <a target="_blank" rel="noopener" href="http://nodejs.cn/s/wsJ1o1"><code>net.Socket</code></a>）。</li>
<li><a target="_blank" rel="noopener" href="http://nodejs.cn/s/fhVJQM"><code>Transform</code></a> - 在读写过程中可以修改或转换数据的 <code>Duplex</code> 流（例如 <a target="_blank" rel="noopener" href="http://nodejs.cn/s/n6ED45"><code>zlib.createDeflate()</code></a>）。</li>
</ul>
<h2 id="Netword"><a href="#Netword" class="headerlink" title="Netword"></a>Netword</h2><h3 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h3><p>可以参见网上流传比较广的一个例子, 连续调用两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下几种常见的情况:</p>
<ul>
<li>A. 先接收到 data1, 然后接收到 data2 .</li>
<li>B. 先接收到 data1 的部分数据, 然后接收到 data1 余下的部分以及 data2 的全部.</li>
<li>C. 先接收到了 data1 的全部数据和 data2 的部分数据, 然后接收到了 data2 的余下的数据.</li>
<li>D. 一次性接收到了 data1 和 data2 的全部数据.</li>
</ul>
<p>其中的 BCD 就是我们常见的粘包的情况. 而对于处理粘包的问题, 常见的解决方案有:</p>
<ul>
<li>多次发送之前间隔一个等待时间<ul>
<li>只需要等上一段时间再进行下一次 send 就好, 适用于交互频率特别低的场景. 缺点也很明显, 对于比较频繁的场景而言传输效率实在太低. 不过几乎不用做什么处理。</li>
</ul>
</li>
<li>关闭 Nagle 算法<ul>
<li>关闭 Nagle 算法, 在 Node.js 中你可以通过 <a target="_blank" rel="noopener" href="https://nodejs.org/dist/latest-v6.x/docs/api/net.html#net_socket_setnodelay_nodelay"><code>socket.setNoDelay()</code></a> 方法来关闭 Nagle 算法, 让每一次 send 都不缓冲直接发送。该方法比较适用于每次发送的数据都比较大 (但不是文件那么大), 并且频率不是特别高的场景. 如果是每次发送的数据量比较小, 并且频率特别高的, 关闭 Nagle 纯属自废武功。</li>
</ul>
</li>
<li>进行封包/拆包<ul>
<li>封包/拆包是目前业内常见的解决方案了. 即给每个数据包在发送之前, 于其前/后放一些有特征的数据, 然后收到数据的时候根据特征数据分割出来各个数据包。</li>
</ul>
</li>
</ul>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><table>
<thead>
<tr>
<th>协议</th>
<th>连接性</th>
<th>双工性</th>
<th>可靠性</th>
<th>有序性</th>
<th>有界性</th>
<th>拥塞控制</th>
<th>传输速度</th>
<th>量级</th>
<th>头部大小</th>
</tr>
</thead>
<tbody><tr>
<td>TCP</td>
<td>面向连接 (Connection oriented)</td>
<td>全双工(1:1)</td>
<td>可靠 (重传机制)</td>
<td>有序 (通过SYN排序)</td>
<td>无, 有粘包情况</td>
<td>有</td>
<td>慢</td>
<td>低</td>
<td>20~60字节</td>
</tr>
<tr>
<td>UDP</td>
<td>无连接 (Connection less)</td>
<td>n:m</td>
<td>不可靠 (丢包后数据丢失)</td>
<td>无序</td>
<td>有消息边界, <strong>无粘包</strong></td>
<td>无</td>
<td>快</td>
<td>高</td>
<td>8字节</td>
</tr>
</tbody></table>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul>
<li>GET 和 POST 有什么区别?<ul>
<li>只有语义上的区别，你可以不遵守。</li>
<li>GET产生一个TCP数据包；POST产生两个TCP数据包。但是有些浏览器POST只发一个数据包。</li>
</ul>
</li>
<li>POST 和 PUT 有什么区别?<ul>
<li>POST 是新建 (create) 资源, 非幂等, 同一个请求如果重复 POST 会新建多个资源。</li>
<li>PUT 是 Update/Replace, 幂等, 同一个 PUT 请求重复操作会得到同样的结果。</li>
</ul>
</li>
</ul>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><ul>
<li><p>DNS 模块中 .lookup 与 .resolve 的区别?</p>
<ul>
<li><table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
<th>同步</th>
<th>网络请求</th>
<th>速度</th>
</tr>
</thead>
<tbody><tr>
<td>.lookup(hostname[, options], cb)</td>
<td>通过系统自带的 DNS 缓存 (如 <code>/etc/hosts</code>)</td>
<td>同步</td>
<td>无</td>
<td>快</td>
</tr>
<tr>
<td>.resolve(hostname[, rrtype], cb)</td>
<td>通过系统配置的 DNS 服务器指定的记录 (rrtype指定)</td>
<td>异步</td>
<td>有</td>
<td>慢</td>
</tr>
</tbody></table>
</li>
<li><p>当你要解析一个域名的 ip 时, 通过 .lookup 查询直接调用 <code>getaddrinfo</code> 来拿取地址, 速度很快, 但是如果本地的 hosts 文件被修改了, .lookup 就会拿 hosts 文件中的地方, 而 .resolve 依旧是外部正常的地址。</p>
</li>
</ul>
</li>
<li><p>hosts 文件是什么? 什么叫 DNS 本地解析?</p>
<ul>
<li>hosts 文件是个没有扩展名的系统文件, 其作用就是将网址域名与其对应的 IP 地址建立一个关联“数据库”, 当用户在浏览器中输入一个需要登录的网址时, 系统会首先自动从 hosts 文件中寻找对应的IP地址。</li>
</ul>
</li>
</ul>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>​    RPC (Remote Procedure Call Protocol) 基于 TCP/IP 来实现调用远程服务器的方法, 与 http 同属应用层. 常用于构建集群, 以及微服务 </p>
<h4 id="常见的RPC方式"><a href="#常见的RPC方式" class="headerlink" title="常见的RPC方式"></a>常见的RPC方式</h4><ul>
<li>Thrift<ul>
<li><strong>Thrift</strong>是一种由FaceBook为“大规模跨语言服务”开发的接口描述语言](<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80)%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E3%80%82">https://zh.wikipedia.org/wiki/接口描述语言)和二进制通讯协议。</a></li>
</ul>
</li>
<li>HTTP<ul>
<li>使用 HTTP 协议来进行 RPC 调用也是很常见的, 相比 TCP 连接, 通过通过 HTTP 的方式性能会差一些, 但是在使用以及调试上会简单一些. 近期比较有名的框架参见 <a target="_blank" rel="noopener" href="http://www.grpc.io/">gRPC</a>。</li>
</ul>
</li>
<li>MQ<ul>
<li>使用消息队列 (Message Queue) 来进行 RPC 调用 (RPC over mq) 在业内有不少例子, 比较适合业务解耦/广播/限流等场景.</li>
</ul>
</li>
</ul>
<h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><h3 id="TTY"><a href="#TTY" class="headerlink" title="TTY"></a>TTY</h3><p>​    “tty” 原意是指 “teletype” 即打字机, “pty” 则是 “pseudo-teletype” 即伪打字机. 在 Unix 中, <code>/dev/tty*</code> 是指任何表现的像打字机的设备, 例如终端 (terminal)。</p>
<ul>
<li><p>使用w命令可以看到当前登录的用户情况</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">USER     TTY      FROM              LOGIN@  IDLE WHAT</span><br><span class="line">zhangming console  -                27 420  13days -</span><br><span class="line">zhangming s002     -                日17       - -zsh</span><br><span class="line">zhangming s003     -                14:35       - w</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="OS模块"><a href="#OS模块" class="headerlink" title="OS模块"></a>OS模块</h3><table>
<thead>
<tr>
<th>os.EOL</th>
<th>根据当前系统, 返回当前系统的 <code>End Of Line</code></th>
</tr>
</thead>
<tbody><tr>
<td>os.arch()</td>
<td>返回当前系统的 CPU 架构, 如 <code>&#39;x86&#39;</code> 和 <code>&#39;x64&#39;</code></td>
</tr>
<tr>
<td>os.constants</td>
<td>返回系统常量</td>
</tr>
<tr>
<td>os.cpus()</td>
<td>返回 CPU 每个核的信息</td>
</tr>
<tr>
<td>os.endianness()</td>
<td>返回 CPU 字节序, 如果是大端字节序返回 <code>BE</code>, 小端字节序则 <code>LE</code></td>
</tr>
<tr>
<td>os.freemem()</td>
<td>返回系统空闲内存的大小, 单位是字节</td>
</tr>
<tr>
<td>os.homedir()</td>
<td>返回当前用户的根目录</td>
</tr>
<tr>
<td>os.hostname()</td>
<td>返回当前系统的主机名</td>
</tr>
<tr>
<td>os.loadavg()</td>
<td>返回负载信息</td>
</tr>
<tr>
<td>os.networkInterfaces()</td>
<td>返回网卡信息 (类似 <code>ifconfig</code>)</td>
</tr>
<tr>
<td>os.platform()</td>
<td>返回编译时指定的平台信息, 如 <code>win32</code>, <code>linux</code>, 同 <code>process.platform()</code></td>
</tr>
<tr>
<td>os.release()</td>
<td>返回操作系统的分发版本号</td>
</tr>
<tr>
<td>os.tmpdir()</td>
<td>返回系统默认的临时文件夹</td>
</tr>
<tr>
<td>os.totalmem()</td>
<td>返回总内存大小(同内存条大小)</td>
</tr>
<tr>
<td>os.type()</td>
<td>根据 <code>[uname](https://en.wikipedia.org/wiki/Uname#Examples)</code> 返回系统的名称</td>
</tr>
<tr>
<td>os.uptime()</td>
<td>返回系统的运行时间，单位是秒</td>
</tr>
<tr>
<td>os.userInfo([options])</td>
<td>返回当前用户信息</td>
</tr>
</tbody></table>
<blockquote>
<p> 不同系统的换行符（EOL）的区别</p>
</blockquote>
<table>
<thead>
<tr>
<th>符号</th>
<th>系统</th>
</tr>
</thead>
<tbody><tr>
<td>LF（\n）</td>
<td>在 Unix 或 Unix 相容系统 (GNU/Linux, AIX, Xenix, Mac OS X, …)、BeOS、Amiga、RISC OS</td>
</tr>
<tr>
<td>CR+LF</td>
<td>MS-DOS、微软视窗操作系统 (Microsoft Windows)、大部分非 Unix 的系统</td>
</tr>
<tr>
<td>CR  (\r)</td>
<td>Apple II 家族, Mac OS 至版本9</td>
</tr>
</tbody></table>
<h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><p>​    Node.js 内置的 path 是用于处理路径问题的模块. 不过众所周知, 路径在不同操作系统下又不可调和的差异。所以不要自己随便拼接路径，要使用<code>Path.join()</code>或者<code>Path.resolve()</code>。</p>
<table>
<thead>
<tr>
<th>POSIX</th>
<th>值</th>
<th>Windows</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>path.posix.sep</td>
<td><code>&#39;/&#39;</code></td>
<td>path.win32.sep</td>
<td><code>&#39;\\&#39;</code></td>
</tr>
<tr>
<td>path.posix.normalize(‘/foo/bar//baz/asdf/quux/..’)</td>
<td><code>&#39;/foo/bar/baz/asdf&#39;</code></td>
<td>path.win32.normalize(‘C:\temp\foo\bar..&#39;)</td>
<td><code>&#39;C:\\temp\\foo\\&#39;</code></td>
</tr>
<tr>
<td>path.posix.basename(‘/tmp/myfile.html’)</td>
<td><code>&#39;myfile.html&#39;</code></td>
<td>path.win32.basename(‘C:\temp\myfile.html’)</td>
<td><code>&#39;myfile.html&#39;</code></td>
</tr>
<tr>
<td>path.posix.join(‘/asdf’, ‘/test.html’)</td>
<td><code>&#39;/asdf/test.html&#39;</code></td>
<td>path.win32.join(‘/asdf’, ‘/test.html’)</td>
<td><code>&#39;\\asdf\\test.html&#39;</code></td>
</tr>
<tr>
<td>path.posix.relative(‘/root/a’, ‘/root/b’)</td>
<td><code>&#39;../b&#39;</code></td>
<td>path.win32.relative(‘C:\a’, ‘c:\b’)</td>
<td><code>&#39;..\\b&#39;</code></td>
</tr>
<tr>
<td>path.posix.isAbsolute(‘/baz/..’)</td>
<td><code>true</code></td>
<td>path.win32.isAbsolute(‘C:\foo..’)</td>
<td><code>true</code></td>
</tr>
<tr>
<td>path.posix.delimiter</td>
<td><code>&#39;:&#39;</code></td>
<td>path.win32.delimiter</td>
<td><code>&#39;,&#39;</code></td>
</tr>
<tr>
<td>process.env.PATH</td>
<td><code>&#39;/usr/bin:/bin&#39;</code></td>
<td>process.env.PATH</td>
<td><code>C:\Windows\system32;C:\Program Files\node\&#39;</code></td>
</tr>
<tr>
<td>PATH.split(path.posix.delimiter)</td>
<td><code>[&#39;/usr/bin&#39;, &#39;/bin&#39;]</code></td>
<td>PATH.split(path.win32.delimiter)</td>
<td><code>[&#39;C:\\Windows\\system32&#39;, &#39;C:\\Program Files\\node\\&#39;]</code></td>
</tr>
</tbody></table>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><table>
<thead>
<tr>
<th>环境变量</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td><code>NODE_DEBUG=module[,…]</code></td>
<td>指定要打印调试信息的核心模块列表</td>
</tr>
<tr>
<td><code>NODE_PATH=path[:…]</code></td>
<td>指定搜索目录模块路径的前缀列表</td>
</tr>
<tr>
<td><code>NODE_DISABLE_COLORS=1</code></td>
<td>关闭 REPL 的颜色显示</td>
</tr>
<tr>
<td><code>NODE_ICU_DATA=file</code></td>
<td>ICU (Intl object) 数据路径</td>
</tr>
<tr>
<td><code>NODE_REPL_HISTORY=file</code></td>
<td>持久化存储REPL历史文件的路径</td>
</tr>
<tr>
<td><code>NODE_TTY_UNSAFE_ASYNC=1</code></td>
<td>设置为1时, 将同步操作 stdio (如 console.log 变成同步)</td>
</tr>
<tr>
<td><code>NODE_EXTRA_CA_CERTS=file</code></td>
<td>指定 CA (如 VeriSign) 的额外证书路径</td>
</tr>
</tbody></table>
<h3 id="负载"><a href="#负载" class="headerlink" title="负载"></a>负载</h3><p>​    负载是衡量服务器运行状态的一个重要概念. 通过负载情况, 我们可以知道服务器目前状态是清闲, 良好, 繁忙还是即将 crash。</p>
<p>​    PM2管理node进程，<a target="_blank" rel="noopener" href="https://wohugb.gitbooks.io/pm2/content/features/quick-start.html">pm2入门</a></p>
<h2 id="错误处理-调试"><a href="#错误处理-调试" class="headerlink" title="错误处理/调试"></a><a target="_blank" rel="noopener" href="https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md">错误处理/调试</a></h2><h3 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h3><blockquote>
<p>在 Node.js 中的错误主要有一下四种类型：</p>
</blockquote>
<table>
<thead>
<tr>
<th>错误</th>
<th>名称</th>
<th>触发</th>
</tr>
</thead>
<tbody><tr>
<td>Standard JavaScript errors</td>
<td>标准 JavaScript 错误</td>
<td>由错误代码触发</td>
</tr>
<tr>
<td>System errors</td>
<td>系统错误</td>
<td>由操作系统触发</td>
</tr>
<tr>
<td>User-specified errors</td>
<td>用户自定义错误</td>
<td>通过 throw 抛出</td>
</tr>
<tr>
<td>Assertion errors</td>
<td>断言错误</td>
<td>由 <code>assert</code> 模块触发</td>
</tr>
</tbody></table>
<blockquote>
<p>其中标准的 JavaScript 错误常见有：</p>
</blockquote>
<ul>
<li>EvalError: 调用 eval() 出现错误时抛出该错误</li>
<li>SyntaxError: 代码不符合 JavaScript 语法规范时抛出该错误</li>
<li>RangeError: 数组越界时抛出该错误</li>
<li>ReferenceError: 引用未定义的变量时抛出该错误</li>
<li>TypeError: 参数类型错误时抛出该错误</li>
<li>URIError: 误用全局的 URI 处理函数时抛出该错误</li>
</ul>
<blockquote>
<p>在 Node.js 中错误处理主要有一下几种方法:</p>
</blockquote>
<ul>
<li><p>callback(err, data) 回调约定</p>
</li>
<li><p>throw / try / catch</p>
</li>
<li><p>EventEmitter 的 error 事件</p>
</li>
</ul>
<p>​    <a target="_blank" rel="noopener" href="https://github.com/joyent/node-verror">vError模块</a>让 Error 一层层封装, 并在每一层将错误的信息一层层的包上, 最后拿到的 Error 直接可以从 message 中获取用于定位问题的关键信息.</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><h4 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h4><p>​    黑盒测试 (Black-box Testing), 测试应用程序的功能, 而不是其内部结构或运作. 测试者不需了解代码、内部结构等, 只需知道什么是应用应该做的事, 即当键入特定的输入, 可得到一定的输出. 测试者通过选择<code>有效输入</code>和<code>无效输入</code>来验证是否正确的输出. 此测试方法可适合大部分的软件测试, 例如集成测试 (Integration Testing) 以及系统测试 (System Testing)。</p>
<h4 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h4><p>​    白盒测试 (White-box Testing) 测试应用程序的内部结构或运作, 而不是测试应用程序的功能 (即黑盒测试). 在白盒测试时,以编程语言的角度来设计测试案例. 白盒测试可以应用于单元测试 (Unit Testing)、集成测试 (Integration Testing) 和系统的软件测试流程, 可测试在集成过程中每一单元之间的路径, 或者主系统跟子系统中的测试。</p>
<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>​    单元测试 (Unit Testing) 是白盒测试的一种, 用于针对程序模块进行正确性检验的测试工作. 单元 (Unit) 是指<strong>最小可测试的部件</strong>. 在过程化编程中, 一个单元就是单个程序、函数、过程等; 对于面向对象编程, 最小单元就是方法, 包括基类、抽象类、或者子类中的方法。</p>
<h4 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h4><p>覆盖率通常由四个维度贡献:</p>
<ul>
<li><p>行覆盖率 (line coverage) 是否每一行都执行了？</p>
</li>
<li><p>函数覆盖率 (function coverage) 是否每个函数都调用了？</p>
</li>
<li><p>分支覆盖率 (branch coverage) 是否每个if代码块都执行了？</p>
</li>
<li><p>语句覆盖率 (statement coverage) 是否每个语句都执行了？</p>
</li>
</ul>
<p>常用的测试覆盖率框架 <a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2015/06/istanbul.html">istanbul</a></p>
<h4 id="常见测试工具"><a href="#常见测试工具" class="headerlink" title="常见测试工具"></a>常见测试工具</h4><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/mochajs/mocha">Mocha</a></li>
<li>ava</li>
<li>Jest</li>
</ul>
<h4 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h4><p>​    压力测试 (Stress testing), 是保证系统稳定性的一种测试方法. 通过预估系统所需要承载的 QPS, TPS 等指标, 然后通过如 <a target="_blank" rel="noopener" href="http://jmeter.apache.org/">Jmeter</a> 等压测工具模拟相应的请求情况, 来验证当前应能能否达到目标。</p>
<h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><ul>
<li>Assert<ul>
<li>Node.js 中内置的 <code>assert</code> 模块也是属于断言模块的一种, 但是官方在文档中有注明, 该内置模块主要是用于内置代码编写时的基本断言需求, 并不是一个通用的断言库 (<strong>not intended to be used as a general purpose assertion library</strong>)</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/chaijs/chai">Chai</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/shouldjs/should.js">should.js</a></li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/node-js/">node.js</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></div><div class="post_share"></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">ruomu</div><div class="author-info__description">贪安稳就没有自由，要自由就要历些危险，只有这两条路。</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ruomuc"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ruomuc" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:zm252615299@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98"><span class="toc-text">JavaScript基础问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-text">类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="toc-text">类型判断</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#typeof%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">typeof操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">一般数据类型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">特殊的数据类型</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#instanceof%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">instanceof操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#constructor%E5%B1%9E%E6%80%A7"><span class="toc-text">constructor属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#toString%E6%96%B9%E6%B3%95"><span class="toc-text">toString方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83"><span class="toc-text">类型比较</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E7%AD%89"><span class="toc-text">全等&#x3D;&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89"><span class="toc-text">相等&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Object-is-value1-value2"><span class="toc-text">Object.is(value1,value2)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#var%E5%92%8Clet%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">var和let的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#const"><span class="toc-text">const</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-text">闭包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="toc-text">值传递和引用传递？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">深拷贝和浅拷贝</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-text">内存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#v8%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-text">v8内存的大小</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#v8%E5%86%85%E5%AD%98%E6%B8%85%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-text">v8内存清理机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E7%9A%84%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98"><span class="toc-text">如何高效的使用内存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-text">内存泄露</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7"><span class="toc-text">性能监控</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#es6%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">es6基本语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97"><span class="toc-text">模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6-%E5%BC%82%E6%AD%A5"><span class="toc-text">事件&#x2F;异步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#promise"><span class="toc-text">promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Events"><span class="toc-text">Events</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E-%E5%BC%82%E6%AD%A5"><span class="toc-text">阻塞&#x2F;异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Event-loop"><span class="toc-text">Event-loop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C-%E5%B9%B6%E5%8F%91"><span class="toc-text">并行&#x2F;并发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#process"><span class="toc-text">process</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E6%B5%81"><span class="toc-text">标准流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Child-Process"><span class="toc-text">Child Process</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cluster"><span class="toc-text">Cluster</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">进程间通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-text">守护进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO"><span class="toc-text">IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer"><span class="toc-text">Buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFBuffer"><span class="toc-text">什么是Buffer?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer%E6%94%AF%E6%8C%81%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%EF%BC%9F"><span class="toc-text">Buffer支持的字符编码？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BABuffer%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">创建Buffer实例的方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-text">Buffer常用操作？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-Decoder"><span class="toc-text">String Decoder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream"><span class="toc-text">Stream</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">流的类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netword"><span class="toc-text">Netword</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%98%E5%8C%85"><span class="toc-text">粘包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP"><span class="toc-text">UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP"><span class="toc-text">HTTP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS"><span class="toc-text">DNS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC"><span class="toc-text">RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84RPC%E6%96%B9%E5%BC%8F"><span class="toc-text">常见的RPC方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OS"><span class="toc-text">OS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TTY"><span class="toc-text">TTY</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OS%E6%A8%A1%E5%9D%97"><span class="toc-text">OS模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Path"><span class="toc-text">Path</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">环境变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD"><span class="toc-text">负载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-%E8%B0%83%E8%AF%95"><span class="toc-text">错误处理&#x2F;调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Errors"><span class="toc-text">Errors</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-text">测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95"><span class="toc-text">测试方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-text">黑盒测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-text">白盒测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">单元测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%8E%87"><span class="toc-text">覆盖率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-text">常见测试工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95"><span class="toc-text">压力测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%AD%E8%A8%80"><span class="toc-text">断言</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/27/go%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%E5%9E%8B/" title="go的接口和类型">go的接口和类型</a><time datetime="2022-02-27T06:01:33.000Z" title="更新于 2022-02-27 14:01:33">2022-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2018/07/31/V8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6/" title="V8的垃圾回收机制和内存限制">V8的垃圾回收机制和内存限制</a><time datetime="2022-01-01T06:34:31.000Z" title="更新于 2022-01-01 14:34:31">2022-01-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/12/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3nodejs%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" title="深入理解nodejs内存分配">深入理解nodejs内存分配</a><time datetime="2021-12-25T03:26:22.000Z" title="更新于 2021-12-25 11:26:22">2021-12-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/12/11/%E5%9B%9A%E5%BE%92%E5%81%A5%E8%BA%AB/" title="囚徒健身">囚徒健身</a><time datetime="2021-12-12T05:54:35.000Z" title="更新于 2021-12-12 13:54:35">2021-12-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/08/29/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0%E7%A7%81%E6%9C%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/" title="博客迁移到私有服务器上">博客迁移到私有服务器上</a><time datetime="2021-08-29T08:23:59.000Z" title="更新于 2021-08-29 16:23:59">2021-08-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://blog-1301153828.cos.ap-shanghai.myqcloud.com/forestroad.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2022 By ruomu</div><div class="footer_custom_text">welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'hVxwhszrh6HIYuh0m6Bmtvoo-gzGzoHsz',
      appKey: 'h09HacDfMwbAWQMgWw6D07Tb',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://unpkg.com/valine@1.4.18/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.bootcdn.net/ajax/libs/canvas-nest.js/2.0.4/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>