---
title: MySql必知必会
categories:
  - 数据库
tags:
  - mysql
date: 2019-02-12 22:05:50
updated: 2019-02-12 22:05:50

---
虽然mysql已经用了很久了，但都是一些零零散散的，前不久买了《mysql必知必会》这本书看了两遍。然后整理一下，忘了还可以来查。

## 数据库基础
数据库（database）：保存有组织的数据的容器（通常是一个文件或一组文件）

表（table）：某种特定类型数据的结构化清单。表的名字在同一数据库中是唯一的。

列（column）：表中的一个字段，所有的表都是由一个列或多个列组成的。列的名字在同一表中是唯一的。

数据类型：每个表列都会有所容许的数据类型，它限制该列所存储的数据的类型。

行（row）：表中的一条记录。

主键（primary key）：表中的每一行都有可以唯一表示自己的一列。
- 任意两行都不具有相同的主键值
- 每个行都必须拥有主键值，主键值不允许为null

## 使用mysql
虽然平时开发和部署用的都是navicat。

登录mysql：`mysql -u<uname> -p<pswd>` 例如 `mysql -uroot -proot`
上述命令等同于 `mysql -h localhost -uroot -proot ` 这里的`localhost`指的是本地，远程改为对应ip地址即可。

关键字：和编程语言一样，mysql也有自己的关键字（保留字），数据库里的命令不要使用关键字。

展示这账号下所有的数据库：`SHOW DATABASES`,打开名为aaa的数据库：`USE aaa`，只有打开数据库之后才能操作数据库。然后，展示aaa中所有的表：`SHOW TABLES`。展示abb表中的所有列信息：`SHOW COLUMNS FROM abb`。

可以输入`help show`来显示更多关于 SHOW 的命令。

## 检索数据
检索单个列：`SELECT 列名 FROM 表名`

检索多个列：`SELECT 列名1,列名2,列名3... FROM 表名`

检索所有列：`SELECT * FROM 表名`

检索不同的行：`SELECT DISTINCT 列名 FROM 表名`
- DISTINCT 关键字表示返回不重复的数据，并且不能给指定列使用，必须放在检索的所有列名前面，对所有检索列生效。

限制结果：`SELECT 列名 FROM 表名 LIMIT 5`检索出前5行
- LIMIT 关键字
- LIMIT 5,5 返回下一个五行，从行5到行9即第六行到第十行。  行是从行0开始的即第一行。
- LIMIT 5 OFFSET 5  为了防止搞糊涂，这种写法表示从行5往后取5行。更容易理解。等价于 LIMIT 5,5

完全限定表名：`SELECT 表名.列名 FROM 表名`，在后面的关联查询很有用，不会搞混不同表中列名相同的列。

##排序检索数据
子句：SQL语句由子句构成，有些子句是必需的，而有些子句是可选的。一个子句通常由一个关键字和所提供的数据组成。

ORDER BY
- `SELECT 列名 FROM 表名 ORDER BY 列名` 表示根据某一列来排序检索出来的数据
- `SELECT 列名 FROM 表名 ORDER BY 列名1 ,列名2` 根据多个列名排序，先按找列名1排序，如果列名1数据相同，再按照列名2排序。

ORDER BY 列名 DESC(ASC)
- ASC和不写相同即降序排列，DESC是升序排列
- DESC只作用域它前面的列名，如果要给多个列名降序排列，则每个列名后面都要跟 DESC

## 过滤数据
##### 使用WHERE 子句过滤数据。
`SELECT 列名1,列名2 FROM 表名 WHERE 列名 = 值1`。获取列名 = 值1 的列名1 和列名2 的数据。
- `=` 等于
- `<> `和 != 不等于
- `<` 小于
- `<=` 小于等于
- `>` 大于
- `>= `大于等于
- `BETWEEN a AND b ` 介于a和b之间
- ` IS (NOT) NULL` 判断空值和 非空不能用等于和不等于

##### 组合WHERE子句

`AND`操作符：
- `SELECT 列1,列2 FROM 表名 WHERE 列3 = 值1 AND 列4 = 值2` 使用`AND`连接多个条件进行过滤。
- `AND`操作符连接条件不限个数，没加一条条件都要用`AND`连接。

`OR`操作符：
- 用法与`AND`相同，只不过把 “与”变为了 “或”

`AND`与`OR`混用：
- 类似于编程语言。“与”的优先级是比“或”高的。所以先算`AND`再算`OR`。

`IN`操作符：
- `SELECT 列名 FROM 表名 WHERE 列1 = 值1 OR 列1 = 值2`等价于`SELECT 列名 FROM 表名 WHERE 列1 IN(值1,值2)`
- 用来匹配多个值，并且`IN`的运算速度要比`OR`快一点。

`NOT`运算符：
- `NOT`运算符用来否定跟在其后的条件，简单的语句没有用，复杂的语句可能会用到。
- `SELECT 列名 FROM 表名 WHERE 列1 NOT IN(值1,值2)` 查找列1不等于 值1或值2的数据。

##### 通配符过滤
通配符：用来匹配值的一部分的特殊字符。
搜索模式：由字面值、通配符或两者结合构成的搜索条件。
为了在搜索子句中使用通配符，必须使用`LIKE`操作符。LIKE指示MySql后跟的搜索模式利用通配符而不是直接相等匹配进行比较。

###### 百分号通配符`%`：表示任意字符出现任意次数
- `SELECT 列1,列2 FROM 表名 WHERE 列3 LIKE 'jet%'` 这条语句会搜索列3的值中以`jet`开头的数据。比如：jet12、jet1234 aa
- `SELECT 列1,列2 FROM 表名 WHERE 列3 LIKE '%jet%'`这条语句会搜索列3中包含jet的数据。比如 12jet34、ajetad


###### 下划线通配符`_`:用法和`%`一样只不过下划线通配符只匹配单个字符而不是多个字符。

###### 通配符使用技巧：
- 不要过度使用通配符。
- 在必须使用通配符是，除非非常必要，否则不要把它们用在搜索模式的开始处。
- 仔细注意通配符的位置。

##### 用正则表达式进行搜索
与通配符不通的是将`LIKE`关键字替换成了`REGEXP`。正则表达式用在很多地方，并不是只有数据库有。。
###### 基本字符匹配
- `SELECT 列1,列2 FROM 表名 WHERE 列3 REGEXP '1000' ORDER BY 列1`这里的意思就是匹配列3的值1000的数据，这里的正则和等于结果相同。
- `SELECT 列1,列2 FROM 表名 WHERE 列3 REGEXP '.000' ORDER BY 列1` 这里的“.”是任意字符的意思，所以会找到 1000、2000、3000这些值。

###### 进行OR匹配
- `SELECT 列1,列2 FROM 表名 WHERE 列3 REGEXP '1000|2000' ORDER BY 列1`，这里的“|”表示或的意思，匹配值为1000或者2000。

###### 匹配几个字符之一
- `SELECT 列1,列2 FROM 表名 WHERE 列3 REGEXP '[123]000' ORDER BY 列1`这里的“[]”表示或的意思，匹配值为 1000或2000或3000。
- `[123]000`和`[1|2|3]000`相同。

###### 匹配范围
例如匹配0-9可以这样写[0123456789]，也可以这样写[0-9]。
[a-z]表示匹配任意小写字母
ps:这个好像是按照ASCII码的顺序来的。

<!--more-->
###### 匹配特殊字符
只需要在特殊字符前面加“\\”反斜杠就可以了，一般的正则加一个反斜杠就可以了，这里加两个是因为一个用于数据库解释，另一个用于正则表达式库解释。
`\\f 换页  \\n   \\r   \\t \\v  \\. \\*`。

###### 匹配字符类
可以使用预定义的字符集，比如[:alnum:]代表任意字母和数字 同 [a-zA-Z0-9]。
这个在书上的P76页有个表。网上应该也能搜到就不写了。
###### 匹配多个实例
重复元字符
- `*` 0或多个匹配
- `+` 1或多个匹配
- `?` 0或1个匹配
- `{n}` 指定数目个匹配
- `{n,}` 不少于指定数目个匹配
- `{n,m}` 指定数目范围个匹配

###### 定位符
为了匹配特定位置的文本
- `^`文本的开始
- `$`文本的结尾
- `[[:<:]]`词的开始
- `[[:>:]]`词的结尾

ps:后面两个我也不知道怎么用的

LIKE和REGEXP的不同在于，LIKE匹配整个串，而REGEXP匹配字串，所有给正则前后加上定位符 `^``$`就可以使REGEXP的作用于LIKE一样。ps:闲的蛋疼吧。

##### 创建计算字段
如果存储在表中的数据不是应用程序所需要的，我们需要直接从数据库检索出转换、计算或格式化的数据，而不是检索，再在应用程序中处理和格式化，这是就需要使用到计算字段了。计算字段是运行在SELECT语句内创建的。
字段：基本上与列的意思相同，经常互换使用。
###### 拼接字段 
拼接：将值联结到一起构成单个值。
- `Concat()`函数把多个串拼接起来形成一个较长的串，指定一个或多个串，各个串之间使用逗号连接。
- 多数DBMS使用“+”或“||”来实现拼接，Mysql使用Concat()实现。
- `SELECT Concat(列1,' (',列2,')') FROM 表名 WHERE 列3 REGEXP '[123]000' ORDER BY 列1` 这条语句最后的结果是`列1的数据（列2的数据）`比如` ACME (USA)`

###### 使用别名
前面的Concat()函数虽然拼成了一个较长的新串，但是这个串没有名字，没有名字的字段程序无法调用，于是需要使用别名来取一个名字。
- `SELECT Concat(列1,' (',列2,')') AS name1 FROM 表名 WHERE 列3 REGEXP '[123]000' ORDER BY 列1`把拼接的新的串取名叫name1
- 这是调用就可以用 data.name1来取值。
- 当然别名也可以在任何时候使用，比如数据库某个字段名字太长，或者名次相同或相似，都可以取别名。

###### 执行算数计算
可以对取出的字段进行加减乘除运算
-  `SELECT 列1 * 列2 AS name1 FROM 表名 WHERE 列3 REGEXP '[123]000' ORDER BY 列1` 这个表示取出列1和列2的值相乘之后的结果取名为name1，这个相当于只返回了一个字段的数据，因为被运算了。
-  同理还有 Trim()函数：去除左右空格 Now()函数：返回当前时间和日期

##### 使用数据处理函数
函数的缺点是可移植性不强，当使用函数时，应做好代码注释，以便以后能够确切的知道SQL代码的含义。
###### 文本处理函数
- `RTrim()` 去掉列值右边的空格。
- `Upper()` 将文本转换成大写。如下：
- `SELECT Upper(列1) AS name1 FROM 表名 WHERE 列3 REGEXP '[123]000' ORDER BY 列1`
- 类似的函数还有：
 - Left() 返回串左边的字符
 - Length() 返回串的长度
 - Locate() 找出串的一个子串
 - Lower() 将串转为小写
 - LTrim() 去掉串左边的空格
 - Right() 返回串右边的字符
 - Soundex() 返回串的SOUNDEX值

如果查找一个联系人为 "Y.Lie"的数据，但是子句的WHERE条件写成了 "Y.Lee"怎么办？
这时用Soundex()函数：`SELECT 列1 FROM 表名 WHERE Soundex(列3) = Soundex('Y.Lee') ORDER BY 列1`

###### 日期和时间处理函数
日期函数比较多常用的有
- Date() 返回日期时间的日期部分
- 数据库中的日期格式必须为：YYYY-MM-DD 时间格式：00:00:00
其他的见本书P71


###### 数值处理函数
常见的有
- Abs()返回绝对值
- Sqrt()返回平方根

更多见P74或百度谷歌

## 汇总数据（聚集函数）

###### 聚集函数
运行在数组上，计算和返回单个值的函数。

###### AVG()函数
AVG()通过对表中行数计数并计算特定列值之和，求得该列的平均值。AVG()可用来返回所有列的平均值，也可以用来返回特定列或行的平均值。
- `SELECT AVG(列1) AS name1 FROM 表名`
- `SELECT AVG(列1) AS name1 FROM 表名 WHERE 列2 = 值2`
- AVG()函数只能用来确定特定数值列的平均值，而且列名必须座位函数参数给出。为了获取多个列的平均值必须使用多个AVG函数。
- AVG()函数忽略列值为NULL的行

###### COUNT()函数
COUNT()函数进行计数，可利用COUNT()函数确定表中行的数目或符合条件的行的数目
- COUNT(*) 对表中行的数目进行计数，不管表列中包含的是空值（NULL）还会非空值。
- COUNT(column) 对特定列中具有值的进行计数，忽略NULL值。
- `SELECT COUNT(*) AS name1 FROM 表名` 获取表中行的数量
- `SELECT COUNT(列1) AS name1 FROM 表名` 获取表中列1值不为空的行的数量。

###### MAX()函数
MAX()函数返回指定列中的最大值，MAX()要求指定列名
- `SELECT MAX(列1) AS name1 FROM 表名`
- MAX()用于文本数据时，返回最后一行
- NAX()函数忽略列值为NULL的行

###### MIN()函数
MIN()函数功能正好和MAX()作用相反。规则相同。

###### SUM()函数
SUN()函数用来返回指定列值的和（总计）
- `SELECT MAX(列1) AS name1 FROM 表名` 也可以  `SELECT MAX(列1*列2) AS name1 FROM 表名`
- 如上所示，利用算数操作符再取合，所有聚集函数都可以用来执行多个列上的计算。
- SUM() 函数忽略列值为NULL的行

###### 聚集不同值
对于聚集函数：
- 指定ALL或者不给值（默认为ALL）为对所有的行执行计算
- 而 DISTINCT 参数为只计算不同的值（去重复）
- `SELECT SUM(DISTINCT 列1) AS name1 FROM 表名` 计算列1的和，但是不计算重复的值，即如果有列1有两行数据相同，只算一次。

注意：
- DISTINCT 不能用于COUNT(*)
- DISTINCT 必须使用列名，不能用于计算或表达式
- DISTINCT 可以理论上可以用于MAX()和MIN()函数，但没有实际意义。

###### 组合聚集函数
SELECT语句可以根据需要包含多个聚集函数。
- `SELECT MAX(列1) AS name1, MIN(列2) AS name2, AVG(列3) AS name3 FROM 表名`
- 使用较为复杂的语句是，尽量使用别名来避免混淆各个列。

PS:mysql的这些函数时高效的，他们返回结果一般比在程序里计算要快的多。

## 分组数据
###### 创建分组
分组是在SELECT语句的GROUP BY子句中建立的。
- `SELECT name ,COUINT(*) AS num FROM class GROUP BY name`
- 上面的查询语句指定了两个列，一个是name表示班级中的学生名字，一个是 COUNT(*)建立的num。
- 这里的COUNT(*)不会class表的总行数，因为使用了GROUP BY name，他会根据班级学生姓名分组，返回每个学生出现在class表中的行数。

GROUP BY 语句的相关规定：
- GROUP BY可以包含任意数目的列，这使得能对分组进行嵌套，为数据分组提供更细致的控制。
- 如果在GROUP BY 子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算。
- GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果SELECT中使用表达式，则必须在GROUP BY 子句中指定相同的表达式。不能使用别名。
- 除聚集函数外，SELECT语句中的每个列都必须需在GROUP BY子句中给出
- 如果分组列中具有NULL值，则NULL将作为一个分组返回，如果有多个NULL值，它们将分为一组。
- GROUP BY 子句必须出现在 WHERE 子句之后，ORDER BY子句之前。

###### 过滤分组
出了能常见分组之外，MySql还允许过滤分组。
过滤分组使用`HAVING`而不是`WHERE`。
- `SELECT name ,COUNT(*) AS num FROM class GROUP BY name HAVING COUNT(*) >= 2`这个和上面的区别是，不仅通过姓名进行分组查询出每一个姓名出现的行数，还通过HAVING COUNT(*) >= 2还会再次过滤掉少于两行的数据。
- `SELECT name ,COUNT(*) AS num FROM class WHERE age >= 14 GROUP BY name HAVING COUNT(*) >= 2`这个语句比其上面那条又多了一个过滤，就是年龄要大于14岁。

###### 分组和排序
虽然ORDER BY 和 GROUP BY很相似，但是他们是完全不同的。刚开始我很容易把他弄混淆，其实字面意思区别就很明显，一个是分组。一个是排序。

| ORDER BY | GROUOP BY |
|--------|--------|
|    排序产生的输出    |    分组行，但输出可能不是分组的顺序    |
| 任意列都可以使用，没有选择的列也可以 | 只能使用选择列或表达式列，而且必须使用每个选择列表达式列 |
| 不一定需要 | 如果与聚集函数一起使用列（或表达式），则必须使用 |

###### SELECT 子句顺序
`SELECT name ,COUNT(*) AS num FROM class WHERE age >= 14 GROUP BY name HAVING COUNT(*) >= 2 ORDER BY age LIMIT 5`
PS:上面一条语句就可以说明这些子句的使用顺序了。

## 使用子查询
###### 利用子查询进行过滤
如果一条SELECT语句的条件是另一条SELECT语句的查询结果，可以把两条语句以子查询的方式写在一起。
- `SELECT name ,COUNT(*) AS num FROM class WHERE age IN (SELECT age FROM grade WHERE score = 90)`
- 上面的语句显示查询出 score = 90 的age数据，然后再以这个age为条件从 class 表查出 name和总行数

###### 利用计算字段使用子查询
子查询不一定要写到WHERE后面当条件，也可以写在FROM前面当做一个输出字段。
- `SELECT name ,(SELECT age FROM grade WHERE score = 90) AS num FROM class WHERE age = 14`
- 上面语句想要从其他表里拿个字段一起返回回来，这样写可以少一次数据库的连接，可以尽可能的在一个语句中拿到自己想要的结果，不过子查询也不宜太过于复杂，过于复杂的语句不易阅读和移植。

## 联结表
###### 联结
SQL最强大的功能之一就是能在数据库检查查询的执行中联结（join）表。

###### 关系表
大概意思就是 假如有一张班级表，有一张成绩表，他们两个之间的联系就是姓名，可以通过姓名来讲两张表联结起来（相当于生成了一张包含了你所需要所有数据的虚拟表，这张表并不真正存在）。

**外键**:外键为某一个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。
- 利用主键和外键的好处：
- 信息不重复，节省空间
- 只更新一个表的数据，关系表的数据无需更改，没有重复数据，数据一致性好。

因此，关系数据库的可伸缩性远比非关系数据库要好。

###### 创建联结
创建联结非常简单，规定要联结带的所有表以及它们如何关联即可。
- `SELECT 列1,列2,列3 FROM 表1,表2 WHERE 表1.列名 = 表2.列名 ORDER BY 列3 ,列4`
- 上面的语句查询的三个字段，有的是表1的有的是表2的，通过完全限定列名 表1.列名 = 表2.列名 来联结两个表查询出所有数据。

**完全限定列名**：在引用的列可能出现二义性时，必须使用完全限定列名。

###### WHERE子句的重要性
- 在联结两个表时，你实际上做的是将第一张表中的每一行与第二张表中的每一行配对。WHERE子句作为过滤条件，它只包含那些匹配给定条件的行。
- 没有WHERE子句，第一个表中的每行将于第二张表的每个行配对，而不管它们逻辑上是否可以配在一起。
- 笛卡尔积：有没有联结条件的表关系返回的结果为笛卡尔积。检索出来的行数等于两表行数之积。
- 联结时应该保证所有联结都有WHERE子句。

###### 内部联结
上面的联结方式称为**等值联结**，它基于两个表之间的相等测试，也称为内部联结。
- `SELECT 列1,列2,列3 FROM 表1 INNER JOIN 表2 ON 表1.列名 = 表2.列名 ORDER BY 列3 ,列4`
- 上面的语句与前面的那条联结语句作用一样。只不过两表的关系由 `INNER JOIN`指定，联结条件使用特定的`ON`语句代替`WHERE`子句。

###### 联结多个表
SQL对一条SELECT语句中可以联结的表的数量没有限制。
- `SELECT 列1,列2,列3 FROM 表1,表2,表3 WHERE 表1.列名 = 表2.列名 AND 表2.列名 = 表3.列名 ORDER BY 列3 ,列4`
-  不要联结不必要的表，联结的表越多，性能下降越厉害。

PS:大部分联结是可以使用子查询实现的，实际使用时选择适合应用的具体方法就可以了，性能受各种因素的影响。

## 高级联结
###### 使用表别名
别名除了用于列名和计算字段外，SQL还允许给表名起别名
- 表别名不仅可以用于WHERE子句，还可以用于SELECT ，FROM ，ORDER BY 等。
- 表别名只在查询执行中使用，不返回客户机。。

##### 使用不同类型的联结
除了**内部联结**之外，还有**自联结**，**自然联结**，**外部联结**。
###### 自联结
自己联结自己。。。
- `SELECT 列1,列2, FROM 表1 WHERE 列3 = (SELECT 列3 FROM 表1 WHERE 列1 = "xxx")`子查询，现在表1中查询出列1的值为"xxx"的列3的值，再根据这个值在表1中查询出列1和列2的值
- 上面这个有点绕，引用书上的列子：假如你发现某件商品有问题，你想要知道这个物品的供货商提供的其他物品是否也有问题。此查询要求首先根据有问题的物品的ID找到它的供货商，然后再根据供货商的ID找到他提供的所有物品。
- `SELECT b1.列1,b1.列2, FROM 表1 AS b1 ,表1 AS b2 WHERE b1.列3 = b2.列3 AND b1.ID = 'xxx'`
- 上面的查询语句看起来挺诡异的，但是是合法的。看起来是b1和b2是同一个表，但在执行时是两个两个实例。

###### 自然联结
无论和是对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列）。**自然联结**排除多次出现，使每个列只返回一次，并且这个操作不是系统完成的，而是自己完成的。
- `SELECT  b1.*,b1.列2, FROM 表1 AS b1 ,表1 AS b2 WHERE b1.列3 = b2.列3 AND b1.ID = 'xxx'`
- 上面的通配符只对b1表生效，其他的列明确指出。没有重复的列被检索出来。
- 我们建立的所有 内部联结 都是自然联结，或许我们永远都不会用到不是 自然联结 的 内部联结。

###### 外部联结
外部联结分为左外部联结`LEFT OUTER JOIN`和由外部联结`RIGHT OUTER JOIN`。
- `SELECT * FROM 表1 AS b1 LEFT OUTER JOIN 表1 AS b2 ON b1.id = b2.roomid`
- 上面这句查询选择b1表中的所有行去关联b2表，如果b1表有三行数据，那么最终结果也是三行
- `SELECT * FROM 表1 AS b1 RIGHT OUTER JOIN 表1 AS b2 ON b1.id = b2.roomid`
- 上面这句查询选择b2表中的所有行去关联b1表，如果b2表有10行数据，那么最终结果也是10行

PS：所有由上可知 两种外部联结完全可以替换使用。

###### 带聚集函数的联结

`SELECT b1.列1,b1.列2,COUNT(b2.列3) FROM 表1 AS b1 INNER JOIN 表2 AS b2 ON 表1.列名 = 表2.列名 ORDER BY 列3 ,列4`
没有太大区别，正常的聚集函数使用方式。


###### 使用联结和联结条件
- 一般我们使用内部联结。外部联结也是有效的。
- 保证使用正确的联结条件。
- 应该总是提供联结条件，否则会出现**笛卡尔积**。
- 在一个联结中联结多个表，甚至每个联结都可以采取不用的联结类型，这样做是合法的，但是应该在使用前分别测试。

## 组合查询
###### 组合查询
MySql允许执行多个查询，并将结果作为单个查询结果返回。
有两种基本情况，其中需要使用到组合查询：
- 在单个查询中从不同的表返回类似结构的数据
- 对单个表执行多个查询，按单个查询返回数据
- 任何具有多个WHERE子句的SELECT语句都可以作为一个组合查询给出

###### 创建组合查询
使用UNION连接多条查询语句即可。
- `SELECT 列1 FROM 表1 WHERE 列3 = 1 UNION SELECT 列1 FROM 表2 WHERE 列4 = 233`

###### UNION的使用规则
- UNION必须由两条以上的SELECT语句组成，语句之间使用关键字UNION分隔
- UNION中的每个查询必须包含相同的列、表达式或聚集函数（出现次序可以不相同）
- 列数据类型必须兼容，不必完全相同，但是必须是DBMS可以隐含转换的类型。

###### 包含取消重复的行
UNION从查询结果集中自动去除了重复行。
去除重复行是UNION的默认行为，如果不想去除，则使用 `UNION ALL`代替`UNION`。

###### 排序组合查询的结果
如果需要对结果使用ORDER BY排序是，只能在最后一条SELECT 语句的末尾使用 ORDER BY。

PS:因为每个查询包含相同的列，其实这个挺合理的。

## 全文本搜索
MySql最常用的引擎为 MyISAM 和 InnoDB
书上说的是：MyISAM不支持事务，支持全文本搜索 而 InnoDB 不支持 全文本搜索，支持事务。
但是在 MySql 5.7以后 InnoDB也支持全文本搜索。
[>>>更多区别传送门](https://blog.csdn.net/xlgen157387/article/details/68978320)

前面介绍了LIKE关键字，它利用通配符操作符匹配文本，还有正则表达式可以实现更加复杂的匹配模式。

PS:这里相对比较高级了，其实日常的使用基本使用不到。这本书估计是针对数据库管理员的吧，平常很多还没用到 orz。

##### 使用全文本搜索





未完待续。。。

