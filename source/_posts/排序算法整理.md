---
title: 排序算法整理
categories:
  - 数据结构与算法
tags:
  - 算法
  - 排序算法
date: 2021-04-17 15:16:54
updated: 2021-6-13 14:10:46
cover: https://proxy.qnoss.seeln.com/images/wp4202367-aconcagua-wallpapers.jpg
---

如题，整理一下常用的排序算法，方便用的时候好找（~~虽然基本也用不到~~）。

这里推荐一个网站，https://visualgo.net/en

本文完整可执行代码地址：[github](https://github.com/ruomuc/test_demos/tree/master/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86)
<!--more-->

## 冒泡排序

- 冒泡排序
- **稳定**的排序算法
- 平均时间复杂度 O(n²)
- 空间复杂度 O(1)

```go
// nums 需要排序的数组
// order ASC-升序 DESC-降序
func bubblePop(nums []int, order string) []int {
	for i := range nums {
		for j := 0; j < len(nums)-i-1; j++ {
			if nums[j] > nums[j+1] && order == "ASC" || nums[j] < nums[j+1] && order == "DESC" {
				nums[j], nums[j+1] = nums[j+1], nums[j]
			}
		}
	}
	return nums
}
```

## 插入排序

- 插入排序
- **稳定**的排序算法
- 平均时间复杂度 O(n²)
  - 最好情况：输入已经排好序时为O(n)
  - 最坏情况：输入逆序时为 O(n²)
- 空间复杂度 O(1)


```go
func insertSort(nums []int, order string) []int {
	for i := 1; i < len(nums); i++ {
		key := nums[i]
		j := i - 1
		if order == "ASC" {
			for j >= 0 && nums[j] > key {
				nums[j+1] = nums[j]
				j--
			}
		} else if order == "DESC" {
			for j >= 0 && nums[j] < key {
				nums[j+1] = nums[j]
				j--
			}
		}
		nums[j+1] = key
	}
	return nums
}
```

## 快速排序

- 快速排序
- **不稳定**的排序算法
- 平均时间复杂度 O(nlgn)
  - 最好情况： O(nlgn)
  - 最坏情况下，输入逆序，时间复杂度为 O(n²)
- 平均空间复杂度 O(lgn)
	- 最好情况：O(lgn)
	- 最快情况：O(n)
- 核心思想：分治

```go
func quickSort(arr []int, left int, right int, order string) {
	if left >= right {
		return
	}
	i, j := left, right
	// 选取基准元素
	pivot := left
	for i < j {
		if order == "ASC" {
			for arr[j] >= arr[pivot] && i < j {
				j--
			}
			for arr[i] <= arr[pivot] && i < j {
				i++
			}
		}
		if order == "DESC" {
			for arr[j] <= arr[pivot] && i < j {
				j--
			}
			for arr[i] >= arr[pivot] && i < j {
				i++
			}
		}
		arr[i], arr[j] = arr[j], arr[i]
	}
	arr[i], arr[pivot] = arr[pivot], arr[i]
	// 递归处理
	quickSort(arr, left, j-1, order)
	quickSort(arr, j+1, right, order)
}
```

## 归并排序

- 归并排序
- **稳定的**排序算法
- 平均时间复杂度 O(nlgn)
  - 最好情况： O(nlgn)
  - 最差情况： O(nlgn)
- 空间复杂度 O(n)
- 核心思想：分治

```go
func mergeSort(nums []int, order string) {
	var divide func(left, right int)
	var merge func(left, right, mid int)

	divide = func(left, right int) {
		if left >= right {
			return
		}
		mid := (left + right) / 2
		divide(left, mid)
		divide(mid+1, right)
		merge(left, right, mid)
	}

	merge = func(left, right, mid int) {
		temp := make([]int, 0)
		p1, p2 := left, mid+1

		if order == "ASC" {
			for p1 <= mid && p2 <= right {
				// 升序小的在前
				if nums[p1] <= nums[p2] {
					temp = append(temp, nums[p1])
					p1++
				} else {
					temp = append(temp, nums[p2])
					p2++
				}
			}
		} else if order == "DESC" {
			for p1 <= mid && p2 <= right {
				// 降序大的在前
				if nums[p1] >= nums[p2] {
					temp = append(temp, nums[p1])
					p1++
				} else {
					temp = append(temp, nums[p2])
					p2++
				}
			}
		}

		// 处理单边的情况
		for p1 <= mid {
			temp = append(temp, nums[p1])
			p1++
		}
		for p2 <= right {
			temp = append(temp, nums[p2])
			p2++
		}
		// 把排好序的元素，拷贝到源数组上
		for i := left; i <= right; i++ {
			nums[i] = temp[0]
			temp = temp[1:]
		}
	}
	divide(0, len(nums)-1)
}
```

## 选择排序

- 选择排序
- **不稳定的**排序算法
- 平均时间复杂度 O(n²)
- 空间复杂度 O(1)

```go
func selectionSort(nums []int, orderType string) {
	n := len(nums)
	for i := range nums[1:] {
		tempIdx := i
		if orderType == "ASC" {
			for j := i + 1; j < n; j++ {
				if nums[j] < nums[tempIdx] {
					tempIdx = j
				}
			}
		} else if orderType == "DESC" {
			for j := i + 1; j < n; j++ {
				if nums[j] > nums[tempIdx] {
					tempIdx = j
				}
			}
		}
		nums[i], nums[tempIdx] = nums[tempIdx], nums[i]
	}
}
```

## 堆排序

- 堆排序
- **不稳定的**排序算法
- 平均时间复杂度 O(nlgn)
- 平均空间复杂度 O(1)

```go
func heapSort(arr []int, orderType string) {
	length := len(arr)
	if orderType == "ASC" {
		// 创建最大堆
		buildMaxHeap(arr, length)
		// 把堆顶元素放到数组最后
		// 然后调整除了最后一个元素的最大堆
		// 重复
		for i := length - 1; i >= 0; i-- {
			arr[0], arr[i] = arr[i], arr[0]
			length--
			maxHeadpify(arr, 0, length)
		}
	} else if orderType == "DESC" {
		// 创建最小堆
		buildMinHeap(arr, length)
		for i := length - 1; i >= 0; i-- {
			arr[0], arr[i] = arr[i], arr[0]
			length--
			minHeadpify(arr, 0, length)
		}
	}
}

// 建立最大堆
func buildMaxHeap(arr []int, length int) {
	for i := length / 2; i >= 0; i-- {
		maxHeadpify(arr, i, length)
	}
}

// 调整最大堆
func maxHeadpify(arr []int, i, length int) {
	left := 2*i + 1
	right := 2*i + 2
	largest := i

	if left < length && arr[left] > arr[largest] {
		largest = left
	}
	if right < length && arr[right] > arr[largest] {
		largest = right
	}
	if largest != i {
		arr[i], arr[largest] = arr[largest], arr[i]
	}
}

// 创建最小堆
func buildMinHeap(arr []int, length int) {
	for i := length / 2; i >= 0; i-- {
		minHeadpify(arr, i, length)
	}
}

// 调整最小堆
func minHeadpify(arr []int, i, length int) {
	left := 2*i + 1
	right := 2*i + 2
	minimum := i

	if left < length && arr[left] < arr[minimum] {
		minimum = left
	}
	if right < length && arr[right] < arr[minimum] {
		minimum = right
	}
	if minimum != i {
		arr[i], arr[minimum] = arr[minimum], arr[i]
	}
}

```







最后更新时间 2021年6月13日14:11:27

未完待续~

